<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[雷纯锋的技术博客]]></title>
  <link href="http://leichunfeng.github.io/atom.xml" rel="self"/>
  <link href="http://leichunfeng.github.io/"/>
  <updated>2015-11-09T11:52:46+08:00</updated>
  <id>http://leichunfeng.github.io/</id>
  <author>
    <name><![CDATA[雷纯锋]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Functor、Applicative 和 Monad]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/11/08/functor-applicative-and-monad/"/>
    <updated>2015-11-08T10:53:16+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/11/08/functor-applicative-and-monad</id>
    <content type="html"><![CDATA[<p><code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 是函数式编程语言中三个非常重要的概念，尤其是 <code>Monad</code> ，难倒了不知道多少英雄好汉。事实上，它们的概念是非常简单的，但是却很少有文章能够将它们描述清楚，往往还适得其反，越描越黑。与其它文章不同的是，本文将从结论出发，层层深入，一步步为你揭开它们的神秘面纱。</p>

<p><strong>说明</strong>：本文中的主要代码为 <a href="https://www.haskell.org">Haskell</a> 语言，它是一门纯函数式的编程语言。其中，具体的语法细节，我们不需要太过关心，因为这并不影响你对本文的理解。</p>

<h2>结论</h2>

<p>关于 <code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 的概念，其实各用一句话就可以概括：</p>

<ol>
<li>一个 <code>Functor</code> 就是一种实现了 <code>Functor typeclass</code> 的数据类型；</li>
<li>一个 <code>Applicative</code> 就是一种实现了 <code>Applicative typeclass</code> 的数据类型；</li>
<li>一个 <code>Monad</code> 就是一种实现了 <code>Monad typeclass</code> 的数据类型。</li>
</ol>


<p>当然，你可能会问那什么是 <a href="http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101">typeclass</a> 呢？我想当你在看到<strong>实现</strong>二字的时候，就应该已经猜到了：</p>

<blockquote><p>A typeclass is a sort of interface that defines some behavior. If a type is a part of a typeclass, that means that it supports and implements the behavior the typeclass describes. A lot of people coming from OOP get confused by typeclasses because they think they are like classes in object oriented languages. Well, they&rsquo;re not. You can think of them kind of as Java interfaces, only better.</p></blockquote>

<p>是的，<code>typeclass</code> 就类似于 <code>Java</code> 中的接口，或者 <code>Objective-C</code> 中的协议。在 <code>typeclass</code> 中定义了一些函数，实现一个 <code>typeclass</code> 就是要实现这些函数，而所有实现了这个 <code>typeclass</code> 的数据类型都会拥有这些共同的行为。</p>

<p>那 <code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 三者之间有什么联系吗，为什么它们老是结队出现呢？其实，<code>Applicative</code> 是增强型的 <code>Functor</code> ，一种数据类型要成为 <code>Applicative</code> 的前提条件是它必须是 <code>Functor</code> ；同样的，<code>Monad</code> 是增强型的 <code>Applicative</code> ，一种数据类型要成为 <code>Monad</code> 的前提条件是它必须是 <code>Applicative</code> 。<strong>注</strong>：这个联系，在我们看到 <code>Applicative typeclass</code> 和 <code>Monad typeclass</code> 的定义时，自然就会明了。</p>

<h2>Maybe</h2>

<p>在正式开始介绍 <code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 的定义前，我想先介绍一种非常有意思的数据类型，<a href="https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.1.0/Data-Maybe.html">Maybe</a> 类型（可类比 <code>Swift</code> 中的 <code>Optional</code>）：</p>

<blockquote><p>The Maybe type encapsulates an optional value. A value of type Maybe a either contains a value of type a (represented as Just a), or it is empty (represented as Nothing). Using Maybe is a good way to deal with errors or exceptional cases without resorting to drastic measures such as error.</p></blockquote>

<p><code>Maybe</code> 类型封装了一个可选值。一个 <code>Maybe a</code> 类型的值要么包含一个 <code>a</code> 类型的值（用 <code>Just a</code> 表示）；要么为空（用 <code>Nothing</code> 表示）。我们可以把 <code>Maybe</code> 看作一个盒子，这个盒子里面可能装着一个 <code>a</code> 类型的值，即 <code>Just a</code> ；也可能是一个空盒子，即 <code>Nothing</code> 。或者，你也可以把它理解成泛型，比如 <code>Objective-C</code> 中的 <code>NSArray&lt;ObjectType&gt;</code> 。不过，最正确的理解应该是把 <code>Maybe</code> 看作一个上下文，这个上下文表示某次计算可能成功也可能失败，成功时用 <code>Just a</code> 表示，<code>a</code> 为计算结果；失败时用 <code>Nothing</code> 表示，这就是 <code>Maybe</code> 类型存在的意义：</p>

<p><img src="http://leichunfeng.github.io/images/maybe.png" title="maybe" alt="maybe"></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">data</span> <span class="n">Maybe</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Nothing</span> <span class="o">|</span> <span class="n">Just</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面，我们来直观地感受一下 <code>Maybe</code> 类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">Nothing</span>
</span><span class='line'><span class="n">Nothing</span>
</span><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">Just</span> <span class="mi">2</span>
</span><span class='line'><span class="n">Just</span> <span class="mi">2</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以用盒子模型来理解一下，<code>Nothing</code> 就是一个空盒子；而 <code>Just 2</code> 则是一个装着 <code>2</code> 这个值的盒子：</p>

<p><img src="http://leichunfeng.github.io/images/just2.png" title="just2" alt="just2"></p>

<p><strong>提前剧透</strong>：<code>Maybe</code> 类型实现了 <code>Functor typeclass</code>、<code>Applicative typeclass</code> 和 <code>Monad typeclass</code> ，所以它同时是 <code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> ，具体实现细节将在下面的章节进行介绍。</p>

<h2>Functor</h2>

<p>在正式开始介绍 <code>Functor</code> 前，我们先思考一个这样的问题，假如我们有一个值 <code>2</code> ：</p>

<p><img src="http://leichunfeng.github.io/images/normal2.png" title="normal2" alt="normal2"></p>

<p>我们如何将函数 <code>(+3)</code> 应用到这个值上呢？我想上过小学的朋友应该都知道，这就是一个简单的加法运算：</p>

<p><img src="http://leichunfeng.github.io/images/value_apply.png" title="value_apply" alt="value_apply"></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="mi">2</span>
</span><span class='line'><span class="mi">5</span>
</span></code></pre></td></tr></table></div></figure>


<p>分分钟搞定。那么问题来了，如果这个值 <code>2</code> 是在一个上下文中呢？比如 <code>Maybe</code> ，此时，这个值 <code>2</code> 就变成了 <code>Just 2</code> ：</p>

<p><img src="http://leichunfeng.github.io/images/just2.png" title="just2" alt="just2"></p>

<p>这个时候，我们就不能直接将函数 <code>(+3)</code> 应用到 <code>Just 2</code> 了。那么，我们如何将一个函数应用到一个在上下文中的值呢？</p>

<p><img src="http://leichunfeng.github.io/images/fmap.png" title="fmap" alt="fmap"></p>

<p>是的，我想你应该已经猜到了，<code>Functor</code> 就是干这事的，欲知后事如何，请看下节分解。</p>

<h3>Functor typeclass</h3>

<p>首先，我们来看一下 <code>Functor typeclass</code> 的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Functor</span> <span class="n">f</span> <span class="n">where</span>
</span><span class='line'>    <span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 <code>Functor typeclass</code> 中定义了一个函数 <code>fmap</code> ，它将一个函数应用到一个在上下文中的值，并返回另一个在相同上下文中的值，这里的 <code>f</code> 是一个类型占位符，表示任意类型的 <code>Functor</code> 。</p>

<p><strong>注</strong>：<code>fmap</code> 函数可类比 <code>Swift</code> 中的 <code>map</code> 方法。</p>

<h3>Maybe Functor</h3>

<p>我们知道 <code>Maybe</code> 类型就是一个 <code>Functor</code> ，它实现了 <code>Functor typeclass</code> 。我们将类型占位符 <code>f</code> 用具体类型 <code>Maybe</code> 代入可得：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Functor</span> <span class="n">Maybe</span> <span class="n">where</span>
</span><span class='line'>    <span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，对于 <code>Maybe</code> 类型来说，它要实现的函数 <code>fmap</code> 的功能就是将一个函数应用到一个在 <code>Maybe</code> 上下文中的值，并返回另一个在 <code>Maybe</code> 上下文中的值。接下来，我们一起来看一下 <code>Maybe</code> 类型实现 <code>Functor typeclass</code> 的具体细节：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">instance</span> <span class="n">Functor</span> <span class="n">Maybe</span> <span class="n">where</span>
</span><span class='line'>    <span class="n">fmap</span> <span class="n">func</span> <span class="p">(</span><span class="n">Just</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">Just</span> <span class="p">(</span><span class="n">func</span> <span class="n">x</span><span class="p">)</span>
</span><span class='line'>    <span class="n">fmap</span> <span class="n">func</span> <span class="n">Nothing</span>  <span class="o">=</span> <span class="n">Nothing</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里针对 <code>Maybe</code> 上下文的两种情况分别进行了处理：如果盒子中有值，即 <code>Just x</code> ，那么就将 <code>x</code> 从盒子中取出，然后将函数 <code>func</code> 应用到 <code>x</code> ，最后将结果放入一个相同类型的新盒子中；如果盒子为空，那么直接返回一个新的空盒子。</p>

<p>看到这里，我想你应该已经知道如何将一个函数应用到一个在上下文中的值了。比如前面提到的将函数 <code>(+3)</code> 应用到 <code>Just 2</code> ：</p>

<p><img src="http://leichunfeng.github.io/images/fmap_just.png" title="fmap_just" alt="fmap_just"></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="n">Just</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="n">Just</span> <span class="mi">5</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外，值得一提的是，当我们将函数 <code>(+3)</code> 应用到一个空盒子，即 <code>Nothing</code> 时，我们将会得到一个新的空盒子：</p>

<p><img src="http://leichunfeng.github.io/images/fmap_nothing.png" title="fmap_nothing" alt="fmap_nothing"></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="n">Nothing</span>
</span><span class='line'><span class="n">Nothing</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Applicative</h2>

<p>现在，我们已经知道如何将函数 <code>(+3)</code> 应用到 <code>Just 2</code> 了。那么问题又来了，如果函数 <code>(+3)</code> 也在上下文中呢，比如 <code>Maybe</code> ，此时，函数 <code>(+3)</code> 就变成了 <code>Just (+3)</code> ：</p>

<p><img src="http://leichunfeng.github.io/images/justadd3.png" title="justadd3" alt="justadd3"></p>

<p>那么，我们如何将一个在上下文中的函数应用到一个在上下文中的值呢？</p>

<p><img src="http://leichunfeng.github.io/images/apply_justadd3_just2.png" title="apply_justadd3_just2" alt="apply_justadd3_just2"></p>

<p>这就是 <code>Applicative</code> 要干的事，详情请看下节内容。</p>

<h3>Applicative typeclass</h3>

<p>同样的，我们先来看一下 <code>Applicative typeclass</code> 的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">Applicative</span> <span class="n">f</span> <span class="n">where</span>
</span><span class='line'>    <span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</span><span class='line'>    <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们注意到，与 <code>Functor typeclass</code> 的定义不同的是，在 <code>Applicative typeclass</code> 的定义中多了一个类约束 <code>Functor f</code> ，表示的意思是数据类型 <code>f</code> 要实现 <code>Applicative typeclass</code> 的前提条件是它必须要实现 <code>Functor typeclass</code> ，也就是说它必须是一个 <code>Functor</code> 。</p>

<p>在 <code>Applicative typeclass</code> 中定义了两个函数：</p>

<ul>
<li><code>pure</code> ：将一个值放入上下文中；</li>
<li><code>(&lt;*&gt;)</code> ：将一个在上下文中的函数应用到一个在上下文中的值，并返回另一个在上下文中的值。</li>
</ul>


<p><strong>注</strong>：<code>&lt;*&gt;</code> 函数的发音我也不知道，如果有同学知道的话还请告之，谢谢。</p>

<h3>Maybe Applicative</h3>

<p>同样的，我们将类型占位符 <code>f</code> 用具体类型 <code>Maybe</code> 代入，可得：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Functor</span> <span class="n">Maybe</span> <span class="o">=&gt;</span> <span class="n">Applicative</span> <span class="n">Maybe</span> <span class="n">where</span>
</span><span class='line'>    <span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">a</span>
</span><span class='line'>    <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">Maybe</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，对于 <code>Maybe</code> 类型来说，它要实现的 <code>pure</code> 函数的功能就是将一个值放入 <code>Maybe</code> 上下文中。而 <code>(&lt;*&gt;)</code> 函数的功能则是将一个在 <code>Maybe</code> 上下文中的函数应用到一个在 <code>Maybe</code> 上下文中的值，并返回另一个在 <code>Maybe</code> 上下文中的值。接下来，我们一起来看一下 <code>Maybe</code> 类型实现 <code>Applicative typeclass</code> 的具体细节：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">instance</span> <span class="n">Applicative</span> <span class="n">Maybe</span> <span class="n">where</span>
</span><span class='line'>    <span class="n">pure</span> <span class="o">=</span> <span class="n">Just</span>
</span><span class='line'>    <span class="n">Nothing</span> <span class="o">&lt;*&gt;</span> <span class="n">_</span> <span class="o">=</span> <span class="n">Nothing</span>
</span><span class='line'>    <span class="p">(</span><span class="n">Just</span> <span class="n">func</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">something</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">func</span> <span class="n">something</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>pure</code> 函数的实现非常简单，直接等于 <code>Just</code> 即可。而对于 <code>(&lt;*&gt;)</code> 函数的实现，我们同样需要针对 <code>Maybe</code> 上下文的两种情况分别进行处理：当装函数的盒子为空时，直接返回一个新的空盒子；当装函数的盒子不为空时，即 <code>Just func</code> ，则取出 <code>func</code> ，使用 <code>fmap</code> 函数直接将 <code>func</code> 应用到那个在上下文中的值，这个正是我们前面说的 <code>Functor</code> 的功能。</p>

<p>好了，我们接下来看一下将 <code>Just (+3)</code> 应用到 <code>Just 2</code> 的具体过程：</p>

<p><img src="http://leichunfeng.github.io/images/applicative_just.png" title="applicative_just" alt="applicative_just"></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">Just</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">Just</span> <span class="mi">2</span>
</span><span class='line'><span class="n">Just</span> <span class="mi">5</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样的，当我们将一个空盒子，即 <code>Nothing</code> 应用到 <code>Just 2</code> 的时候，我们将得到一个新的空盒子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">Nothing</span> <span class="o">&lt;*&gt;</span> <span class="n">Just</span> <span class="mi">2</span>
</span><span class='line'><span class="n">Nothing</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Monad</h2>

<p>截至目前，我们已经知道了 <code>Functor</code> 的作用就是应用一个函数到一个上下文中的值：</p>

<p><img src="http://leichunfeng.github.io/images/fmap.png" title="fmap" alt="fmap"></p>

<p>而 <code>Applicative</code> 的作用则是应用一个上下文中的函数到一个上下文中的值：</p>

<p><img src="http://leichunfeng.github.io/images/apply_justadd3_just2.png" title="apply_justadd3_just2" alt="apply_justadd3_just2"></p>

<p>那么 <code>Monad</code> 又会是什么呢？其实，<code>Monad</code> 的作用跟 <code>Functor</code> 类似，也是应用一个函数到一个上下文中的值。不同之处在于，<code>Functor</code> 应用的是一个接收一个普通值并且返回一个普通值的函数，而 <code>Monad</code> 应用的是一个接收一个普通值但是返回一个在上下文中的值的函数：</p>

<p><img src="http://leichunfeng.github.io/images/bind.png" title="bind" alt="bind"></p>

<h3>Monad typeclass</h3>

<p>同样的，我们先来看一下 <code>Monad typeclass</code> 的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Applicative</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">Monad</span> <span class="n">m</span> <span class="n">where</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="err">\</span><span class="n">_</span> <span class="o">-&gt;</span> <span class="n">y</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">fail</span> <span class="o">::</span> <span class="n">String</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">fail</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">error</span> <span class="n">msg</span>
</span></code></pre></td></tr></table></div></figure>


<p>哇，这什么鬼，完全看不懂啊，太复杂了。兄台莫急，且听我细说。在 <code>Monad typeclass</code> 中定义了四个函数，分别是 <code>return</code>、<code>(&gt;&gt;=)</code>、<code>(&gt;&gt;)</code> 和 <code>fail</code> ，且后两个函数 <code>(&gt;&gt;)</code> 和 <code>fail</code> 给出了默认实现，而在绝大多数情况下，我们都不需要去重写它们。因此，去掉这两个函数后，<code>Monad typeclass</code> 的定义可简化为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Applicative</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">Monad</span> <span class="n">m</span> <span class="n">where</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</span><span class='line'>    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>怎么样？现在看上去就好多了吧。跟 <code>Applicative typeclass</code> 的定义一样，在 <code>Monad typeclass</code> 的定义中也有一个类约束 <code>Applicative m</code> ，表示的意思是一种数据类型 <code>m</code> 要成为 <code>Monad</code> 的前提条件是它必须是 <code>Applicative</code> 。另外，其实 <code>return</code> 函数的功能与 <code>Applicative</code> 中的 <code>pure</code> 函数的功能是一样的，只不过换了一个名字而已，它们的作用都是将一个值放入上下文中。而 <code>(&gt;&gt;=)</code> 函数的功能则是应用一个（接收一个普通值但是返回一个在上下文中的值的）函数到一个上下文中的值，并返回另一个在相同上下文中的值。</p>

<p><strong>注</strong>：<code>&gt;&gt;=</code> 函数的发音为 <code>bind</code> ，学习 <code>ReactiveCocoa</code> 的同学要注意啦。另外，<code>&gt;&gt;=</code> 函数可类比 <code>Swift</code> 中的 <code>flatMap</code> 方法。</p>

<h3>Maybe Monad</h3>

<p>同样的，我们将类型占位符 <code>m</code> 用具体类型 <code>Maybe</code> 代入，可得：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Applicative</span> <span class="n">Maybe</span> <span class="o">=&gt;</span> <span class="n">Monad</span> <span class="n">Maybe</span> <span class="n">where</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">a</span>
</span><span class='line'>    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="n">Maybe</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>相信你用盒子模型已经能够轻松地理解上面两个函数了，因此不再赘述。接下来，我们一起来看一下 <code>Maybe</code> 类型实现 <code>Monad typeclass</code> 的具体细节：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">instance</span> <span class="n">Monad</span> <span class="n">Maybe</span> <span class="n">where</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Just</span> <span class="n">x</span>
</span><span class='line'>    <span class="n">Nothing</span> <span class="o">&gt;&gt;=</span> <span class="n">func</span> <span class="o">=</span> <span class="n">Nothing</span>
</span><span class='line'>    <span class="n">Just</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">func</span>  <span class="o">=</span> <span class="n">func</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>正如前面所说，<code>return</code> 函数的实现跟 <code>pure</code> 函数一样，直接等于 <code>Just</code> 函数即可，功能就是将一个值 <code>x</code> 放入 <code>Maybe</code> 盒子中，变成 <code>Just x</code> 。同样的，对于 <code>(&gt;&gt;=)</code> 函数的实现，我们需要针对 <code>Maybe</code> 上下文的两种情况分别进行处理，当盒子为空时，直接返回一个新的空盒子；当盒子不为空时，即 <code>Just x</code> ，则取出 <code>x</code> ，直接将 <code>func</code> 函数应用到 <code>x</code> ，而我们知道 <code>func x</code> 的结果就是一个在上下文中的值。</p>

<p>下面，我们一起来看一个具体的例子。我们先定义一个 <code>half</code> 函数，这个函数接收一个数字 <code>x</code> 作为参数，如果 <code>x</code> 是偶数，则将 <code>x</code> 除以 <code>2</code> ，并将结果放入 <code>Maybe</code> 盒子中；如果 <code>x</code> 不是偶数，则返回一个空盒子：</p>

<p><img src="http://leichunfeng.github.io/images/half.png" title="half" alt="half"></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">half</span> <span class="n">x</span> <span class="o">=</span> <span class="k">if</span> <span class="n">even</span> <span class="n">x</span>
</span><span class='line'>    <span class="n">then</span> <span class="n">Just</span> <span class="p">(</span><span class="n">x</span> <span class="err">`</span><span class="n">div</span><span class="err">`</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span> <span class="n">Nothing</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来，我们使用 <code>(&gt;&gt;=)</code> 函数将 <code>half</code> 函数应用到 <code>Just 20</code> ，假设得到结果 <code>y</code> ；然后继续使用 <code>(&gt;&gt;=)</code> 函数将 <code>half</code> 函数应用到上一步的结果 <code>y</code> ，以此类推，看看会得到什么样的结果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">Just</span> <span class="mi">20</span> <span class="o">&gt;&gt;=</span> <span class="n">half</span>
</span><span class='line'><span class="n">Just</span> <span class="mi">10</span>
</span><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">Just</span> <span class="mi">10</span> <span class="o">&gt;&gt;=</span> <span class="n">half</span>
</span><span class='line'><span class="n">Just</span> <span class="mi">5</span>
</span><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">Just</span> <span class="mi">10</span> <span class="o">&gt;&gt;=</span> <span class="n">half</span>
</span><span class='line'><span class="n">Just</span> <span class="mi">5</span>
</span><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">Just</span> <span class="mi">5</span> <span class="o">&gt;&gt;=</span> <span class="n">half</span>
</span><span class='line'><span class="n">Nothing</span>
</span></code></pre></td></tr></table></div></figure>


<p>看到上面的运算过程，不知道你有没有看出点什么端倪呢？上一步的输出作为下一步的输入，并且只要你愿意的话，这个过程可以无限地进行下去。我想你可能已经想到了，是的，就是链式操作。所有的操作链接起来就像是一条生产线，每一步的操作都是对输入进行加工，然后产生输出，整个操作过程可以看作是对最初的原材料 <code>Just 20</code> 进行加工并最终生产出成品 <code>Nothing</code> 的过程：</p>

<p><img src="http://leichunfeng.github.io/images/monad_chain.png" title="monad_chain" alt="monad_chain"></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">Just</span> <span class="mi">20</span> <span class="o">&gt;&gt;=</span> <span class="n">half</span> <span class="o">&gt;&gt;=</span> <span class="n">half</span> <span class="o">&gt;&gt;=</span> <span class="n">half</span>
</span><span class='line'><span class="n">Nothing</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注</strong>：链式操作只是 <code>Monad</code> 为我们带来的主要好处之一；另一个本文并未涉及到的主要好处是，<code>Monad</code> 可以为我们自动处理上下文，而我们只需要关心真正的值就可以了。</p>

<h3>ReactiveCocoa</h3>

<p>现在，我们已经知道 <code>Monad</code> 是什么了，它就是一种实现了 <code>Monad typeclass</code> 的数据类型。那么它有什么具体的应用呢？你总不能让我们都来做理论研究吧。既然如此，那我们就只好祭出 <code>Objective-C</code> 中的神器，<code>ReactiveCocoa</code> ，它就是根据 <code>Monad</code> 的概念搭建起来的。下面是 <code>RACStream</code> 的继承结构图：</p>

<p><img src="http://leichunfeng.github.io/images/RACStream.png" title="RACStream" alt="RACStream"></p>

<p><code>RACStream</code> 是 <code>ReactiveCocoa</code> 中最核心的类，它就是一个 <code>Monad</code> ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">/// An abstract class representing any stream of values.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// This class represents a monad, upon which many stream-based operations can</span>
</span><span class='line'><span class="c1">/// be built.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// When subclassing RACStream, only the methods in the main @interface body need</span>
</span><span class='line'><span class="c1">/// to be overridden.</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">RACStream</span> : <span class="bp">NSObject</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// Lifts `value` into the stream monad.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// Returns a stream containing only the given value.</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">return:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">value</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// Lazily binds a block to the values in the receiver.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// This should only be used if you need to terminate the bind early, or close</span>
</span><span class='line'><span class="c1">/// over some state. -flattenMap: is more appropriate for all other cases.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// block - A block returning a RACStreamBindBlock. This block will be invoked</span>
</span><span class='line'><span class="c1">///         each time the bound stream is re-evaluated. This block must not be</span>
</span><span class='line'><span class="c1">///         nil or return nil.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// Returns a new stream which represents the combined result of all lazy</span>
</span><span class='line'><span class="c1">/// applications of `block`.</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">bind:</span><span class="p">(</span><span class="n">RACStreamBindBlock</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以看到，在 <code>RACStream</code> 中定义了两个看上去非常眼熟的方法：</p>

<ol>
<li><code>+ (instancetype)return:(id)value;</code> ；</li>
<li><code>- (instancetype)bind:(RACStreamBindBlock (^)(void))block;</code> 。</li>
</ol>


<p>其中，<code>return:</code> 方法的功能就是将一个值 <code>value</code> 放入 <code>RACStream</code> 上下文中；而 <code>bind:</code> 方法的功能则是将一个 <code>RACStreamBindBlock</code> 类型的 <code>block</code> 应用到一个在 <code>RACStream</code> 上下文中的值（<code>receiver</code>），并返回另一个在 <code>RACStream</code> 上下文中的值。并且，<code>RACStreamBindBlock</code> 类型的 <code>block</code> 就是一个接收一个普通值但是返回一个在 <code>RACStream</code> 上下文中的值的“函数”：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">/// A block which accepts a value from a RACStream and returns a new instance</span>
</span><span class='line'><span class="c1">/// of the same stream class.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// Setting `stop` to `YES` will cause the bind to terminate after the returned</span>
</span><span class='line'><span class="c1">/// value. Returning `nil` will result in immediate termination.</span>
</span><span class='line'><span class="k">typedef</span> <span class="n">RACStream</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">RACStreamBindBlock</span><span class="p">)(</span><span class="kt">id</span> <span class="n">value</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来，为了加深理解，我们一起来对比一下 <code>Monad typeclass</code> 的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Applicative</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">Monad</span> <span class="n">m</span> <span class="n">where</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</span><span class='line'>    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样的，我们将类型占位符 <code>m</code> 用 <code>RACStream</code> 代入，可得：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Applicative</span> <span class="n">RACStream</span> <span class="o">=&gt;</span> <span class="n">Monad</span> <span class="n">RACStream</span> <span class="n">where</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">RACStream</span> <span class="n">a</span>
</span><span class='line'>    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="n">RACStream</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">RACStream</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RACStream</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中，<code>return :: a -&gt; RACStream a</code> 就对应 <code>+ (instancetype)return:(id)value;</code> ，而 <code>(&gt;&gt;=) :: RACStream a -&gt; (a -&gt; RACStream b) -&gt; RACStream b</code> 则对应 <code>- (instancetype)bind:(RACStreamBindBlock (^)(void))block;</code> 。<strong>注</strong>：我们前面已经提到过了，<code>&gt;&gt;=</code> 函数的发音就是 <code>bind</code> 。因此，<code>ReactiveCocoa</code> 便有了下面的玩法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">RACSignal</span> <span class="o">*</span><span class="n">signal2</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">signal1</span>
</span><span class='line'>    <span class="nl">bind</span><span class="p">:</span><span class="n">block1</span><span class="p">]</span>
</span><span class='line'>    <span class="nl">bind</span><span class="p">:</span><span class="n">block2</span><span class="p">]</span>
</span><span class='line'>    <span class="nl">bind</span><span class="p">:</span><span class="n">block3</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Monad</code> 就像是 <code>ReactiveCocoa</code> 中的太极，太极生两仪，两仪生四象，四象生八卦。至此，我们已经知道了 <code>ReactiveCocoa</code> 中最核心的原理，而更多关于 <code>ReactiveCocoa</code> 的内容我们将在后续的源码解析中再进行介绍，敬请期待。</p>

<h2>总结</h2>

<p><code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 是什么：</p>

<ol>
<li>一个 <code>Functor</code> 就是一种实现了 <code>Functor typeclass</code> 的数据类型；</li>
<li>一个 <code>Applicative</code> 就是一种实现了 <code>Applicative typeclass</code> 的数据类型；</li>
<li>一个 <code>Monad</code> 就是一种实现了 <code>Monad typeclass</code> 的数据类型。</li>
</ol>


<p><code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 三者之间的联系：</p>

<ol>
<li><code>Applicative</code> 是增强型的 <code>Functor</code> ，一种数据类型要成为 <code>Applicative</code> 的前提条件是它必须是 <code>Functor</code> ；</li>
<li><code>Monad</code> 是增强型的 <code>Applicative</code> ，一种数据类型要成为 <code>Monad</code> 的前提条件是它必须是 <code>Applicative</code> 。</li>
</ol>


<p><code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 三者之间的区别：</p>

<p><img src="http://leichunfeng.github.io/images/recap.png" title="recap" alt="recap"></p>

<ol>
<li><code>Functor</code> ：使用 <code>fmap</code> 应用一个函数到一个上下文中的值；</li>
<li><code>Applicative</code> ：使用 <code>&lt;*&gt;</code> 应用一个上下文中的函数到一个上下文中的值；</li>
<li><code>Monad</code> ：使用 <code>&gt;&gt;=</code> 应用一个接收一个普通值但是返回一个在上下文中的值的函数到一个上下文中的值。</li>
</ol>


<p>此外，我们还介绍了一种非常有意思的数据类型 <code>Maybe</code> ，它实现了 <code>Functor typeclass</code>、<code>Applicative typeclass</code> 和 <code>Monad typeclass</code> ，所以它同时是 <code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 。</p>

<p>以上就是本文的全部内容，希望可以对你有所帮助，Good luck !</p>

<h2>参考链接</h2>

<p><a href="http://learnyouahaskell.com/chapters">http://learnyouahaskell.com/chapters</a>
<br>
<a href="https://downloads.haskell.org/~ghc/latest/docs/html/libraries">https://downloads.haskell.org/~ghc/latest/docs/html/libraries</a>
<br>
<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">http://adit.io/posts/2013-04-17-functors,<em>applicatives,</em>and_monads_in_pictures.html</a></p>

<p><img src="http://leichunfeng.github.io/images/wechat_pay.jpg" width="260" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 并发编程之 Operation Queues]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/07/29/ios-concurrency-programming-operation-queues/"/>
    <updated>2015-07-29T22:06:33+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/07/29/ios-concurrency-programming-operation-queues</id>
    <content type="html"><![CDATA[<p>现如今移动设备也早已经进入了多核心 <code>CPU</code> 时代，并且随着时间的推移，<code>CPU</code> 的核心数只会增加不会减少。而作为软件开发者，我们需要做的就是尽可能地提高应用的并发性，来充分利用这些多核心 <code>CPU</code> 的性能。在 iOS 开发中，我们主要可以通过 Operation Queues、Dispatch Queues 和 Dispatch Sources 来提高应用的并发性。本文将主要介绍 Operation Queues 的相关知识，另外两个属于 Grand Central Dispatch（以下正文简称 <code>GCD</code> ）的范畴，将会在后续的文章中进行介绍。</p>

<p>由于本文涉及的内容较多，所以建议读者先提前了解一下本文的目录结构，以便对本文有一个宏观的认识：</p>

<ul>
<li>基本概念

<ul>
<li>术语</li>
<li>串行 vs. 并发</li>
<li>同步 vs. 异步</li>
<li>队列 vs. 线程</li>
</ul>
</li>
<li>iOS 的并发编程模型</li>
<li>Operation Queues vs. Grand Central Dispatch (GCD)</li>
<li>关于 Operation 对象

<ul>
<li>并发 vs. 非并发 Operation</li>
<li>创建 NSInvocationOperation 对象</li>
<li>创建 NSBlockOperation 对象</li>
</ul>
</li>
<li>自定义 Operation 对象

<ul>
<li>执行主任务</li>
<li>响应取消事件</li>
<li>配置并发执行的 Operation</li>
<li>维护 KVO 通知</li>
</ul>
</li>
<li>定制 Operation 对象的执行行为

<ul>
<li>配置依赖关系</li>
<li>修改 Operation 在队列中的优先级</li>
<li>修改 Operation 执行任务线程的优先级</li>
<li>设置 Completion Block</li>
</ul>
</li>
<li>执行 Operation 对象

<ul>
<li>添加 Operation 到 Operation Queue 中</li>
<li>手动执行 Operation</li>
<li>取消 Operation</li>
<li>等待 Operation 执行完成</li>
<li>暂停和恢复 Operation Queue</li>
</ul>
</li>
<li>总结</li>
</ul>


<h2>基本概念</h2>

<p>在正式开始介绍 Operation Queues 的相关知识前，我想先介绍几个在 iOS 并发编程中非常容易混淆的基本概念，以帮助读者更好地理解本文。<strong>注</strong>，本文中的 Operation Queues 指的是 NSOperation 和 NSOperationQueue 的统称。</p>

<h3>术语</h3>

<p>首先，我们先来了解一下在 iOS 并发编程中非常重要的三个术语，这是我们理解 iOS 并发编程的基础：</p>

<ul>
<li>进程（process），指的是一个正在运行中的可执行文件。每一个进程都拥有独立的虚拟内存空间和系统资源，包括端口权限等，且至少包含一个主线程和任意数量的辅助线程。另外，当一个进程的主线程退出时，这个进程就结束了；</li>
<li>线程（thread），指的是一个独立的代码执行路径，也就是说线程是代码执行路径的最小分支。在 iOS 中，线程的底层实现是基于 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html">POSIX threads API</a> 的，也就是我们常说的 pthreads ；</li>
<li>任务（task），指的是我们需要执行的工作，是一个抽象的概念，用通俗的话说，就是一段代码。</li>
</ul>


<h3>串行 vs. 并发</h3>

<p>从本质上来说，串行和并发的主要区别在于允许同时执行的任务数量。串行，指的是一次只能执行一个任务，必须等一个任务执行完成后才能执行下一个任务；并发，则指的是允许多个任务同时执行。</p>

<h3>同步 vs. 异步</h3>

<p>同样的，同步和异步操作的主要区别在于是否等待操作执行完成，亦即是否阻塞当前线程。同步操作会等待操作执行完成后再继续执行接下来的代码，而异步操作则恰好相反，它会在调用后立即返回，不会等待操作的执行结果。</p>

<h3>队列 vs. 线程</h3>

<p>有一些对 iOS 并发编程模型不太了解的同学可能会对队列和线程产生混淆，不清楚它们之间的区别与联系，因此，我觉得非常有必要在这里简单地介绍一下。在 iOS 中，有两种不同类型的队列，分别是串行队列和并发队列。正如我们上面所说的，串行队列一次只能执行一个任务，而并发队列则可以允许多个任务同时执行。iOS 系统就是使用这些队列来进行任务调度的，它会根据调度任务的需要和系统当前的负载情况动态地创建和销毁线程，而不需要我们手动地管理。</p>

<h2>iOS 的并发编程模型</h2>

<p>在其他许多语言中，为了提高应用的并发性，我们往往需要自行创建一个或多个额外的线程，并且手动地管理这些线程的生命周期，这本身就已经是一项非常具有挑战性的任务了。此外，对于一个应用来说，最优的线程个数会随着系统当前的负载和低层硬件的情况发生动态变化。因此，一个单独的应用想要实现一套正确的多线程解决方案就变成了一件几乎不可能完成的事情。而更糟糕的是，线程的同步机制大幅度地增加了应用的复杂性，并且还存在着不一定能够提高应用性能的风险。</p>

<p>然而，值得庆幸的是，在 iOS 中，苹果采用了一种比传统的基于线程的系统更加异步的方式来执行并发任务。与直接创建线程的方式不同，我们只需定义好要调度的任务，然后让系统帮我们去执行这些任务就可以了。我们可以完全不需要关心线程的创建与销毁、以及多线程之间的同步等问题，苹果已经在系统层面帮我们处理好了，并且比我们手动地管理这些线程要高效得多。</p>

<p>因此，我们应该要听从苹果的劝告，珍爱生命，远离线程。不过话又说回来，尽管队列是执行并发任务的首先方式，但是毕竟它们也不是什么万能的灵丹妙药。所以，在以下三种场景下，我们还是应该直接使用线程的：</p>

<ul>
<li>用线程以外的其他任何方式都不能实现我们的特定任务；</li>
<li>必须实时执行一个任务。因为虽然队列会尽可能快地执行我们提交的任务，但是并不能保证实时性；</li>
<li>你需要对在后台执行的任务有更多的可预测行为。</li>
</ul>


<h2>Operation Queues vs. Grand Central Dispatch (GCD)</h2>

<p>简单来说，<code>GCD</code> 是苹果基于 <code>C</code> 语言开发的，一个用于多核编程的解决方案，主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。而 Operation Queues 则是一个建立在 <code>GCD</code> 的基础之上的，面向对象的解决方案。它使用起来比 <code>GCD</code> 更加灵活，功能也更加强大。下面简单地介绍了 Operation Queues 和 <code>GCD</code> 各自的使用场景：</p>

<ul>
<li>Operation Queues ：相对 <code>GCD</code> 来说，使用 Operation Queues 会增加一点点额外的开销，但是我们却换来了非常强大的灵活性和功能，我们可以给 operation 之间添加依赖关系、取消一个正在执行的 operation 、暂停和恢复 operation queue 等；</li>
<li><code>GCD</code> ：则是一种更轻量级的，以 <code>FIFO</code> 的顺序执行并发任务的方式，使用 <code>GCD</code> 时我们并不关心任务的调度情况，而让系统帮我们自动处理。但是 <code>GCD</code> 的短板也是非常明显的，比如我们想要给任务之间添加依赖关系、取消或者暂停一个正在执行的任务时就会变得非常棘手。</li>
</ul>


<h2>关于 Operation 对象</h2>

<p>在 iOS 开发中，我们可以使用 NSOperation 类来封装需要执行的任务，而一个 operation 对象（以下正文简称 operation ）指的就是 NSOperation 类的一个具体实例。NSOperation 本身是一个抽象类，不能直接实例化，因此，如果我们想要使用它来执行具体任务的话，就必须创建自己的子类或者使用系统预定义的两个子类，NSInvocationOperation 和 NSBlockOperation 。</p>

<p><strong>NSInvocationOperation</strong> ：我们可以通过一个 <code>object</code> 和 <code>selector</code> 非常方便地创建一个 NSInvocationOperation ，这是一种非常动态和灵活的方式。假设我们已经有了一个现成的方法，这个方法中的代码正好就是我们需要执行的任务，那么我们就可以在不修改任何现有代码的情况下，通过方法所在的对象和这个现有方法直接创建一个 NSInvocationOperation 。</p>

<p><strong>NSBlockOperation</strong> ：我们可以使用 NSBlockOperation 来并发执行一个或多个 block ，只有当一个 NSBlockOperation 所关联的所有 block 都执行完毕时，这个 NSBlockOperation 才算执行完成，有点类似于 <code>dispatch_group</code> 的概念。</p>

<p>另外，所有的 operation 都支持以下特性：</p>

<ul>
<li>支持在 operation 之间建立依赖关系，只有当一个 operation 所依赖的所有 operation 都执行完成时，这个 operation 才能开始执行；</li>
<li>支持一个可选的 completion block ，这个 block 将会在 operation 的主任务执行完成时被调用；</li>
<li>支持通过 <code>KVO</code> 来观察 operation 执行状态的变化；</li>
<li>支持设置执行的优先级，从而影响 operation 之间的相对执行顺序；</li>
<li>支持取消操作，可以允许我们停止正在执行的 operation 。</li>
</ul>


<h3>并发 vs. 非并发 Operation</h3>

<p>通常来说，我们都是通过将 operation 添加到一个 operation queue 的方式来执行 operation 的，然而这并不是必须的。我们也可以直接通过调用 <code>start</code> 方法来执行一个 operation ，但是这种方式并不能保证 operation 是异步执行的。NSOperation 类的 <code>isConcurrent</code> 方法的返回值标识了一个 operation 相对于调用它的 <code>start</code> 方法的线程来说是否是异步执行的。在默认情况下，isConcurrent 方法的返回值是 <code>NO</code> ，也就是说会阻塞调用它的 <code>start</code> 方法的线程。</p>

<p>如果我们想要自定义一个并发执行的 operation ，那么我们就必须要编写一些额外的代码来让这个 operation 异步执行。比如，为这个 operation 创建新的线程、调用系统的异步方法或者其他任何方式来确保 <code>start</code> 方法在开始执行任务后立即返回。</p>

<p>在绝大多数情况下，我们都不需要去实现一个并发的 operation 。如果我们一直是通过将 operation 添加到 operation queue 的方式来执行 operation 的话，我们就完全没有必要去实现一个并发的 operation 。因为，当我们将一个非并发的 operation 添加到 operation queue 后，operation queue 会自动为这个 operation 创建一个线程。因此，只有当我们需要手动地执行一个 operation ，又想让它异步执行时，我们才有必要去实现一个并发的 operation 。</p>

<h3>创建 NSInvocationOperation 对象</h3>

<p>正如上面提到的，NSInvocationOperation 是 NSOperation 类的一个子类，当一个 NSInvocationOperation 开始执行时，它会调用我们指定的 <code>object</code> 的 <code>selector</code> 方法。通过使用 NSInvocationOperation 类，我们可以避免为每一个任务都创建一个自定义的子类，特别是当我们在修改一个已经存在的应用，并且这个应用中已经有了我们需要执行的任务所对应的 <code>object</code> 和 <code>selector</code> 时非常有用。</p>

<p>下面的示例代码展示了如何通过 <code>object</code> 和 <code>selector</code> 创建一个 NSInvocationOperation 对象。<strong>说明</strong>，本文中的所有示例代码都可以在这里 <a href="https://github.com/leichunfeng/OperationQueues">OperationQueues</a> 找到，每一个类都有与之对应的测试类，充当 <code>client</code> 的角色，建议你在看完一个小节的代码时，运行一下相应的测试用例，观察打印的结果，以加深理解。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">OQCreateInvocationOperation</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSInvocationOperation</span> <span class="o">*</span><span class="p">)</span><span class="nf">invocationOperationWithData:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">data</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[[</span><span class="bp">NSInvocationOperation</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">myTaskMethod1</span><span class="p">:)</span> <span class="nl">object</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">myTaskMethod1:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">data</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing %@ with data: %@, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">),</span> <span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外，我们在前面也提到了，NSInvocationOperation 类的使用可以非常的动态和灵活，其中比较显著的一点就是我们可以根据上下文动态地调用 <code>object</code> 的不同 <code>selector</code> 。比如说，我们可以根据用户的输入动态地执行不同的 <code>selector</code> ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSInvocationOperation</span> <span class="o">*</span><span class="p">)</span><span class="nf">invocationOperationWithData:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">data</span> <span class="nf">userInput:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">userInput</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">NSInvocationOperation</span> <span class="o">*</span><span class="n">invocationOperation</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">invocationOperationWithData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">userInput</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">invocationOperation</span><span class="p">.</span><span class="n">invocation</span><span class="p">.</span><span class="n">selector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">myTaskMethod2</span><span class="p">:);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">invocationOperation</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">myTaskMethod2:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">data</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing %@ with data: %@, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">),</span> <span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>创建 NSBlockOperation 对象</h3>

<p>NSBlockOperation 是 NSOperation 类的另外一个系统预定义的子类，我们可以用它来封装一个或多个 <code>block</code> 。我们知道 <code>GCD</code> 主要就是用来进行 <code>block</code> 调度的，那为什么我们还需要 NSBlockOperation 类呢？一般来说，有以下两个场景我们会优先使用 NSBlockOperation 类：</p>

<ul>
<li>当我们在应用中已经使用了 Operation Queues 且不想创建 Dispatch Queues 时，NSBlockOperation 类可以为我们的应用提供一个面向对象的封装；</li>
<li>我们需要用到 Dispatch Queues 不具备的功能时，比如需要设置 operation 之间的依赖关系、使用 <code>KVO</code> 观察 operation 的状态变化等。</li>
</ul>


<p>下面的示例代码展示了创建一个 NSBlockOperation 对象的基本方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">OQCreateBlockOperation</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="p">)</span><span class="nf">blockOperation</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">blockOperation</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing block1, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing block1&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">blockOperation</span> <span class="nl">addExecutionBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing block2, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing block2&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">blockOperation</span> <span class="nl">addExecutionBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing block3, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing block3&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">blockOperation</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h2>自定义 Operation 对象</h2>

<p>当系统预定义的两个子类 NSInvocationOperation 和 NSBlockOperation 不能很好的满足我们的需求时，我们可以自定义自己的 NSOperation 子类，添加我们想要的功能。目前，我们可以自定义非并发和并发两种不同类型的 NSOperation 子类，而自定义一个前者要比后者简单得多。</p>

<p>对于一个非并发的 operation ，我们需要做的就只是执行 <code>main</code> 方法中的任务以及能够正常响应取消事件就可以了，其它的复杂工作比如依赖配置、KVO 通知等 NSOperation 类都已经帮我们处理好了。而对于一个并发的 operation ，我们还需要重写 NSOperation 类中的一些现有方法。接下来，我们将会介绍如何自定义这两种不同类型的 NSOperation 子类。</p>

<h3>执行主任务</h3>

<p>从最低限度上来说，每一个 operation 都应该至少实现以下两个方法：</p>

<ul>
<li>一个自定义的初始化方法；</li>
<li><code>main</code> 方法。</li>
</ul>


<p>我们需要用一个自定义的初始化方法来将创建的 operation 置于一个已知的状态，并且重写 <code>main</code> 方法来执行我们的任务。当然，我们也可以实现一些其他的额外方法，比如实现 <code>NSCoding</code> 协议来允许我们归档和解档 operation 等。下面的示例代码展示了如何自定义一个简单的 operation ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">OQNonConcurrentOperation</span> <span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="kt">id</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">OQNonConcurrentOperation</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithData:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">data</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">///  不支持取消操作</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">main</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@try</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing %@ with data: %@, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">),</span> <span class="nb">self</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">@catch</span><span class="p">(</span><span class="bp">NSException</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Exception: %@&quot;</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>响应取消事件</h3>

<p>当一个 operation 开始执行后，它会一直执行它的任务直到完成或被取消为止。我们可以在任意时间点取消一个 operation ，甚至是在它还未开始执行之前。为了让我们自定义的 operation 能够支持取消事件，我们需要在代码中定期地检查 <code>isCancelled</code> 方法的返回值，一旦检查到这个方法返回 <code>YES</code> ，我们就需要立即停止执行接下来的任务。根据苹果官方的说法，<code>isCancelled</code> 方法本身是足够轻量的，所以就算是频繁地调用它也不会给系统带来太大的负担。</p>

<blockquote><p>The isCancelled method itself is very lightweight and can be called frequently without any significant performance penalty.</p></blockquote>

<p>通常来说，当我们自定义一个 operation 类时，我们需要考虑在以下几个关键点检查 <code>isCancelled</code> 方法的返回值：</p>

<ul>
<li>在真正开始执行任务之前；</li>
<li>至少在每次循环中检查一次，而如果一次循环的时间本身就比较长的话，则需要检查得更加频繁；</li>
<li>在任何相对来说比较容易中止 operation 的地方。</li>
</ul>


<p>看到这里，我想你应该可以意识到一点，那就是尽管 operation 是支持取消操作的，但却并不是立即取消的，而是在你调用了 operation 的 <code>cancel</code> 方法之后的下一个 <code>isCancelled</code> 的检查点取消的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">///  支持取消操作</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">main</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@try</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">isCancelled</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing %@ with data: %@, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">),</span> <span class="nb">self</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="bp">NSUInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">isCancelled</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Loop %@&quot;</span><span class="p">,</span> <span class="l">@(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="l">)</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">@catch</span><span class="p">(</span><span class="bp">NSException</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Exception: %@&quot;</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>配置并发执行的 Operation</h3>

<p>在默认情况下，operation 是同步执行的，也就是说在调用它的 <code>start</code> 方法的线程中执行它们的任务。而在 operation 和 operation queue 结合使用时，operation queue 可以为非并发的 operation 提供线程，因此，大部分的 operation 仍然可以异步执行。但是，如果你想要手动地执行一个 operation ，又想这个 operation 能够异步执行的话，你需要做一些额外的配置来让你的 operation 支持并发执行。下面列举了一些你可能需要重写的方法：</p>

<ul>
<li><code>start</code> ：必须的，所有并发执行的 operation 都必须要重写这个方法，替换掉 NSOperation 类中的默认实现。<code>start</code> 方法是一个 operation 的起点，我们可以在这里配置任务执行的线程或者一些其它的执行环境。另外，需要特别注意的是，在我们重写的 <code>start</code> 方法中一定不要调用父类的实现；</li>
<li><code>main</code> ：可选的，通常这个方法就是专门用来实现与该 operation 相关联的任务的。尽管我们可以直接在 <code>start</code> 方法中执行我们的任务，但是用 <code>main</code> 方法来实现我们的任务可以使设置代码和任务代码得到分离，从而使 operation 的结构更清晰；</li>
<li><code>isExecuting</code> 和 <code>isFinished</code> ：必须的，并发执行的 operation 需要负责配置它们的执行环境，并且向外界客户报告执行环境的状态。因此，一个并发执行的 operation 必须要维护一些状态信息，用来记录它的任务是否正在执行，是否已经完成执行等。此外，当这两个方法所代表的值发生变化时，我们需要生成相应的 <code>KVO</code> 通知，以便外界能够观察到这些状态的变化；</li>
<li><code>isConcurrent</code> ：必须的，这个方法的返回值用来标识一个 operation 是否是并发的 operation ，我们需要重写这个方法并返回 <code>YES</code> 。</li>
</ul>


<p>下面我们将分三部分内容来介绍一下定义一个并发执行的 operation 所需的基本代码，主体部分的代码如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">OQConcurrentOperation</span>
</span><span class='line'>
</span><span class='line'><span class="k">@synthesize</span> <span class="n">executing</span> <span class="o">=</span> <span class="n">_executing</span><span class="p">;</span>
</span><span class='line'><span class="k">@synthesize</span> <span class="n">finished</span>  <span class="o">=</span> <span class="n">_finished</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">_executing</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>        <span class="n">_finished</span>  <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isConcurrent</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isExecuting</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_executing</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isFinished</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_finished</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这一部分的代码看上去比较简单，但是却需要我们用心地去理解它。首先，我们用 <code>@synthesize</code> 关键字手动合成了两个实例变量 <code>_executing</code> 和 <code>_finished</code> ，然后分别在重写的 <code>isExecuting</code> 和 <code>isFinished</code> 方法中返回了这两个实例变量。另外，我们通过查看 NSOperation 类的头文件可以发现，<code>executing</code> 和 <code>finished</code> 属性都被声明成了只读的 <code>readonly</code> 。所以我们在 NSOperation 子类中就没有办法直接通过 <code>setter</code> 方法来自动触发 <code>KVO</code> 通知，这也是为什么我们需要在接下来的代码中手动触发 <code>KVO</code> 通知的原因。</p>

<p>接下来是 <code>start</code> 方法的代码，在这个方法中，我们最需要关注的部分就是为 <code>main</code> 方法分离了一个新的线程，这是 operation 能够并发执行的关键所在。此外，在真正开始执行任务前，我们通过检查 <code>isCancelled</code> 方法的返回值来判断 operation 是否已经被 <code>cancel</code> ，如果是就直接返回了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">start</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">isCancelled</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">willChangeValueForKey</span><span class="p">:</span><span class="s">@&quot;isFinished&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="n">_finished</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">didChangeValueForKey</span><span class="p">:</span><span class="s">@&quot;isFinished&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">willChangeValueForKey</span><span class="p">:</span><span class="s">@&quot;isExecuting&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">detachNewThreadSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">main</span><span class="p">)</span> <span class="nl">toTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">withObject</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>    <span class="n">_executing</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">didChangeValueForKey</span><span class="p">:</span><span class="s">@&quot;isExecuting&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，是真正执行任务的 <code>main</code> 方法，值得注意的是在任务执行完毕后，我们需要手动触动 <code>isExecuting</code> 和 <code>isFinished</code> 的 <code>KVO</code> 通知。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">main</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@try</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing %@, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">),</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">willChangeValueForKey</span><span class="p">:</span><span class="s">@&quot;isExecuting&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="n">_executing</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">didChangeValueForKey</span><span class="p">:</span><span class="s">@&quot;isExecuting&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">willChangeValueForKey</span><span class="p">:</span><span class="s">@&quot;isFinished&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="n">_finished</span>  <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">didChangeValueForKey</span><span class="p">:</span><span class="s">@&quot;isFinished&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">@catch</span> <span class="p">(</span><span class="bp">NSException</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Exception: %@&quot;</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意</strong>，有一个非常重要的点需要引起我们的注意，那就是即使一个 operation 是被 <code>cancel</code> 掉了，我们仍然需要手动触发 <code>isFinished</code> 的 <code>KVO</code> 通知。因为当一个 operation 依赖其他 operation 时，它会观察所有其他 operation 的 <code>isFinished</code> 的值的变化，只有当它依赖的所有 operation 的 <code>isFinished</code> 的值为 <code>YES</code> 时，这个 operation 才能够开始执行。因此，如果一个我们自定义的 operation 被取消了但却没有手动触发 <code>isFinished</code> 的 <code>KVO</code> 通知的话，那么所有依赖它的 operation 都不会执行。</p>

<h3>维护 KVO 通知</h3>

<p>NSOperation 类的以下 <code>key paths</code> 支持 <code>KVO</code> 通知，我们可以通过观察这些 <code>key paths</code> 非常方便地监听到一个 operation 内部状态的变化：</p>

<ul>
<li>isCancelled</li>
<li>isConcurrent</li>
<li>isExecuting</li>
<li>isFinished</li>
<li>isReady</li>
<li>dependencies</li>
<li>queuePriority</li>
<li>completionBlock</li>
</ul>


<p>与重写 <code>main</code> 方法不同的是，如果我们重写了 <code>start</code> 方法或者对 NSOperation 类做了大量定制的话，我们需要保证自定义的 operation 在这些 <code>key paths</code> 上仍然支持 <code>KVO</code> 通知。比如，当我们重写了 <code>start</code> 方法时，我们需要特别关注的是 <code>isExecuting</code> 和 <code>isFinished</code> 这两个 <code>key paths</code> ，因为这两个 <code>key paths</code> 最可能受重写 <code>start</code> 方法的影响。</p>

<h2>定制 Operation 对象的执行行为</h2>

<p>我们可以在创建一个 operation 后，添加到 operation queue 前，对 operation 的一些执行行为进行定制。下面介绍的所有定制均适用于所有的 operation ，与是否是自定义的 NSOperation 子类或系统预定义的 NSOperation 子类无关。</p>

<h3>配置依赖关系</h3>

<p>通过配置依赖关系，我们可以让不同的 operation 串行执行，正如我们前面提到的，一个 operation 只有在它依赖的所有 operation 都执行完成后才能开始执行。配置 operation 的依赖关系主要涉及到 NSOperation 类中的以下两个方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addDependency:</span><span class="p">(</span><span class="bp">NSOperation</span> <span class="o">*</span><span class="p">)</span><span class="nv">op</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeDependency:</span><span class="p">(</span><span class="bp">NSOperation</span> <span class="o">*</span><span class="p">)</span><span class="nv">op</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>顾名思义，第一个方法用于添加依赖，第二个方法则用于移除依赖。需要特别注意的是，用 <code>addDependency:</code> 方法添加的依赖关系是单向的，比如 <code>[A addDependency:B];</code> ，表示 A 依赖 B，B 并不依赖 A 。</p>

<p>另外，这里的依赖关系并不局限于相同 operation queue 中的 operation 之间。其实，从上面两个配置依赖关系的方法是存在于 NSOperation 类中的，我们也可以看出来，operation 的依赖关系是它自己管理的，与它被添加到哪个 operation queue 无关。因此，我们完全可以给一些 operation 配置好依赖关系，然后将它们添加到不同的 operation queue 中。但是，有一点是需要我们特别注意的，就是不要在 operation 之间添加循环依赖，因为这样会导致这些 operation 都不会被执行。</p>

<p><strong>注意</strong>，我们应该在手动执行一个 operation 或将它添加到 operation queue 前配置好依赖关系，因为在之后添加的依赖关系可能会失效。</p>

<h3>修改 Operation 在队列中的优先级</h3>

<p>对于被添加到 operation queue 中的 operation 来说，决定它们执行顺序的第一要素是它们的 <code>isReady</code> 状态，其次是它们在队列中的优先级。operation 的 <code>isReady</code> 状态取决于它的依赖关系，而在队列中的优先级则是 operation 本身的属性。默认情况下，所有新创建的 operation 的队列优先级都是 <code>normal</code> 的，但是我们可以根据需要通过 <code>setQueuePriority:</code> 方法来提高或降低 operation 的队列优先级。</p>

<p>需要注意的是，队列优先级只应用于相同 operation queue 中的 operation 之间，不同 operation queue 中的 operation 不受此影响。另外，我们也需要清楚 operation 的队列优先级和依赖关系之间的区别。operation 的队列优先级只决定当前所有 <code>isReady</code> 状态为 <code>YES</code> 的 operation 的执行顺序。比如，在一个 operation queue 中，有一个高优先级和一个低优先级的 operation ，并且它们的 <code>isReady</code> 状态都为 <code>YES</code> ，那么高优先级的 operation 将会优先执行。而如果这个高优先级的 operation 的 <code>isReady</code> 状态为 <code>NO</code> ，而低优先级的 operation 的 <code>isReady</code> 状态为 <code>YES</code> 的话，那么这个低优先级的 operation 反而会优先执行。</p>

<h3>修改 Operation 执行任务线程的优先级</h3>

<p>从 iOS 4.0 开始，我们可以修改 operation 的执行任务线程的优先级。虽然 iOS 系统中的线程策略是由 <code>kernel</code> 内核管理的，但是一般来说，高优先级的线程相对于低优先级的线程来说能够得到更多的运行机会。我们可以给 operation 的线程优先级指定一个从 <code>0.0</code> 到 <code>1.0</code> 的浮点数值，<code>0.0</code> 表示最低的优先级，<code>1.0</code> 表示最高的优先级，默认值为 <code>0.5</code> 。</p>

<p><strong>注意</strong>，我们只能够在执行一个 operation 或将其添加到 operation queue 前，通过 operation 的 <code>setThreadPriority:</code> 方法来修改它的线程优先级。当 operation 开始执行时，NSOperation 类中默认的 <code>start</code> 方法会使用我们指定的值来修改当前线程的优先级。另外，我们指定的这个线程优先级只会影响 <code>main</code> 方法执行时所在线程的优先级。所有其它的代码，包括 operation 的 completion block 所在的线程会一直以默认的线程优先级执行。因此，当我们自定义一个并发的 operation 类时，我们也需要在 <code>start</code> 方法中根据指定的值自行修改线程的优先级。</p>

<h3>设置 Completion Block</h3>

<p>从 iOS 4.0 开始，一个 operation 可以在它的主任务执行完成时回调一个 completion block 。我们可以用 completion block 来执行一些主任务之外的工作，比如，我们可以用它来通知一些客户 operation 已经执行完毕，而并发的 operation 也可以用这个 block 来生成最终的 <code>KVO</code> 通知。如果需要设置一个 operation 的 completion block ，直接调用 NSOperation 类的 <code>setCompletionBlock:</code> 方法即可。</p>

<p><strong>注意</strong>，当一个 operation 被取消时，它的 completion block 仍然会执行，所以我们需要在真正执行代码前检查一下 <code>isCancelled</code> 方法的返回值。另外，我们也没有办法保证 completion block 被回调时一定是在主线程，理论上它应该是与触发 <code>isFinished</code> 的 <code>KVO</code> 通知所在的线程一致的，所以如果有必要的话我们可以在 completion block 中使用 <code>GCD</code> 来保证从主线程更新 <code>UI</code> 。</p>

<h2>执行 Operation 对象</h2>

<p>最终，我们需要执行 operation 来调度与其关联的任务。目前，主要有两种方式来执行一个 operation ：</p>

<ul>
<li>将 operation 添加到一个 operation queue 中，让 operation queue 来帮我们自动执行；</li>
<li>直接调用 <code>start</code> 方法手动执行 operation 。</li>
</ul>


<h3>添加 Operation 到 Operation Queue 中</h3>

<p>就目前来说，将 operation 添加到 operation queue 中是最简单的执行 operation 的方式。另外，这里的 operation queue 指的就是 NSOperationQueue 类的一个具体实例。就技术上而言，我们可以在应用中创建任意数量的 operation queue ，但是 operation queue 的数量越多并不意味着我们就能同时执行越多的 operation 。因为同时并发的 operation 数量是由系统决定的，系统会根据当前可用的核心数以及负载情况动态地调整最大的并发 operation 数量。创建一个 operation queue 非常简单，跟创建其他普通对象没有任何区别：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">operationQueue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>创建好 operation queue 后，我们可以使用下面三个方法添加 operation 到 operation queue 中：</p>

<ul>
<li><code>addOperation:</code> ，添加一个 operation 到 operation queue 中；</li>
<li><code>addOperations:waitUntilFinished:</code> ，添加一组 operation 到 operation queue 中；</li>
<li><code>addOperationWithBlock:</code> ，直接添加一个 block 到 operation queue 中，而不用创建一个 NSBlockOperation 对象。</li>
</ul>


<p>在大多数情况下，一个 operation 被添加到 operation queue 后不久就会执行，但是也有很多原因会使 operation queue 延迟执行入队的 operation 。比如，我们前面提到了的，如果一个 operation 所依赖的其他 operation 还没有执行完成时，这个 operation 就不能开始执行；再比如说 operation queue 被暂停执行或者已经达到了它最大可并发的 operation 数。下面的示例代码展示了这三种方法的基本用法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">OQUseOperationQueue</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">executeOperationUsingOperationQueue</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">operationQueue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSInvocationOperation</span> <span class="o">*</span><span class="n">invocationOperation</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSInvocationOperation</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">taskMethod</span><span class="p">)</span> <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">operationQueue</span> <span class="nl">addOperation</span><span class="p">:</span><span class="n">invocationOperation</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">blockOperation1</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing blockOperation1, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing blockOperation1&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">blockOperation2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing blockOperation2, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing blockOperation2&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">operationQueue</span> <span class="nl">addOperations</span><span class="p">:</span><span class="l">@[</span> <span class="n">blockOperation1</span><span class="p">,</span> <span class="n">blockOperation2</span> <span class="l">]</span> <span class="nl">waitUntilFinished</span><span class="p">:</span><span class="nb">NO</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">operationQueue</span> <span class="nl">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing block, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing block&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">operationQueue</span> <span class="n">waitUntilAllOperationsAreFinished</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">taskMethod</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing %@, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">),</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意</strong>，在将一个 operation 添加到 operation queue 后就不要再修改这个 operation 了。因为 operation 被添加到 operation queue 后随时可能会执行，这个是由系统决定的，所以再修改它的依赖关系或者所包含的数据就很有可能会造成未知的影响。</p>

<p>尽管 NSOperationQueue 类是被设计成用来并发执行 operation 的，但是我们也可以强制一个 operation queue 一次只执行一个 operation 。我们可以通过 <code>setMaxConcurrentoperationCount:</code> 方法来设置一个 operation queue 最大可并发的 operation 数，因此将这个值设置成 1 就可以实现让 operation queue 一次只执行一个 operation 的目的。但是需要注意的是，虽然这样可以让 operation queue 一次只执行一个 operation ，但是 operation 的执行顺序还是一样会受其他因素影响的，比如 operation 的 <code>isReady</code> 状态、operation 的队列优先级等。因此，一个串行的 operation queue 与一个串行的 dispatch queue 还是有本质区别的，因为 dispatch queue 的执行顺序一直是 <code>FIFO</code> 的。如果 operation 的执行顺序对我们来说非常重要，那么我们就应该在将 operation 添加到 operation queue 之前就建立好它的依赖关系。</p>

<h3>手动执行 Operation</h3>

<p>尽管使用 operation queue 是执行一个 operation 最方便的方式，但是我们也可以不用 operation queue 而选择手动地执行一个 operation 。从原理上来说，手动执行一个 operation 也是非常简单的，只需要调用它的 <code>start</code> 方法就可以了。但是从严格意义上来说，在调用 <code>start</code> 方法真正开始执行一个 operation 前，我们应该要做一些防范性的判断，比如检查 operation 的 <code>isReady</code> 状态是否为 <code>YES</code> ，这个取决于它所依赖的 operation 是否已经执行完成；又比如检查 operation 的 <code>isCancelled</code> 状态是否为 <code>YES</code> ，如果是，那么我们就根本不需要再花费不必要的开销去启动它。</p>

<p>另外，我们应该一直通过 <code>start</code> 方法去手动执行一个 operation ，而不是 <code>main</code> 或其他的什么方法。因为默认的 <code>start</code> 方法会在真正开始执行任务前为我们做一些安全性的检查，比如检查 operation 是否已取消等。另外，正如我们前面说的，在默认的 <code>start</code> 方法中会生成一些必要的 <code>KVO</code> 通知，比如 <code>isExcuting</code> 和 <code>isFinished</code> ，而这些 <code>KVO</code> 通知正是 operation 能够正确处理好依赖关系的关键所在。</p>

<p>更进一步说，如果我们需要实现的是一个并发的 operation ，我们也应该在启动 operation 前检查一下它的 <code>isConcurrent</code> 状态。如果它的 <code>isConcurrent</code> 状态为 <code>NO</code> ，那么我们就需要考虑一下是否可以在当前线程同步执行这个 operation ，或者是先为这个 operation 创建一个单独的线程，以供它异步执行。</p>

<p>当然，如果你已经能够确定一个 operation 的可执行状态，那么你大可不必做这些略显啰嗦的防范性检查，直接调用 <code>start</code> 方法执行这个 operation 即可。下面的示例代码展示了手动执行一个 operation 的基本流程：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">OQManualExecuteOperation</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">manualPerformOperation:</span><span class="p">(</span><span class="bp">NSOperation</span> <span class="o">*</span><span class="p">)</span><span class="nv">operation</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">ranIt</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">operation</span><span class="p">.</span><span class="n">isCancelled</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">ranIt</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">operation</span><span class="p">.</span><span class="n">isReady</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">operation</span><span class="p">.</span><span class="n">isConcurrent</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">[</span><span class="n">operation</span> <span class="n">start</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">detachNewThreadSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="nl">toTarget</span><span class="p">:</span><span class="n">operation</span> <span class="nl">withObject</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">ranIt</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">ranIt</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>取消 Operation</h3>

<p>从原则上来说，一旦一个 operation 被添加到 operation queue 后，这个 operation 的所有权就属于这个 operation queue 了，并且不能够被移除。唯一从 operation queue 中出队一个 operation 的方式就是调用它的 <code>cancel</code> 方法取消这个 operation ，或者直接调用 operation queue 的 <code>cancelAllOperations</code> 方法取消这个 operation queue 中所有的 operation 。另外，我们前面也提到了，当一个 operation 被取消后，这个 operation 的 <code>isFinished</code> 状态也会变成 <code>YES</code> ，这样处理的好处就是所有依赖它的 operation 能够接收到这个 <code>KVO</code> 通知，从而能够清除这个依赖关系正常执行。</p>

<h3>等待 Operation 执行完成</h3>

<p>一般来说，为了让我们的应用拥有最佳的性能，我们应该尽可能地异步执行所有的 operation ，从而让我们的应用在执行这些异步 operation 的同时还能够快速地响应用户事件。当然，我们也可以调用 NSOperation 类的 <code>waitUntilFinished</code> 方法来阻塞当前线程，直到这个 operation 执行完成。虽然这种方式可以让我们非常方便地处理 operation 的执行结果，但是却给我们的应用引入了更多的串行，限制了应用的并发性，从而降低了我们应用的响应性。</p>

<p><strong>注意</strong>，我们应该要坚决避免在主线程中去同步等待一个 operation 的执行结果，阻塞的方式只应该用在辅助线程或其他 operation 中。因为阻塞主线程会大大地降低我们应用的响应性，带来非常差的用户体验。</p>

<p>除了等待一个单独的 operation 执行完成外，我们也可以通过调用 NSOperationQueue 的 <code>waitUntilAlloperationsAreFinished</code> 方法来等待 operation queue 中的所有 operation 执行完成。有一点需要特别注意的是，当我们在等待一个 operation queue 中的所有 operation 执行完成时，其他的线程仍然可以向这个 operation queue 中添加 operation ，从而延长我们的等待时间。</p>

<h3>暂停和恢复 Operation Queue</h3>

<p>如果我们想要暂停和恢复执行 operation queue 中的 operation ，可以通过调用 operation queue 的 <code>setSuspended:</code> 方法来实现这个目的。不过需要注意的是，暂停执行 operation queue 并不能使正在执行的 operation 暂停执行，而只是简单地暂停调度新的 operation 。另外，我们并不能单独地暂停执行一个 operation ，除非直接 <code>cancel</code> 掉。</p>

<h2>总结</h2>

<p>看到这里，我想你对 iOS 的并发编程模型已经有了一定的了解。正如文中所说的，我们应该尽可能地直接使用队列而不是线程，让系统去与线程打交道，而我们只需定义好要调度的任务就可以了。一般情况下，我们也完全不需要去自定义一个并发的 operation ，因为在与 operation queue 结合使用时，operation queue 会自动为非并发的 operation 创建一个线程。Operation Queues 是对 <code>GCD</code> 面向对象的封装，它可以高度定制化，对依赖关系、队列优先级和线程优先级等提供了很好的支持，是我们实现复杂任务调度时的不二之选。</p>

<h2>参考链接</h2>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html">https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html</a>
<br>
<a href="http://www.raywenderlich.com/76341/use-nsoperation-nsoperationqueue-swift">http://www.raywenderlich.com/76341/use-nsoperation-nsoperationqueue-swift</a>
<br>
<a href="http://blog.xcodev.com/archives/operation-queue-intro/">http://blog.xcodev.com/archives/operation-queue-intro/</a></p>

<p><strong>版权声明</strong>：我已将本文在微信公众平台的发表权「独家代理」给 iOS 开发（iOSDevTips）微信公众号。扫下方二维码即可关注「iOS 开发」：</p>

<p><img src="http://blog.devtang.com/images/weixin-qr.jpg" alt="iOS 开发二维码" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Associated Objects 的实现原理]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/06/26/objective-c-associated-objects-implementation-principle/"/>
    <updated>2015-06-26T22:35:58+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/06/26/objective-c-associated-objects-implementation-principle</id>
    <content type="html"><![CDATA[<p>我们知道，在 Objective-C 中可以通过 Category 给一个现有的类添加属性，但是却不能添加实例变量，这似乎成为了 Objective-C 的一个明显短板。然而值得庆幸的是，我们可以通过 Associated Objects 来弥补这一不足。本文将结合 <a href="http://opensource.apple.com/tarballs/objc4/">runtime</a> 源码深入探究 Objective-C 中 Associated Objects 的实现原理。</p>

<p>在阅读本文的过程中，读者需要着重关注以下三个问题：</p>

<ol>
<li>关联对象被存储在什么地方，是不是存放在被关联对象本身的内存中？</li>
<li>关联对象的五种关联策略有什么区别，有什么坑？</li>
<li>关联对象的生命周期是怎样的，什么时候被释放，什么时候被移除？</li>
</ol>


<p></p>


<p>这是我写这篇文章的初衷，也是本文的价值所在。</p>

<h2>使用场景</h2>

<p>按照 Mattt Thompson 大神的文章 <a href="http://nshipster.com/associated-objects/">Associated Objects</a> 中的说法，Associated Objects 主要有以下三个使用场景：</p>

<ol>
<li>为现有的类添加私有变量以帮助实现细节；</li>
<li>为现有的类添加公有属性；</li>
<li>为 <code>KVO</code> 创建一个关联的观察者。</li>
</ol>


<p></p>


<p>从本质上看，第 <code>1</code> 、<code>2</code> 个场景其实是一个意思，唯一的区别就在于新添加的这个属性是公有的还是私有的而已。就目前来说，我在实际工作中使用得最多的是第 <code>2</code> 个场景，而第 <code>3</code> 个场景我还没有使用过。</p>

<h2>相关函数</h2>

<p>与 Associated Objects 相关的函数主要有三个，我们可以在 runtime 源码的 runtime.h 文件中找到它们的声明：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">objc_setAssociatedObject</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">id</span> <span class="n">value</span><span class="p">,</span> <span class="n">objc_AssociationPolicy</span> <span class="n">policy</span><span class="p">);</span>
</span><span class='line'><span class="kt">id</span> <span class="nf">objc_getAssociatedObject</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">objc_removeAssociatedObjects</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这三个函数的命名对程序员非常友好，可以让我们一眼就看出函数的作用：</p>

<ul>
<li><code>objc_setAssociatedObject</code> 用于给对象添加关联对象，传入 <code>nil</code> 则可以移除已有的关联对象；</li>
<li><code>objc_getAssociatedObject</code> 用于获取关联对象；</li>
<li><code>objc_removeAssociatedObjects</code> 用于移除一个对象的所有关联对象。</li>
</ul>


<p></p>


<p><strong>注</strong>：<code>objc_removeAssociatedObjects</code> 函数我们一般是用不上的，因为这个函数会移除一个对象的所有关联对象，将该对象恢复成“原始”状态。这样做就很有可能把别人添加的关联对象也一并移除，这并不是我们所希望的。所以一般的做法是通过给 <code>objc_setAssociatedObject</code> 函数传入 <code>nil</code> 来移除某个已有的关联对象。</p>

<h3>key 值</h3>

<p>关于前两个函数中的 <code>key</code> 值是我们需要重点关注的一个点，这个 <code>key</code> 值必须保证是一个对象级别（为什么是对象级别？看完下面的章节你就会明白了）的唯一常量。一般来说，有以下三种推荐的 <code>key</code> 值：</p>

<ol>
<li>声明 <code>static char kAssociatedObjectKey;</code> ，使用 <code>&amp;kAssociatedObjectKey</code> 作为 <code>key</code> 值;</li>
<li>声明 <code>static void *kAssociatedObjectKey = &amp;kAssociatedObjectKey;</code> ，使用 <code>kAssociatedObjectKey</code> 作为 <code>key</code> 值；</li>
<li>用 <code>selector</code> ，使用 <code>getter</code> 方法的名称作为 <code>key</code> 值。</li>
</ol>


<p></p>


<p>我个人最喜欢的（没有之一）是第 <code>3</code> 种方式，因为它省掉了一个变量名，非常优雅地解决了计算科学中的两大世界难题之一（命名）。</p>

<h3>关联策略</h3>

<p>在给一个对象添加关联对象时有五种关联策略可供选择：</p>

<p>
    <table border="1" width="100%">
        <tr>
            <th>关联策略</th>        
            <th>等价属性</th>        
            <th>说明</th>        
        </tr>
        <tr>
            <td>OBJC_ASSOCIATION_ASSIGN</td>        
            <td>@property (assign) or @property (unsafe_unretained)</td>
            <td>弱引用关联对象</td>        
        </tr>
        <tr>
            <td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>        
            <td>@property (strong, nonatomic)</td>        
            <td>强引用关联对象，且为非原子操作</td>        
        </tr>
        <tr>
            <td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>        
            <td>@property (copy, nonatomic)</td>        
            <td>复制关联对象，且为非原子操作</td>        
        </tr>
        <tr>
            <td>OBJC_ASSOCIATION_RETAIN</td>        
            <td>@property (strong, atomic)</td>        
            <td>强引用关联对象，且为原子操作</td>        
        </tr>
        <tr>
            <td>OBJC_ASSOCIATION_COPY</td>        
            <td>@property (copy, atomic)</td>        
            <td>复制关联对象，且为原子操作</td>        
        </tr>
    </table>
</p>


<p>其中，第 <code>2</code> 种与第 <code>4</code> 种、第 <code>3</code> 种与第 <code>5</code> 种关联策略的唯一差别就在于操作是否具有原子性。由于操作的原子性不在本文的讨论范围内，所以下面的实验和讨论就以前三种以例进行展开。</p>

<h2>实现原理</h2>

<p>在探究 Associated Objects 的实现原理前，我们还是先来动手做一个小实验，研究一下关联对象什么时候会被释放。本实验主要涉及 <code>ViewController</code> 类和它的分类 <code>ViewController+AssociatedObjects</code> 。<strong>注</strong>：本实验的完整代码可以在这里 <a href="https://github.com/leichunfeng/AssociatedObjects">AssociatedObjects</a> 找到，其中关键代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">ViewController</span> <span class="nl">(AssociatedObjects)</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">associatedObject_assign</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">associatedObject_retain</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">copy</span><span class="p">,</span>   <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">associatedObject_copy</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ViewController</span> <span class="nl">(AssociatedObjects)</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">associatedObject_assign</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAssociatedObject_assign:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">associatedObject_assign</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">associatedObject_assign</span><span class="p">),</span> <span class="n">associatedObject_assign</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_ASSIGN</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">associatedObject_retain</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAssociatedObject_retain:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">associatedObject_retain</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">associatedObject_retain</span><span class="p">),</span> <span class="n">associatedObject_retain</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">associatedObject_copy</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAssociatedObject_copy:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">associatedObject_copy</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">associatedObject_copy</span><span class="p">),</span> <span class="n">associatedObject_copy</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_COPY_NONATOMIC</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 <code>ViewController+AssociatedObjects.h</code> 中声明了三个属性，限定符分别为 <code>assign, nonatomic</code> 、<code>strong, nonatomic</code> 和 <code>copy, nonatomic</code> ，而在 <code>ViewController+AssociatedObjects.m</code> 中相应的分别用 <code>OBJC_ASSOCIATION_ASSIGN</code> 、<code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> 、<code>OBJC_ASSOCIATION_COPY_NONATOMIC</code> 三种关联策略为这三个属性添加“实例变量”。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">__weak</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">string_weak_assign</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="k">__weak</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">string_weak_retain</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="k">__weak</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">string_weak_copy</span>   <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ViewController</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">associatedObject_assign</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;leichunfeng1&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">associatedObject_retain</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;leichunfeng2&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">associatedObject_copy</span>   <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;leichunfeng3&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">string_weak_assign</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">associatedObject_assign</span><span class="p">;</span>
</span><span class='line'>    <span class="n">string_weak_retain</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">associatedObject_retain</span><span class="p">;</span>
</span><span class='line'>    <span class="n">string_weak_copy</span>   <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">associatedObject_copy</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesBegan:</span><span class="p">(</span><span class="bp">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
</span><span class='line'><span class="c1">//    NSLog(@&quot;self.associatedObject_assign: %@&quot;, self.associatedObject_assign); // Will Crash</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;self.associatedObject_retain: %@&quot;</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">associatedObject_retain</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;self.associatedObject_copy:   %@&quot;</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">associatedObject_copy</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 <code>ViewController</code> 的 <code>viewDidLoad</code> 方法中，我们对三个属性进行了赋值，并声明了三个全局的 <code>__weak</code> 变量来观察相应对象的释放时机。此外，我们重写了 <code>touchesBegan:withEvent:</code> 方法，在方法中分别打印了这三个属性的当前值。</p>

<p>在继续阅读下面章节前，建议读者先自行思考一下 <code>self.associatedObject_assign</code> 、<code>self.associatedObject_retain</code> 和 <code>self.associatedObject_copy</code> 指向的对象分别会在什么时候被释放，以加深理解。</p>

<h3>实验</h3>

<p>我们先在 <code>viewDidLoad</code> 方法的第 <code>28</code> 行打上断点，然后运行程序，点击导航栏右上角的按钮 <code>Push</code> 到 <code>ViewController</code> 界面，程序将停在断点处。接着，我们使用 <code>lldb</code> 的 <code>watchpoint</code> 命令来设置观察点，观察全局变量 <code>string_weak_assign</code> 、<code>string_weak_retain</code> 和 <code>string_weak_copy</code> 的值的变化。正确设置好观察点后，将会在 <code>console</code> 中看到如下的类似输出：</p>

<p><img src="http://blog.leichunfeng.com/images/AssociatedObjects1.jpg" title="设置观察点" alt="设置观察点" /></p>

<p>点击继续运行按钮，有一个观察点将被命中。我们先查看 <code>console</code> 中的输出，通过将这一步打印的 <code>old value</code> 和上一步的 <code>new value</code> 进行对比，我们可以知道本次命中的观察点是 <code>string_weak_assign</code> ，<code>string_weak_assign</code> 的值变成了 <code>0x0000000000000000</code> ，也就是 <code>nil</code> 。换句话说 <code>self.associatedObject_assign</code> 指向的对象已经被释放了，而通过查看左侧调用栈我们可以知道，这个对象是由于其所在的 <code>autoreleasepool</code> 被 <code>drain</code> 而被释放的，这与我前面的文章<a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/">《Objective-C Autorelease Pool 的实现原理
》</a>中的表述是一致的。<strong>提示</strong>，待会你也可以放开 <code>touchesBegan:withEvent:</code> 中第 <code>31</code> 行的注释，在 <code>ViewController</code> 出现后，点击一下它的 <code>view</code> ，进一步验证一下这个结论。</p>

<p><img src="http://blog.leichunfeng.com/images/AssociatedObjects2.jpg" title="设置观察点" alt="设置观察点" /></p>

<p>接下来，我们点击 <code>ViewController</code> 导航栏左上角的按钮，返回前一个界面，此时，又将有一个观察点被命中。同理，我们可以知道这个观察点是 <code>string_weak_retain</code> 。我们查看左侧的调用栈，将会发现一个非常敏感的函数调用 <code>_object_remove_assocations</code> ，调用这个函数后 <code>ViewController</code> 的所有关联对象被全部移除。最终，<code>self.associatedObject_retain</code> 指向的对象被释放。</p>

<p><img src="http://blog.leichunfeng.com/images/AssociatedObjects3.jpg" title="设置观察点" alt="设置观察点" /></p>

<p>点击继续运行按钮，最后一个观察点 <code>string_weak_copy</code> 被命中。同理，<code>self.associatedObject_copy</code> 指向的对象也由于关联对象的移除被最终释放。</p>

<p><img src="http://blog.leichunfeng.com/images/AssociatedObjects4.jpg" title="设置观察点" alt="设置观察点" /></p>

<h3>结论</h3>

<p>由这个实验，我们可以得出以下结论：</p>

<ol>
<li>关联对象的释放时机与被移除的时机并不总是一致的，比如上面的 <code>self.associatedObject_assign</code> 所指向的对象在 <code>ViewController</code> 出现后就被释放了，但是 <code>self.associatedObject_assign</code> 仍然有值，还是保存的原对象的地址。如果之后再使用 <code>self.associatedObject_assign</code> 就会造成 Crash ，所以我们在使用弱引用的关联对象时要非常小心；</li>
<li>一个对象的所有关联对象是在这个对象被释放时调用的 <code>_object_remove_assocations</code> 函数中被移除的。</li>
</ol>


<p></p>


<p>接下来，我们就一起看看 runtime 中的源码，来验证下我们的实验结论。</p>

<h3>objc_setAssociatedObject</h3>

<p>我们可以在 <code>objc-references.mm</code> 文件中找到 <code>objc_setAssociatedObject</code> 函数最终调用的函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">_object_set_associative_reference</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">id</span> <span class="n">value</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">policy</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// retain the new value (if any) outside the lock.</span>
</span><span class='line'>    <span class="n">ObjcAssociation</span> <span class="n">old_association</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">nil</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">new_value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">?</span> <span class="n">acquireValue</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">policy</span><span class="p">)</span> <span class="o">:</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">AssociationsManager</span> <span class="n">manager</span><span class="p">;</span>
</span><span class='line'>        <span class="n">AssociationsHashMap</span> <span class="o">&amp;</span><span class="n">associations</span><span class="p">(</span><span class="n">manager</span><span class="p">.</span><span class="n">associations</span><span class="p">());</span>
</span><span class='line'>        <span class="kt">disguised_ptr_t</span> <span class="n">disguised_object</span> <span class="o">=</span> <span class="n">DISGUISE</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">new_value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// break any existing association.</span>
</span><span class='line'>            <span class="n">AssociationsHashMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">associations</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">disguised_object</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">associations</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// secondary table exists</span>
</span><span class='line'>                <span class="n">ObjectAssociationMap</span> <span class="o">*</span><span class="n">refs</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'>                <span class="n">ObjectAssociationMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">j</span> <span class="o">=</span> <span class="n">refs</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">refs</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">old_association</span> <span class="o">=</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'>                    <span class="n">j</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="n">ObjcAssociation</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">new_value</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                    <span class="p">(</span><span class="o">*</span><span class="n">refs</span><span class="p">)[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ObjcAssociation</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">new_value</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// create the new association (first time).</span>
</span><span class='line'>                <span class="n">ObjectAssociationMap</span> <span class="o">*</span><span class="n">refs</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ObjectAssociationMap</span><span class="p">;</span>
</span><span class='line'>                <span class="n">associations</span><span class="p">[</span><span class="n">disguised_object</span><span class="p">]</span> <span class="o">=</span> <span class="n">refs</span><span class="p">;</span>
</span><span class='line'>                <span class="p">(</span><span class="o">*</span><span class="n">refs</span><span class="p">)[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ObjcAssociation</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">new_value</span><span class="p">);</span>
</span><span class='line'>                <span class="n">object</span><span class="o">-&gt;</span><span class="n">setHasAssociatedObjects</span><span class="p">();</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// setting the association to nil breaks the association.</span>
</span><span class='line'>            <span class="n">AssociationsHashMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">associations</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">disguised_object</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span>  <span class="n">associations</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">ObjectAssociationMap</span> <span class="o">*</span><span class="n">refs</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'>                <span class="n">ObjectAssociationMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">j</span> <span class="o">=</span> <span class="n">refs</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">refs</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">old_association</span> <span class="o">=</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'>                    <span class="n">refs</span><span class="o">-&gt;</span><span class="n">erase</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// release the old value (outside of the lock).</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">old_association</span><span class="p">.</span><span class="n">hasValue</span><span class="p">())</span> <span class="n">ReleaseValue</span><span class="p">()(</span><span class="n">old_association</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在看这段代码前，我们需要先了解一下几个数据结构以及它们之间的关系：</p>

<ol>
<li><code>AssociationsManager</code> 是顶级的对象，维护了一个从 <code>spinlock_t</code> 锁到 <code>AssociationsHashMap</code> 哈希表的单例键值对映射；</li>
<li><code>AssociationsHashMap</code> 是一个无序的哈希表，维护了从对象地址到 <code>ObjectAssociationMap</code> 的映射；</li>
<li><code>ObjectAssociationMap</code> 是一个 <code>C++</code> 中的 <code>map</code> ，维护了从 <code>key</code> 到 <code>ObjcAssociation</code> 的映射，即关联记录；</li>
<li><code>ObjcAssociation</code> 是一个 <code>C++</code> 的类，表示一个具体的关联结构，主要包括两个实例变量，<code>_policy</code> 表示关联策略，<code>_value</code> 表示关联对象。</li>
</ol>


<p></p>


<p>每一个对象地址对应一个 <code>ObjectAssociationMap</code> 对象，而一个 <code>ObjectAssociationMap</code> 对象保存着这个对象的若干个关联记录。</p>

<p>弄清楚这些数据结构之间的关系后，再回过头来看上面的代码就不难了。我们发现，在苹果的底层代码中一般都会充斥着各种 <code>if else</code> ，可见写好 <code>if else</code> 后我们就距离成为高手不远了。开个玩笑，我们来看下面的流程图，一图胜千言：</p>

<p><img src="http://blog.leichunfeng.com/images/objc_setAssociatedObject.png" title="objc_setAssociatedObject" alt="objc_setAssociatedObject" /></p>

<h3>objc_getAssociatedObject</h3>

<p>同样的，我们也可以在 <code>objc-references.mm</code> 文件中找到 <code>objc_getAssociatedObject</code> 函数最终调用的函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="nf">_object_get_associative_reference</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">uintptr_t</span> <span class="n">policy</span> <span class="o">=</span> <span class="n">OBJC_ASSOCIATION_ASSIGN</span><span class="p">;</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">AssociationsManager</span> <span class="n">manager</span><span class="p">;</span>
</span><span class='line'>        <span class="n">AssociationsHashMap</span> <span class="o">&amp;</span><span class="n">associations</span><span class="p">(</span><span class="n">manager</span><span class="p">.</span><span class="n">associations</span><span class="p">());</span>
</span><span class='line'>        <span class="kt">disguised_ptr_t</span> <span class="n">disguised_object</span> <span class="o">=</span> <span class="n">DISGUISE</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
</span><span class='line'>        <span class="n">AssociationsHashMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">associations</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">disguised_object</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">associations</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">ObjectAssociationMap</span> <span class="o">*</span><span class="n">refs</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'>            <span class="n">ObjectAssociationMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">j</span> <span class="o">=</span> <span class="n">refs</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">refs</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">ObjcAssociation</span> <span class="o">&amp;</span><span class="n">entry</span> <span class="o">=</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'>                <span class="n">value</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
</span><span class='line'>                <span class="n">policy</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">policy</span><span class="p">();</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">policy</span> <span class="o">&amp;</span> <span class="n">OBJC_ASSOCIATION_GETTER_RETAIN</span><span class="p">)</span> <span class="p">((</span><span class="kt">id</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">value</span><span class="p">,</span> <span class="n">SEL_retain</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">policy</span> <span class="o">&amp;</span> <span class="n">OBJC_ASSOCIATION_GETTER_AUTORELEASE</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">((</span><span class="kt">id</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">value</span><span class="p">,</span> <span class="n">SEL_autorelease</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>看懂了 <code>objc_setAssociatedObject</code> 函数后，<code>objc_getAssociatedObject</code> 函数对我们来说就是小菜一碟了。这个函数先根据对象地址在 <code>AssociationsHashMap</code> 中查找其对应的 <code>ObjectAssociationMap</code> 对象，如果能找到则进一步根据 <code>key</code> 在 <code>ObjectAssociationMap</code> 对象中查找这个 <code>key</code> 所对应的关联结构 <code>ObjcAssociation</code> ，如果能找到则返回 <code>ObjcAssociation</code> 对象的 <code>value</code> 值，否则返回 <code>nil</code> 。</p>

<h3>objc_removeAssociatedObjects</h3>

<p>同理，我们也可以在 <code>objc-references.mm</code> 文件中找到 <code>objc_removeAssociatedObjects</code> 函数最终调用的函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">_object_remove_assocations</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">vector</span><span class="o">&lt;</span> <span class="n">ObjcAssociation</span><span class="p">,</span><span class="n">ObjcAllocator</span><span class="o">&lt;</span><span class="n">ObjcAssociation</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">elements</span><span class="p">;</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">AssociationsManager</span> <span class="n">manager</span><span class="p">;</span>
</span><span class='line'>        <span class="n">AssociationsHashMap</span> <span class="o">&amp;</span><span class="n">associations</span><span class="p">(</span><span class="n">manager</span><span class="p">.</span><span class="n">associations</span><span class="p">());</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">associations</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">disguised_ptr_t</span> <span class="n">disguised_object</span> <span class="o">=</span> <span class="n">DISGUISE</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
</span><span class='line'>        <span class="n">AssociationsHashMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">associations</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">disguised_object</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">associations</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// copy all of the associations that need to be removed.</span>
</span><span class='line'>            <span class="n">ObjectAssociationMap</span> <span class="o">*</span><span class="n">refs</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'>            <span class="k">for</span> <span class="p">(</span><span class="n">ObjectAssociationMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">j</span> <span class="o">=</span> <span class="n">refs</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span> <span class="o">=</span> <span class="n">refs</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">elements</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">j</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="c1">// remove the secondary table.</span>
</span><span class='line'>            <span class="n">delete</span> <span class="n">refs</span><span class="p">;</span>
</span><span class='line'>            <span class="n">associations</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// the calls to releaseValue() happen outside of the lock.</span>
</span><span class='line'>    <span class="n">for_each</span><span class="p">(</span><span class="n">elements</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">elements</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ReleaseValue</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数负责移除一个对象的所有关联对象，具体实现也是先根据对象的地址获取其对应的 <code>ObjectAssociationMap</code> 对象，然后将所有的关联结构保存到一个 <code>vector</code> 中，最终释放 <code>vector</code> 中保存的所有关联对象。根据前面的实验观察到的情况，在一个对象被释放时，也正是调用的这个函数来移除其所有的关联对象。</p>

<h3>给类对象添加关联对象</h3>

<p>看完源代码后，我们知道对象地址与 <code>AssociationsHashMap</code> 哈希表是一一对应的。那么我们可能就会思考这样一个问题，是否可以给类对象添加关联对象呢？答案是肯定的。我们完全可以用同样的方式给类对象添加关联对象，只不过我们一般情况下不会这样做，因为更多时候我们可以通过 <code>static</code> 变量来实现类级别的变量。我在分类 <code>ViewController+AssociatedObjects</code> 中给 <code>ViewController</code> 类对象添加了一个关联对象 <code>associatedObject</code> ，读者可以亲自在 <code>viewDidLoad</code> 方法中调用一下以下两个方法验证一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">associatedObject</span><span class="p">;</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAssociatedObject:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">associatedObject</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>读到这里，相信你对开篇的那三个问题已经有了一定的认识，下面我们再梳理一下：</p>

<ol>
<li>关联对象与被关联对象本身的存储并没有直接的关系，它是存储在单独的哈希表中的；</li>
<li>关联对象的五种关联策略与属性的限定符非常类似，在绝大多数情况下，我们都会使用 <code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> 的关联策略，这可以保证我们持有关联对象；</li>
<li>关联对象的释放时机与移除时机并不总是一致，比如实验中用关联策略 <code>OBJC_ASSOCIATION_ASSIGN</code> 进行关联的对象，很早就已经被释放了，但是并没有被移除，而再使用这个关联对象时就会造成 Crash 。</li>
</ol>


<p></p>


<p>在弄懂 Associated Objects 的实现原理后，可以帮助我们更好地使用它，在出现问题时也能尽快地定位问题，最后希望本文能够对你有所帮助。</p>

<h2>参考链接</h2>

<p><a href="http://nshipster.com/associated-objects/">http://nshipster.com/associated-objects/</a>
<br>
<a href="http://kingscocoa.com/tutorials/associated-objects/">http://kingscocoa.com/tutorials/associated-objects/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Method Swizzling 的最佳实践]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/06/14/objective-c-method-swizzling-best-practice/"/>
    <updated>2015-06-14T12:03:32+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/06/14/objective-c-method-swizzling-best-practice</id>
    <content type="html"><![CDATA[<p>Objective-C 中的 Method Swizzling 是一项<strong>异常</strong>强大的技术，它可以允许我们动态地替换方法的实现，实现 <code>Hook</code> 功能，是一种比子类化更加灵活的“重写”方法的方式。</p>

<h2>Method Swizzling 的原理</h2>

<p>Method Swizzling 是一把双刃剑，使用得当可以让我们非常轻松地实现复杂的功能，而如果一旦误用，它也很可能会给我们的程序带来毁灭性的伤害。但是我们大可不必惊慌，在了解了它的实现原理后，我们就可以“信手拈来”了。</p>

<p>我们先来了解下 Objective-C 中方法 <code>Method</code> 的数据结构：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="kt">method_t</span> <span class="o">*</span><span class="n">Method</span><span class="p">;</span>
</span><span class='line'><span class="k">struct</span> <span class="kt">method_t</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">SEL</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">types</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">IMP</span> <span class="n">imp</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">struct</span> <span class="nl">SortBySELAddress</span> <span class="p">:</span>
</span><span class='line'>        <span class="n">public</span> <span class="n">std</span><span class="o">::</span><span class="n">binary_function</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">method_t</span><span class="o">&amp;</span><span class="p">,</span>
</span><span class='line'>                                    <span class="k">const</span> <span class="kt">method_t</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">bool</span> <span class="n">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="kt">method_t</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span>
</span><span class='line'>                         <span class="k">const</span> <span class="kt">method_t</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span> <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">name</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>本质上，它就是 <code>struct method_t</code> 类型的指针，所以我们重点看下结构体 <code>method_t</code> 的定义。在结构体 <code>method_t</code> 中定义了三个成员变量和一个成员函数：</p>

<ol>
<li><code>name</code> 表示的是方法的名称，用于唯一标识某个方法，比如 <code>@selector(viewWillAppear:)</code> ；</li>
<li><code>types</code> 表示的是方法的返回值和参数类型（详细信息可以查阅苹果官方文档中的 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encodings</a> ）；</li>
<li><code>imp</code> 是一个函数指针，指向方法的实现；</li>
<li><code>SortBySELAddress</code> 顾名思义，是一个根据 <code>name</code> 的地址对方法进行排序的函数。</li>
</ol>


<p>由此，我们也可以发现 Objective-C 中的方法名是不包括参数类型的，也就是说下面两个方法在 runtime 看来就是同一个方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillAppear:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">string</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>而下面两个方法却是可以共存的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span><span class="p">;</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为实例方法和类方法是分别保存在类对象和元类对象中的，更多详情可以查看我前面的文章<a href="http://blog.leichunfeng.com/blog/2015/04/25/objective-c-object-model/">《Objective-C 对象模型》</a>。</p>

<p>原则上，方法的名称 <code>name</code> 和方法的实现 <code>imp</code> 是一一对应的，而 Method Swizzling 的原理就是动态地改变它们的对应关系，以达到替换方法实现的目的。</p>

<h2>Method Swizzling 有什么用</h2>

<p>说了这么多，到底 Method Swizzling 有什么用呢？表猴急哈，我们接下来看个例子就明白了。用过<a href="http://www.umeng.com/">友盟</a>统计的同学应该知道，要实现<a href="http://dev.umeng.com/analytics/ios-doc/integration#3">页面的统计</a>功能，我们需要在每个页面的 <code>view controller</code> 中添加如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="nl">viewWillAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">MobClick</span> <span class="nl">beginLogPageView</span><span class="p">:</span><span class="s">@&quot;PageOne&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillDisappear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="nl">viewWillDisappear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">MobClick</span> <span class="nl">endLogPageView</span><span class="p">:</span><span class="s">@&quot;PageOne&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>要达到这个目的，我们有两种比较常规的实现方式：</p>

<ol>
<li>直接修改每个页面的 <code>view controller</code> 代码，简单粗暴；</li>
<li>子类化 <code>view controller</code> ，并让我们的 <code>view controller</code> 都继承这些子类。</li>
</ol>


<p>第 1 种方式的缺点是不言而喻的，这样做不仅会产生大量重复的代码，而且还很容易遗漏某些页面，非常难维护；第 2 种方式稍微好一点，但是也同样需要我们子类化 <code>UIViewController</code> 、<code>UITableViewController</code> 和 <code>UITabBarController</code> 等不同类型的 <code>view controller</code> 。</p>

<p>也许你跟我一样陷入了思考，难道就没有一种简单优雅的解决方案吗？答案是肯定的，Method Swizzling 就是解决此类问题的最佳方式。</p>

<h2>Method Swizzling 的最佳实践</h2>

<p>下面我们就以替换 <code>viewWillAppear</code> 方法为例谈谈 Method Swizzling 的最佳实践，话不多说，直接上代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="bp">UIViewController</span> <span class="nl">(MRCUMAnalytics)</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="bp">UIViewController</span> <span class="nl">(MRCUMAnalytics)</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">load</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class='line'>    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="kt">Class</span> <span class="k">class</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="k">class</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">SEL</span> <span class="n">originalSelector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">viewWillAppear</span><span class="p">:);</span>
</span><span class='line'>        <span class="kt">SEL</span> <span class="n">swizzledSelector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">mrc_viewWillAppear</span><span class="p">:);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">Method</span> <span class="n">originalMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="k">class</span><span class="p">,</span> <span class="n">originalSelector</span><span class="p">);</span>
</span><span class='line'>        <span class="n">Method</span> <span class="n">swizzledMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="k">class</span><span class="p">,</span> <span class="n">swizzledSelector</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">BOOL</span> <span class="n">success</span> <span class="o">=</span> <span class="n">class_addMethod</span><span class="p">(</span><span class="k">class</span><span class="p">,</span> <span class="n">originalSelector</span><span class="p">,</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">swizzledMethod</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">swizzledMethod</span><span class="p">));</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">class_replaceMethod</span><span class="p">(</span><span class="k">class</span><span class="p">,</span> <span class="n">swizzledSelector</span><span class="p">,</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">));</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">,</span> <span class="n">swizzledMethod</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - Method Swizzling</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">mrc_viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">mrc_viewWillAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">MobClick</span> <span class="nl">beginLogPageView</span><span class="p">:</span><span class="n">NSStringFromClass</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">])];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>解析</strong>：在上面的代码中有三个关键点需要引起我们的注意：</p>

<ol>
<li>为什么是在 <code>+load</code> 方法中实现 Method Swizzling 的逻辑，而不是其他的什么方法，比如 <code>+initialize</code> 等；</li>
<li>为什么 Method Swizzling 的逻辑需要用 dispatch_once 来进行调度；</li>
<li>为什么需要调用 <code>class_addMethod</code> 方法，并且以它的结果为依据分别处理两种不同的情况。</li>
</ol>


<p>下面我们就一起来分析下这三个为什么到底是为了什么？</p>

<p><strong>第 1 个为什么</strong>：看过我前面文章<a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/">《Objective-C +load vs +initialize》</a> 的同学应该知道，<code>+load</code> 和 <code>+initialize</code> 是 Objective-C runtime 会自动调用的两个类方法。但是它们被调用的时机却是有差别的，<code>+load</code> 方法是在类被加载的时候调用的，而 <code>+initialize</code> 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。也就是说 <code>+initialize</code> 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 <code>+initialize</code> 方法是永远不会被调用的。此外 <code>+load</code> 方法还有一个非常重要的特性，那就是子类、父类和分类中的 <code>+load</code> 方法的实现是被区别对待的。换句话说在 Objective-C runtime 自动调用 <code>+load</code> 方法时，分类中的 <code>+load</code> 方法并不会对主类中的 <code>+load</code> 方法造成覆盖。综上所述，<code>+load</code> 方法是实现 Method Swizzling 逻辑的最佳“场所”。</p>

<p><strong>第 2 个为什么</strong>：我们上面提到，<code>+load</code> 方法在类加载的时候会被 runtime 自动调用一次，但是它并没有限制程序员对 <code>+load</code> 方法的手动调用。什么？你说不会有程序员这么干？那可说不定，我还见过手动调用 <code>viewDidLoad</code> 方法的程序员，就是介么任性。而我们所能够做的就是尽可能地保证程序能够在各种情况下正常运行。</p>

<p><strong>第 3 个为什么</strong>：我们使用 Method Swizzling 的目的通常都是为了给程序增加功能，而不是完全地替换某个功能，所以我们一般都需要在自定义的实现中调用原始的实现。所以这里就会有两种情况需要我们分别进行处理：</p>

<p><strong>第 1 种情况</strong>：主类本身有实现需要替换的方法，也就是 <code>class_addMethod</code> 方法返回 <code>NO</code> 。这种情况的处理比较简单，直接交换两个方法的实现就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">/// 先调用原始实现，由于主类本身有实现该方法，所以这里实际调用的是主类的实现</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">mrc_viewWillAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">/// 我们增加的功能</span>
</span><span class='line'>    <span class="p">[</span><span class="n">MobClick</span> <span class="nl">beginLogPageView</span><span class="p">:</span><span class="n">NSStringFromClass</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">])];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">mrc_viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">/// 主类的实现</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>第 2 种情况</strong>：主类本身没有实现需要替换的方法，而是继承了父类的实现，即 <code>class_addMethod</code> 方法返回 <code>YES</code> 。这时使用 <code>class_getInstanceMethod</code> 函数获取到的 <code>originalSelector</code> 指向的就是父类的方法，我们再通过执行 <code>class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</code> 将父类的实现替换到我们自定义的 <code>mrc_viewWillAppear</code> 方法中。这样就达到了在 <code>mrc_viewWillAppear</code> 方法的实现中调用父类实现的目的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">/// 先调用原始实现，由于主类本身并没有实现该方法，所以这里实际调用的是父类的实现</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">mrc_viewWillAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">/// 我们增加的功能</span>
</span><span class='line'>    <span class="p">[</span><span class="n">MobClick</span> <span class="nl">beginLogPageView</span><span class="p">:</span><span class="n">NSStringFromClass</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">])];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">mrc_viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">/// 父类的实现</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>看到这里，相信你对 Method Swizzling 已经有了一定的了解，那么接下来就请你自己亲自试一试吧，you should give it a try yourself 。</p>

<h2>总结</h2>

<p>Method Swizzling 是一种黑魔法，我们在使用它时需要加倍小心，而遵循本文的最佳实践可以让你事半功倍。</p>

<h2>参考链接</h2>

<p><a href="http://nshipster.com/method-swizzling/">http://nshipster.com/method-swizzling/</a>
<br>
<a href="https://www.mikeash.com/pyblog/friday-qa-2010-01-29-method-replacement-for-fun-and-profit.html">https://www.mikeash.com/pyblog/friday-qa-2010-01-29-method-replacement-for-fun-and-profit.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Autorelease Pool 的实现原理]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/"/>
    <updated>2015-05-31T10:46:34+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle</id>
    <content type="html"><![CDATA[<p>内存管理一直是学习 Objective-C 的重点和难点之一，尽管现在已经是 ARC 时代了，但是了解 Objective-C 的内存管理机制仍然是十分必要的。其中，弄清楚 autorelease 的原理更是重中之重，只有理解了 autorelease 的原理，我们才算是真正了解了 Objective-C 的内存管理机制。<strong>注</strong>：本文使用的 <a href="http://opensource.apple.com/tarballs/objc4/">runtime</a> 源码是当前的最新版本 <code>objc4-646.tar.gz</code> 。</p>

<h2>autoreleased 对象什么时候释放</h2>

<p>autorelease 本质上就是延迟调用 release ，那 autoreleased 对象究竟会在什么时候释放呢？为了弄清楚这个问题，我们先来做一个小实验。这个小实验分 3 种场景进行，请你先自行思考在每种场景下的 console 输出，以加深理解。<strong>注</strong>：本实验的源码可以在这里 <a href="https://github.com/leichunfeng/AutoreleasePool">AutoreleasePool</a> 找到。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">__weak</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">string_weak_</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 场景 1</span>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;leichunfeng&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">string_weak_</span> <span class="o">=</span> <span class="n">string</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 场景 2</span>
</span><span class='line'><span class="c1">//    @autoreleasepool {</span>
</span><span class='line'><span class="c1">//        NSString *string = [NSString stringWithFormat:@&quot;leichunfeng&quot;];</span>
</span><span class='line'><span class="c1">//        string_weak_ = string;</span>
</span><span class='line'><span class="c1">//    }</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 场景 3</span>
</span><span class='line'><span class="c1">//    NSString *string = nil;</span>
</span><span class='line'><span class="c1">//    @autoreleasepool {</span>
</span><span class='line'><span class="c1">//        string = [NSString stringWithFormat:@&quot;leichunfeng&quot;];</span>
</span><span class='line'><span class="c1">//        string_weak_ = string;</span>
</span><span class='line'><span class="c1">//    }</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;string: %@&quot;</span><span class="p">,</span> <span class="n">string_weak_</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="nl">viewWillAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;string: %@&quot;</span><span class="p">,</span> <span class="n">string_weak_</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="nl">viewDidAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;string: %@&quot;</span><span class="p">,</span> <span class="n">string_weak_</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>思考得怎么样了？相信在你心中已经有答案了。那么让我们一起来看看 console 输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 场景 1</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">32</span><span class="o">:</span><span class="mf">20.837</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33876</span><span class="o">:</span><span class="mi">1448343</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="n">leichunfeng</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">32</span><span class="o">:</span><span class="mf">20.838</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33876</span><span class="o">:</span><span class="mi">1448343</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="n">leichunfeng</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">32</span><span class="o">:</span><span class="mf">20.845</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33876</span><span class="o">:</span><span class="mi">1448343</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="p">(</span><span class="n">null</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 场景 2</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">32</span><span class="o">:</span><span class="mf">50.548</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33915</span><span class="o">:</span><span class="mi">1448912</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="p">(</span><span class="n">null</span><span class="p">)</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">32</span><span class="o">:</span><span class="mf">50.549</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33915</span><span class="o">:</span><span class="mi">1448912</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="p">(</span><span class="n">null</span><span class="p">)</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">32</span><span class="o">:</span><span class="mf">50.555</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33915</span><span class="o">:</span><span class="mi">1448912</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="p">(</span><span class="n">null</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 场景 3</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">33</span><span class="o">:</span><span class="mf">07.075</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33984</span><span class="o">:</span><span class="mi">1449418</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="n">leichunfeng</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">33</span><span class="o">:</span><span class="mf">07.075</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33984</span><span class="o">:</span><span class="mi">1449418</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="p">(</span><span class="n">null</span><span class="p">)</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">33</span><span class="o">:</span><span class="mf">07.094</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33984</span><span class="o">:</span><span class="mi">1449418</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="p">(</span><span class="n">null</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>跟你预想的结果有出入吗？Any way ，我们一起来分析下为什么会得到这样的结果。</p>

<p><strong>分析</strong>：3 种场景下，我们都通过 <code>[NSString stringWithFormat:@"leichunfeng"]</code> 创建了一个 autoreleased 对象，这是我们实验的前提。并且，为了能够在 <code>viewWillAppear</code> 和 <code>viewDidAppear</code> 中继续访问这个对象，我们使用了一个全局的 <code>__weak</code> 变量 <code>string_weak_</code> 来指向它。因为 <code>__weak</code> 变量有一个特性就是它不会影响所指向对象的生命周期，这里我们正是利用了这个特性。</p>

<p><strong>场景 1</strong>：当使用 <code>[NSString stringWithFormat:@"leichunfeng"]</code> 创建一个对象时，这个对象的引用计数为 1 ，并且这个对象被系统自动添加到了当前的 autoreleasepool 中。当使用局部变量 <code>string</code> 指向这个对象时，这个对象的引用计数 +1 ，变成了 2 。因为在 ARC 下 <code>NSString *string</code> 本质上就是 <code>__strong NSString *string</code> 。所以在 <code>viewDidLoad</code> 方法返回前，这个对象是一直存在的，且引用计数为 2 。而当 <code>viewDidLoad</code> 方法返回时，局部变量 <code>string</code> 被回收，指向了 <code>nil</code> 。因此，其所指向对象的引用计数 -1 ，变成了 1 。</p>

<p>而在 <code>viewWillAppear</code> 方法中，我们仍然可以打印出这个对象的值，说明这个对象并没有被释放。咦，这不科学吧？我读书少，你表骗我。不是一直都说当函数返回的时候，函数内部产生的对象就会被释放的吗？如果你这样想的话，那我只能说：骚年你太年经了。开个玩笑，我们继续。前面我们提到了，这个对象是一个 autoreleased 对象，autoreleased 对象是被添加到了当前最近的 autoreleasepool 中的，只有当这个 autoreleasepool 自身 drain 的时候，autoreleasepool 中的 autoreleased 对象才会被 release 。</p>

<p>另外，我们注意到当在 <code>viewDidAppear</code> 中再打印这个对象的时候，对象的值变成了 <code>nil</code> ，说明此时对象已经被释放了。因此，我们可以大胆地猜测一下，这个对象一定是在 <code>viewWillAppear</code> 和 <code>viewDidAppear</code> 方法之间的某个时候被释放了，并且是由于它所在的 autoreleasepool 被 drain 的时候释放的。</p>

<p>你说什么就是什么咯？有本事你就证明给我看你妈是你妈。额，这个我真证明不了，不过上面的猜测我还是可以证明的，不信，你看！</p>

<p>在开始前，我先简单地说明一下原理，我们可以通过使用 <code>lldb</code> 的 <code>watchpoint</code> 命令来设置观察点，观察全局变量 <code>string_weak_</code> 的值的变化，<code>string_weak_</code> 变量保存的就是我们创建的 autoreleased 对象的地址。在这里，我们再次利用了 <code>__weak</code> 变量的另外一个特性，就是当它所指向的对象被释放时，<code>__weak</code> 变量的值会被置为 <code>nil</code> 。了解了基本原理后，我们开始验证上面的猜测。</p>

<p>我们先在第 35 行打一个断点，当程序运行到这个断点时，我们通过 <code>lldb</code> 命令 <code>watchpoint set v string_weak_</code> 设置观察点，观察 <code>string_weak_</code> 变量的值的变化。如下图所示，我们将在 console 中看到类似的输出，说明我们已经成功地设置了一个观察点：</p>

<p><img src="http://blog.leichunfeng.com/images/watchpoint1.jpg" title="设置观察点" alt="设置观察点" /></p>

<p>设置好观察点后，点击 <code>Continue program execution</code> 按钮，继续运行程序，我们将看到如下图所示的界面：</p>

<p><img src="http://blog.leichunfeng.com/images/watchpoint2.jpg" title="设置观察点" alt="设置观察点" /></p>

<p>我们先看 console 中的输出，注意到 <code>string_weak_</code> 变量的值由 <code>0x00007f9b886567d0</code> 变成了 <code>0x0000000000000000</code> ，也就是 <code>nil</code> 。说明此时它所指向的对象被释放了。另外，我们也可以注意到一个细节，那就是 console 中打印了两次对象的值，说明此时 <code>viewWillAppear</code> 也已经被调用了，而 <code>viewDidAppear</code> 还没有被调用。</p>

<p>接着，我们来看看左侧的线程堆栈。我们看到了一个非常敏感的方法调用 <code>-[NSAutoreleasePool release]</code> ，这个方法最终通过调用 <code>AutoreleasePoolPage::pop(void *)</code> 函数来负责对 autoreleasepool 中的 autoreleased 对象执行 release 操作。结合前面的分析，我们知道在 <code>viewDidLoad</code> 中创建的 autoreleased 对象在方法返回后引用计数为 1 ，所以经过这里的 release 操作后，这个对象的引用计数 -1 ，变成了 0 ，该 autoreleased 对象最终被释放，猜测得证。</p>

<p>另外，值得一提的是，我们在代码中并没有手动添加 autoreleasepool ，那这个 autoreleasepool 究竟是哪里来的呢？看完后面的章节你就明白了。</p>

<p><strong>场景 2</strong>：同理，当通过 <code>[NSString stringWithFormat:@"leichunfeng"]</code> 创建一个对象时，这个对象的引用计数为 1 。而当使用局部变量 <code>string</code> 指向这个对象时，这个对象的引用计数 +1 ，变成了 2 。而出了当前作用域时，局部变量 <code>string</code> 变成了 <code>nil</code> ，所以其所指向对象的引用计数变成 1 。另外，我们知道当出了 <code>@autoreleasepool {}</code> 的作用域时，当前 autoreleasepool 被 drain ，其中的 autoreleased 对象被 release 。所以这个对象的引用计数变成了 0 ，对象最终被释放。</p>

<p><strong>场景 3</strong>：同理，当出了 <code>@autoreleasepool {}</code> 的作用域时，其中的 autoreleased 对象被 release ，对象的引用计数变成 1 。当出了局部变量 <code>string</code> 的作用域，即 <code>viewDidLoad</code> 方法返回时，<code>string</code> 指向了 <code>nil</code> ，其所指向对象的引用计数变成 0 ，对象最终被释放。</p>

<p>理解在这 3 种场景下，autoreleased 对象什么时候释放对我们理解 Objective-C 的内存管理机制非常有帮助。其中，场景 1 出现得最多，就是不需要我们手动添加 <code>@autoreleasepool {}</code> 的情况，直接使用系统维护的 autoreleasepool ；场景 2 就是需要我们手动添加 <code>@autoreleasepool {}</code> 的情况，手动干预 autoreleased 对象的释放时机；场景 3 是为了区别场景 2 而引入的，在这种场景下并不能达到出了 <code>@autoreleasepool {}</code> 的作用域时 autoreleased 对象被释放的目的。</p>

<p><strong>PS</strong>：请读者参考场景 1 的分析过程，使用 <code>lldb</code> 命令 <code>watchpoint</code> 自行验证下在场景 2 和场景 3 下 autoreleased 对象的释放时机，you should give it a try yourself 。</p>

<h2>AutoreleasePoolPage</h2>

<p>细心的读者应该已经有所察觉，我们在上面已经提到了 <code>-[NSAutoreleasePool release]</code> 方法最终是通过调用 <code>AutoreleasePoolPage::pop(void *)</code> 函数来负责对 autoreleasepool 中的 autoreleased 对象执行 release 操作的。</p>

<p>那这里的 AutoreleasePoolPage 是什么东西呢？其实，autoreleasepool 是没有单独的内存结构的，它是通过以 AutoreleasePoolPage 为结点的<strong>双向链表</strong>来实现的。我们打开 runtime 的源码工程，在 <code>NSObject.mm</code> 文件的第 438-932 行可以找到 autoreleasepool 的实现源码。通过阅读源码，我们可以知道：</p>

<ul>
<li>每一个线程的 autoreleasepool 其实就是一个指针的堆栈；</li>
<li>每一个指针代表一个需要 release 的对象或者 POOL_SENTINEL（哨兵对象，代表一个 autoreleasepool 的边界）；</li>
<li>一个 pool token 就是这个 pool 所对应的 POOL_SENTINEL 的内存地址。当这个 pool 被 pop 的时候，所有内存地址在 pool token 之后的对象都会被 release ；</li>
<li>这个堆栈被划分成了一个以 page 为结点的双向链表。pages 会在必要的时候动态地增加或删除；</li>
<li>Thread-local storage（线程局部存储）指向 hot page ，即最新添加的 autoreleased 对象所在的那个 page 。</li>
</ul>


<p>一个空的 AutoreleasePoolPage 的内存结构如下图所示：</p>

<p><img src="http://blog.leichunfeng.com/images/AutoreleasePoolPage.png" title="AutoreleasePoolPage" alt="AutoreleasePoolPage" /></p>

<ol>
<li><code>magic</code> 用来校验 AutoreleasePoolPage 的结构是否完整；</li>
<li><code>next</code> 指向最新添加的 autoreleased 对象的下一个位置，初始化时指向 <code>begin()</code> ；</li>
<li><code>thread</code> 指向当前线程；</li>
<li><code>parent</code> 指向父结点，第一个结点的 parent 值为 <code>nil</code> ；</li>
<li><code>child</code> 指向子结点，最后一个结点的 child 值为 <code>nil</code> ；</li>
<li><code>depth</code> 代表深度，从 0 开始，往后递增 1；</li>
<li><code>hiwat</code> 代表 high water mark 。</li>
</ol>


<p>另外，当 <code>next == begin()</code> 时，表示 AutoreleasePoolPage 为空；当 <code>next == end()</code> 时，表示 AutoreleasePoolPage 已满。</p>

<h3>Autorelease Pool Blocks</h3>

<p>我们使用 <code>clang -rewrite-objc</code> 命令将下面的 Objective-C 代码重写成 C++ 代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>将会得到以下输出结果（只保留了相关代码）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kr">__declspec</span><span class="p">(</span><span class="n">dllimport</span><span class="p">)</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">objc_autoreleasePoolPush</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kr">__declspec</span><span class="p">(</span><span class="n">dllimport</span><span class="p">)</span> <span class="kt">void</span> <span class="n">objc_autoreleasePoolPop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">__AtAutoreleasePool</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">__AtAutoreleasePool</span><span class="p">()</span> <span class="p">{</span><span class="n">atautoreleasepoolobj</span> <span class="o">=</span> <span class="n">objc_autoreleasePoolPush</span><span class="p">();}</span>
</span><span class='line'>  <span class="o">~</span><span class="n">__AtAutoreleasePool</span><span class="p">()</span> <span class="p">{</span><span class="n">objc_autoreleasePoolPop</span><span class="p">(</span><span class="n">atautoreleasepoolobj</span><span class="p">);}</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span> <span class="n">atautoreleasepoolobj</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* @autoreleasepool */</span> <span class="p">{</span> <span class="n">__AtAutoreleasePool</span> <span class="n">__autoreleasepool</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>不得不说，苹果对 <code>@autoreleasepool {}</code> 的实现真的是非常巧妙，真正可以称得上是代码的艺术。苹果通过声明一个 <code>__AtAutoreleasePool</code> 类型的局部变量 <code>__autoreleasepool</code> 来实现 <code>@autoreleasepool {}</code> 。当声明 <code>__autoreleasepool</code> 变量时，构造函数 <code>__AtAutoreleasePool()</code> 被调用，即执行 <code>atautoreleasepoolobj = objc_autoreleasePoolPush();</code> ；当出了当前作用域时，析构函数 <code>~__AtAutoreleasePool()</code> 被调用，即执行 <code>objc_autoreleasePoolPop(atautoreleasepoolobj);</code> 。也就是说 <code>@autoreleasepool {}</code> 的实现代码可以进一步简化如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cm">/* @autoreleasepool */</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">void</span> <span class="o">*</span><span class="n">atautoreleasepoolobj</span> <span class="o">=</span> <span class="n">objc_autoreleasePoolPush</span><span class="p">();</span>
</span><span class='line'>    <span class="c1">// 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 autoreleasepool 中</span>
</span><span class='line'>    <span class="n">objc_autoreleasePoolPop</span><span class="p">(</span><span class="n">atautoreleasepoolobj</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，单个 autoreleasepool 的运行过程可以简单地理解为 <code>objc_autoreleasePoolPush()</code>、<code>[对象 autorelease]</code> 和 <code>objc_autoreleasePoolPop(void *)</code> 三个过程。</p>

<h3>push 操作</h3>

<p>上面提到的 <code>objc_autoreleasePoolPush()</code> 函数本质上就是调用的 AutoreleasePoolPage 的 push 函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="o">*</span>
</span><span class='line'><span class="nf">objc_autoreleasePoolPush</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">UseGC</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">AutoreleasePoolPage</span><span class="o">::</span><span class="n">push</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，我们接下来看看 AutoreleasePoolPage 的 push 函数的作用和执行过程。一个 push 操作其实就是创建一个新的 autoreleasepool ，对应 AutoreleasePoolPage 的具体实现就是往 AutoreleasePoolPage 中的 <code>next</code> 位置插入一个 POOL_SENTINEL ，并且返回插入的 POOL_SENTINEL 的内存地址。这个地址也就是我们前面提到的 pool token ，在执行 pop 操作的时候作为函数的入参。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">push</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">id</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">autoreleaseFast</span><span class="p">(</span><span class="n">POOL_SENTINEL</span><span class="p">);</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">dest</span> <span class="o">==</span> <span class="n">POOL_SENTINEL</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">dest</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>push 函数通过调用 <code>autoreleaseFast</code> 函数来执行具体的插入操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">id</span> <span class="o">*</span><span class="nf">autoreleaseFast</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">AutoreleasePoolPage</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">hotPage</span><span class="p">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">autoreleaseFullPage</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">autoreleaseNoPage</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>autoreleaseFast</code> 函数在执行一个具体的插入操作时，分别对三种情况进行了不同的处理：</p>

<ol>
<li>当前 page 存在且没有满时，直接将对象添加到当前 page 中，即 <code>next</code> 指向的位置；</li>
<li>当前 page 存在且已满时，创建一个新的 page ，并将对象添加到新创建的 page 中；</li>
<li>当前 page 不存在时，即还没有 page 时，创建第一个 page ，并将对象添加到新创建的 page 中。</li>
</ol>


<p>每调用一次 push 操作就会创建一个新的 autoreleasepool ，即往 AutoreleasePoolPage 中插入一个 POOL_SENTINEL ，并且返回插入的 POOL_SENTINEL 的内存地址。</p>

<h3>autorelease 操作</h3>

<p>通过 <code>NSObject.mm</code> 源文件，我们可以找到 <code>-autorelease</code> 方法的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">autorelease</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">((</span><span class="kt">id</span><span class="p">)</span><span class="nb">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rootAutorelease</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过查看 <code>((id)self)-&gt;rootAutorelease()</code> 的方法调用，我们发现最终调用的就是 AutoreleasePoolPage 的 <code>autorelease</code> 函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">__attribute__</span><span class="p">((</span><span class="n">noinline</span><span class="p">,</span><span class="n">used</span><span class="p">))</span>
</span><span class='line'><span class="kt">id</span>
</span><span class='line'><span class="n">objc_object</span><span class="o">::</span><span class="n">rootAutorelease2</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">isTaggedPointer</span><span class="p">());</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">AutoreleasePoolPage</span><span class="o">::</span><span class="n">autorelease</span><span class="p">((</span><span class="kt">id</span><span class="p">)</span><span class="n">this</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>AutoreleasePoolPage 的 <code>autorelease</code> 函数的实现对我们来说就比较容量理解了，它跟 push 操作的实现非常相似。只不过 push 操作插入的是一个 POOL_SENTINEL ，而 autorelease 操作插入的是一个具体的 autoreleased 对象。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">id</span> <span class="nf">autorelease</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">isTaggedPointer</span><span class="p">());</span>
</span><span class='line'>    <span class="kt">id</span> <span class="o">*</span><span class="n">dest</span> <span class="n">__unused</span> <span class="o">=</span> <span class="n">autoreleaseFast</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">dest</span>  <span class="o">||</span>  <span class="o">*</span><span class="n">dest</span> <span class="o">==</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>pop 操作</h3>

<p>同理，前面提到的 <code>objc_autoreleasePoolPop(void *)</code> 函数本质上也是调用的 AutoreleasePoolPage 的 <code>pop</code> 函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">objc_autoreleasePoolPop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">UseGC</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// fixme rdar://9167170</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctxt</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">AutoreleasePoolPage</span><span class="o">::</span><span class="n">pop</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>pop 函数的入参就是 push 函数的返回值，也就是 POOL_SENTINEL 的内存地址，即 pool token 。当执行 pop 操作时，内存地址在 pool token 之后的所有 autoreleased 对象都会被 release 。直到 pool token 所在 page 的 <code>next</code> 指向 pool token 为止。</p>

<p>下面是某个线程的 autoreleasepool 堆栈的内存结构图，在这个 autoreleasepool 堆栈中总共有两个 POOL_SENTINEL ，即有两个 autoreleasepool 。该堆栈由三个 AutoreleasePoolPage 结点组成，第一个 AutoreleasePoolPage 结点为 <code>coldPage()</code> ，最后一个 AutoreleasePoolPage 结点为 <code>hotPage()</code> 。其中，前两个结点已经满了，最后一个结点中保存了最新添加的 autoreleased 对象 <code>objr3</code> 的内存地址。</p>

<p><img src="http://blog.leichunfeng.com/images/AutoreleasePoolPage1.png" title="AutoreleasePoolPage1" alt="AutoreleasePoolPage1" /></p>

<p>此时，如果执行 <code>pop(token1)</code> 操作，那么该 autoreleasepool 堆栈的内存结构将会变成如下图所示：</p>

<p><img src="http://blog.leichunfeng.com/images/AutoreleasePoolPage2.png" title="AutoreleasePoolPage2" alt="AutoreleasePoolPage2" /></p>

<h2>NSThread、NSRunLoop 和 NSAutoreleasePool</h2>

<p>根据苹果官方文档中对 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/doc/constant_group/Run_Loop_Modes">NSRunLoop</a> 的描述，我们可以知道每一个线程，包括主线程，都会拥有一个专属的 NSRunLoop 对象，并且会在有需要的时候自动创建。</p>

<blockquote><p>Each NSThread object, including the application’s main thread, has an NSRunLoop object automatically created for it as needed.</p></blockquote>

<p>同样的，根据苹果官方文档中对 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html#//apple_ref/doc/uid/TP40003623">NSAutoreleasePool</a> 的描述，我们可知，在主线程的 NSRunLoop 对象（在系统级别的其他线程中应该也是如此，比如通过 dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) 获取到的线程）的每个 event loop 开始前，系统会自动创建一个 autoreleasepool ，并在 event loop 结束时 drain 。我们上面提到的场景 1 中创建的 autoreleased 对象就是被系统添加到了这个自动创建的 autoreleasepool 中，并在这个 autoreleasepool 被 drain 时得到释放。</p>

<blockquote><p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</p></blockquote>

<p>另外，NSAutoreleasePool 中还提到，每一个线程都会维护自己的 autoreleasepool 堆栈。换句话说 autoreleasepool 是与线程紧密相关的，每一个 autoreleasepool 只对应一个线程。</p>

<blockquote><p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.</p></blockquote>

<p>弄清楚 NSThread、NSRunLoop 和 NSAutoreleasePool 三者之间的关系可以帮助我们从整体上了解 Objective-C 的内存管理机制，清楚系统在背后到底为我们做了些什么，理解整个运行机制等。</p>

<h2>总结</h2>

<p>看到这里，相信你应该对 Objective-C 的内存管理机制有了更进一步的认识。通常情况下，我们是不需要手动添加 autoreleasepool 的，使用线程自动维护的 autoreleasepool 就好了。根据苹果官方文档中对 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI">Using Autorelease Pool Blocks</a> 的描述，我们知道在下面三种情况下是需要我们手动添加 autoreleasepool 的：</p>

<ol>
<li>如果你编写的程序不是基于 UI 框架的，比如说命令行工具；</li>
<li>如果你编写的循环中创建了大量的临时对象；</li>
<li>如果你创建了一个辅助线程。</li>
</ol>


<p>最后，希望本文能对你有所帮助，have fun ！</p>

<h2>参考链接</h2>

<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">http://blog.sunnyxx.com/2014/10/15/behind-autorelease/</a>
<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">http://clang.llvm.org/docs/AutomaticReferenceCounting.html</a>
<a href="http://www.yifeiyang.net/development-of-the-iphone-simply-3/">http://www.yifeiyang.net/development-of-the-iphone-simply-3/</a></p>

<p><strong>版权声明</strong>：我已将本文在微信公众平台的发表权「独家代理」给 iOS 开发（iOSDevTips）微信公众号。扫下方二维码即可关注「iOS 开发」：</p>

<p><img src="http://blog.devtang.com/images/weixin-qr.jpg" alt="iOS 开发二维码" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Category 的实现原理]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/05/18/objective-c-category-implementation-principle/"/>
    <updated>2015-05-18T00:20:57+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/05/18/objective-c-category-implementation-principle</id>
    <content type="html"><![CDATA[<p>对设计模式有一定了解的朋友应该听说过装饰模式，Objective-C 中的 Category 就是对装饰模式的一种具体实现。它的主要作用是在不改变原有类的前提下，动态地给这个类添加一些方法。在 Objective-C 中的具体体现为：实例（类）方法、属性和协议。是的，在 Objective-C 中可以用 Category 来实现协议。本文将结合 <a href="http://opensource.apple.com/tarballs/objc4/">runtime</a>（我下载的是当前的最新版本 <code>objc4-646.tar.gz</code>) 的源码来探究它实现的原理。</p>

<h2>使用场景</h2>

<p>根据苹果官方文档对 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1">Category</a> 的描述，它的使用场景主要有三个：</p>

<ol>
<li>给现有的类添加方法；</li>
<li>将一个类的实现拆分成多个独立的源文件；</li>
<li>声明私有的方法。</li>
</ol>


<p>其中，第 <code>1</code> 个是最典型的使用场景，应用最广泛。</p>

<p><strong>注</strong>：Category 有一个非常容易误用的场景，那就是用 Category 来覆写父类或主类的方法。虽然目前 Objective-C 是允许这么做的，但是这种使用场景是<strong>非常</strong>不推荐的。<a href="http://stackoverflow.com/questions/5272451/overriding-methods-using-categories-in-objective-c">使用 Category 来覆写方法</a>有很多缺点，比如不能覆写 Category 中的方法、无法调用主类中的原始实现等，且很容易造成无法预估的行为。</p>

<h2>实现原理</h2>

<p>我们知道，无论我们有没有主动引入 Category 的头文件，Category 中的方法都会被添加进主类中。我们可以通过 <code>- performSelector:</code> 等方式对 Category 中的相应方法进行调用，之所以需要在调用的地方引入 Category 的头文件，只是为了“照顾”编译器同学的感受。</p>

<p>下面，我们将结合 runtime 的源码探究下 Category 的实现原理。打开 runtime 源码工程，在文件 <code>objc-runtime-new.mm</code> 中找到以下函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">_read_images</span><span class="p">(</span><span class="n">header_info</span> <span class="o">**</span><span class="n">hList</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hCount</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>        <span class="n">_free_internal</span><span class="p">(</span><span class="n">resolvedFutureClasses</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Discover categories. </span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">category_t</span> <span class="o">**</span><span class="n">catlist</span> <span class="o">=</span>
</span><span class='line'>            <span class="n">_getObjc2CategoryList</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="kt">category_t</span> <span class="o">*</span><span class="n">cat</span> <span class="o">=</span> <span class="n">catlist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>            <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">remapClass</span><span class="p">(</span><span class="n">cat</span><span class="o">-&gt;</span><span class="n">cls</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// Category&#39;s target class is missing (probably weak-linked).</span>
</span><span class='line'>                <span class="c1">// Disavow any knowledge of this category.</span>
</span><span class='line'>                <span class="n">catlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">PrintConnecting</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span>
</span><span class='line'>                                 <span class="s">&quot;missing weak-linked target class&quot;</span><span class="p">,</span>
</span><span class='line'>                                 <span class="n">cat</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// Process this category. </span>
</span><span class='line'>            <span class="c1">// First, register the category with its target class. </span>
</span><span class='line'>            <span class="c1">// Then, rebuild the class&#39;s method lists (etc) if </span>
</span><span class='line'>            <span class="c1">// the class is realized. </span>
</span><span class='line'>            <span class="kt">BOOL</span> <span class="n">classExists</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">cat</span><span class="o">-&gt;</span><span class="n">instanceMethods</span> <span class="o">||</span>  <span class="n">cat</span><span class="o">-&gt;</span><span class="n">protocols</span>
</span><span class='line'>                <span class="o">||</span>  <span class="n">cat</span><span class="o">-&gt;</span><span class="n">instanceProperties</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">addUnattachedCategoryForClass</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isRealized</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">remethodizeClass</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
</span><span class='line'>                    <span class="n">classExists</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">PrintConnecting</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&quot;CLASS: found category -%s(%s) %s&quot;</span><span class="p">,</span>
</span><span class='line'>                                 <span class="n">cls</span><span class="o">-&gt;</span><span class="n">nameForLogging</span><span class="p">(),</span> <span class="n">cat</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
</span><span class='line'>                                 <span class="n">classExists</span> <span class="o">?</span> <span class="s">&quot;on existing class&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">cat</span><span class="o">-&gt;</span><span class="n">classMethods</span>  <span class="o">||</span>  <span class="n">cat</span><span class="o">-&gt;</span><span class="n">protocols</span>
</span><span class='line'>                <span class="cm">/* ||  cat-&gt;classProperties */</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">addUnattachedCategoryForClass</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">ISA</span><span class="p">(),</span> <span class="n">hi</span><span class="p">);</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">ISA</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isRealized</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">remethodizeClass</span><span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">ISA</span><span class="p">());</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">PrintConnecting</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&quot;CLASS: found category +%s(%s)&quot;</span><span class="p">,</span>
</span><span class='line'>                                 <span class="n">cls</span><span class="o">-&gt;</span><span class="n">nameForLogging</span><span class="p">(),</span> <span class="n">cat</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Category discovery MUST BE LAST to avoid potential races </span>
</span><span class='line'>    <span class="c1">// when other threads call the new category code before </span>
</span><span class='line'>    <span class="c1">// this thread finishes its fixups.</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// +load handled by prepare_load_methods()</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从第 27-58 行的关键代码，我们可以知道在这个函数中对 Category 做了如下处理：</p>

<ol>
<li>将 Category 和它的主类（或元类）注册到哈希表中；</li>
<li>如果主类（或元类）已实现，那么重建它的方法列表。</li>
</ol>


<p>在这里分了两种情况进行处理：Category 中的实例方法和属性被整合到主类中；而类方法则被整合到元类中（关于对象、类和元类的更多细节，可以参考我前面的博文<a href="http://blog.leichunfeng.com/blog/2015/04/25/objective-c-object-model/">《Objective-C 对象模型》</a>）。另外，对协议的处理比较特殊，Category 中的协议被同时整合到了主类和元类中。</p>

<p>我们注意到，不管是哪种情况，最终都是通过调用 <code>static void remethodizeClass(Class cls)</code> 函数来重新整理类的数据的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">remethodizeClass</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>                         <span class="n">cls</span><span class="o">-&gt;</span><span class="n">nameForLogging</span><span class="p">(),</span> <span class="n">isMeta</span> <span class="o">?</span> <span class="s">&quot;(meta)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Update methods, properties, protocols</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">attachCategoryMethods</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">cats</span><span class="p">,</span> <span class="nb">YES</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">newproperties</span> <span class="o">=</span> <span class="n">buildPropertyList</span><span class="p">(</span><span class="nb">nil</span><span class="p">,</span> <span class="n">cats</span><span class="p">,</span> <span class="n">isMeta</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">newproperties</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">newproperties</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">properties</span><span class="p">;</span>
</span><span class='line'>            <span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">properties</span> <span class="o">=</span> <span class="n">newproperties</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">newprotos</span> <span class="o">=</span> <span class="n">buildProtocolList</span><span class="p">(</span><span class="n">cats</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">protocols</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">protocols</span>  <span class="o">&amp;&amp;</span>  <span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">protocols</span> <span class="o">!=</span> <span class="n">newprotos</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">_free_internal</span><span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">protocols</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">protocols</span> <span class="o">=</span> <span class="n">newprotos</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">_free_internal</span><span class="p">(</span><span class="n">cats</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数的主要作用是将 Category 中的方法、属性和协议整合到类（主类或元类）中，更新类的数据字段 <code>data()</code> 中 <code>method_lists（或 method_list）</code>、<code>properties</code> 和 <code>protocols</code> 的值。进一步，我们通过 <code>attachCategoryMethods</code> 函数的源码可以找到真正处理 Category 方法的 <code>attachMethodLists</code> 函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span>
</span><span class='line'><span class="nf">attachMethodLists</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">method_list_t</span> <span class="o">**</span><span class="n">addedLists</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addedCount</span><span class="p">,</span>
</span><span class='line'>                  <span class="kt">bool</span> <span class="n">baseMethods</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">methodsFromBundle</span><span class="p">,</span>
</span><span class='line'>                  <span class="kt">bool</span> <span class="n">flushCaches</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>        <span class="n">newLists</span><span class="p">[</span><span class="n">newCount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mlist</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Copy old methods to the method list array</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oldCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">newLists</span><span class="p">[</span><span class="n">newCount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldLists</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">oldLists</span>  <span class="o">&amp;&amp;</span>  <span class="n">oldLists</span> <span class="o">!=</span> <span class="n">oldBuf</span><span class="p">)</span> <span class="n">free</span><span class="p">(</span><span class="n">oldLists</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// nil-terminate</span>
</span><span class='line'>    <span class="n">newLists</span><span class="p">[</span><span class="n">newCount</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">newCount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">assert</span><span class="p">(</span><span class="n">newLists</span> <span class="o">!=</span> <span class="n">newBuf</span><span class="p">);</span>
</span><span class='line'>        <span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">method_lists</span> <span class="o">=</span> <span class="n">newLists</span><span class="p">;</span>
</span><span class='line'>        <span class="n">cls</span><span class="o">-&gt;</span><span class="n">setInfo</span><span class="p">(</span><span class="n">RW_METHOD_ARRAY</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">assert</span><span class="p">(</span><span class="n">newLists</span> <span class="o">==</span> <span class="n">newBuf</span><span class="p">);</span>
</span><span class='line'>        <span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">method_list</span> <span class="o">=</span> <span class="n">newLists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RW_METHOD_ARRAY</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数的代码量看上去比较多，但是我们并不难理解它的目的。它的主要作用就是将类中的旧有方法和 Category 中新添加的方法整合成一个新的方法列表，并赋值给 <code>method_lists</code> 或 <code>method_list</code> 。通过探究这个处理过程，我们也印证了一个结论，那就是主类中的方法和 Category 中的方法在 runtime 看来并没有区别，它们是被同等对待的，都保存在主类的方法列表中。</p>

<p>不过，类的方法列表字段有一点特殊，它的结构是联合体，<code>method_lists</code> 和 <code>method_list</code> 共用同一块内存地址。当 <code>newCount</code> 的个数大于 1 时，使用 <code>method_lists</code> 来保存 <code>newLists</code> ，并将方法列表的<strong>标志位</strong>置为 <code>RW_METHOD_ARRAY</code> ，此时类的方法列表字段是 <code>method_list_t</code> 类型的指针数组；否则，使用 <code>method_list</code> 来保存 <code>newLists</code> ，并将方法列表的<strong>标志位</strong>置空，此时类的方法列表字段是 <code>method_list_t</code> 类型的指针。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// class&#39;s method list is an array of method lists</span>
</span><span class='line'><span class="cp">#define RW_METHOD_ARRAY       (1&lt;&lt;20)</span>
</span><span class='line'>
</span><span class='line'><span class="k">union</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">method_list_t</span> <span class="o">**</span><span class="n">method_lists</span><span class="p">;</span>  <span class="c1">// RW_METHOD_ARRAY == 1</span>
</span><span class='line'>    <span class="kt">method_list_t</span> <span class="o">*</span><span class="n">method_list</span><span class="p">;</span>    <span class="c1">// RW_METHOD_ARRAY == 0</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>看过我上一篇博文<a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/">《Objective-C +load vs +initialize》</a>的朋友可能已经有所察觉了。我们注意到 runtime 对 Category 中方法的处理过程并没有对 +load 方法进行什么特殊地处理。因此，严格意义上讲 Category 中的 +load 方法跟普通方法一样也会对主类中的 +load 方法造成覆盖，只不过 runtime 在自动调用主类和 Category 中的 +load 方法时是直接使用各自方法的指针进行调用的。所以才会使我们觉得主类和 Category 中的 +load 方法好像互不影响一样。因此，当我们手动给主类发送 +load 消息时，调用的一直会是分类中的 +load 方法，you should give it a try yourself 。</p>

<h2>总结</h2>

<p>Category 是 Objective-C 中非常强大的技术之一，使用得当的话可以给我们的开发带来极大的便利。很多著名的开源库或多或少都会通过给系统类添加 Category 的方式提供强大功能，比如 <a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a> 、<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> 、 <a href="https://github.com/rs/SDWebImage">SDWebImage</a> 等。但是凡事有利必有弊，正因为 Category 非常强大，所以一旦误用就很可能会造成非常严重的后果。比如覆写系统类的方法，这是 iOS 开发新手经常会犯的一个错误，不管在任何情况下，切记一定不要这么做，No zuo no die 。</p>

<h2>参考链接</h2>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1">https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1</a>
<a href="http://stackoverflow.com/questions/5272451/overriding-methods-using-categories-in-objective-c">http://stackoverflow.com/questions/5272451/overriding-methods-using-categories-in-objective-c</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C +load vs +initialize]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/"/>
    <updated>2015-05-02T17:06:15+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize</id>
    <content type="html"><![CDATA[<p>在上一篇博文<a href="http://blog.leichunfeng.com/blog/2015/04/25/objective-c-object-model/">《Objective-C 对象模型》</a>中，我们知道了 Objective-C 中绝大部分的类都继承自 NSObject 类。而在 NSObject 类中有两个非常特殊的类方法 +load 和 +initialize ，用于类的初始化。这两个看似非常简单的类方法在许多方面会让人感到困惑，比如：</p>

<ol>
<li>子类、父类、分类中的相应方法什么时候会被调用？</li>
<li>需不需要在子类的实现中显式地调用父类的实现？</li>
<li>每个方法到底会被调用多少次？</li>
</ol>


<p>下面，我们将结合 <a href="http://opensource.apple.com/tarballs/objc4/">runtime</a>（我下载的是当前的最新版本 <code>objc4-646.tar.gz</code>) 的源码，一起来揭开它们的神秘面纱。</p>

<h2>+load</h2>

<p>+load 方法是当类或分类被添加到 Objective-C runtime 时被调用的，实现这个方法可以让我们在类加载的时候执行一些类相关的行为。子类的 +load 方法会在它的所有父类的 +load 方法之后执行，而分类的 +load 方法会在它的主类的 +load 方法之后执行。但是不同的类之间的 +load 方法的调用顺序是不确定的。</p>

<p>打开 runtime 工程，我们接下来看看与 +load 方法相关的几个关键函数。首先是文件 <code>objc-runtime-new.mm</code> 中的 <code>void prepare_load_methods(header_info *hi)</code> 函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">prepare_load_methods</span><span class="p">(</span><span class="n">header_info</span> <span class="o">*</span><span class="n">hi</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">rwlock_assert_writing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">runtimeLock</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">classref_t</span> <span class="o">*</span><span class="n">classlist</span> <span class="o">=</span>
</span><span class='line'>        <span class="n">_getObjc2NonlazyClassList</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">schedule_class_load</span><span class="p">(</span><span class="n">remapClass</span><span class="p">(</span><span class="n">classlist</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">category_t</span> <span class="o">**</span><span class="n">categorylist</span> <span class="o">=</span> <span class="n">_getObjc2NonlazyCategoryList</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">category_t</span> <span class="o">*</span><span class="n">cat</span> <span class="o">=</span> <span class="n">categorylist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">remapClass</span><span class="p">(</span><span class="n">cat</span><span class="o">-&gt;</span><span class="n">cls</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>  <span class="c1">// category for ignored weak-linked class</span>
</span><span class='line'>        <span class="n">realizeClass</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
</span><span class='line'>        <span class="n">assert</span><span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">ISA</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isRealized</span><span class="p">());</span>
</span><span class='line'>        <span class="n">add_category_to_loadable_list</span><span class="p">(</span><span class="n">cat</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>顾名思义，这个函数的作用就是提前准备好满足 +load 方法调用条件的类和分类，以供接下来的调用。其中，在处理类时，调用了同文件中的另外一个函数 <code>static void schedule_class_load(Class cls)</code> 来执行具体的操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">schedule_class_load</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isRealized</span><span class="p">());</span>  <span class="c1">// _read_images should realize</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RW_LOADED</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Ensure superclass-first ordering</span>
</span><span class='line'>    <span class="n">schedule_class_load</span><span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">superclass</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">add_class_to_loadable_list</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cls</span><span class="o">-&gt;</span><span class="n">setInfo</span><span class="p">(</span><span class="n">RW_LOADED</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中，函数第 9 行代码对入参的父类进行了递归调用，以确保父类优先的顺序。<code>void prepare_load_methods(header_info *hi)</code> 函数执行完后，当前所有满足 +load 方法调用条件的类和分类就被分别存放在全局变量 <code>loadable_classes</code> 和 <code>loadable_categories</code> 中了。</p>

<p>准备好类和分类后，接下来就是对它们的 +load 方法进行调用了。打开文件 <code>objc-loadmethod.m</code> ，找到其中的 <code>void call_load_methods(void)</code> 函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">call_load_methods</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">BOOL</span> <span class="n">loading</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">more_categories</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">recursive_mutex_assert_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loadMethodLock</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Re-entrant calls do nothing; the outermost call will finish the job.</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">loading</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="n">loading</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">objc_autoreleasePoolPush</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 1. Repeatedly call class +loads until there aren&#39;t any more</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span><span class="n">loadable_classes_used</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">call_class_loads</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 2. Call category +loads ONCE</span>
</span><span class='line'>        <span class="n">more_categories</span> <span class="o">=</span> <span class="n">call_category_loads</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 3. Run more +loads if there are classes OR more untried categories</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">loadable_classes_used</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="o">||</span>  <span class="n">more_categories</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">objc_autoreleasePoolPop</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">loading</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样的，这个函数的作用就是调用上一步准备好的类和分类中的 +load 方法，并且确保类优先于分类的顺序。我们继续查看在这个函数中调用的另外两个关键函数 <code>static void call_class_loads(void)</code> 和 <code>static BOOL call_category_loads(void)</code> 。由于这两个函数的作用大同小异，下面就以篇幅较小的 <code>static void call_class_loads(void)</code> 函数为例进行探讨。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">call_class_loads</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Detach current loadable list.</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">loadable_class</span> <span class="o">*</span><span class="n">classes</span> <span class="o">=</span> <span class="n">loadable_classes</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">used</span> <span class="o">=</span> <span class="n">loadable_classes_used</span><span class="p">;</span>
</span><span class='line'>    <span class="n">loadable_classes</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="n">loadable_classes_allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">loadable_classes_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Call all +loads for the detached list.</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">classes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cls</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">load_method_t</span> <span class="n">load_method</span> <span class="o">=</span> <span class="p">(</span><span class="kt">load_method_t</span><span class="p">)</span><span class="n">classes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">method</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">PrintLoading</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&quot;LOAD: +[%s load]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">nameForLogging</span><span class="p">());</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="p">(</span><span class="o">*</span><span class="n">load_method</span><span class="p">)(</span><span class="n">cls</span><span class="p">,</span> <span class="n">SEL_load</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Destroy the detached list.</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">classes</span><span class="p">)</span> <span class="n">_free_internal</span><span class="p">(</span><span class="n">classes</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数的作用就是真正负责调用类的 +load 方法了。它从全局变量 <code>loadable_classes</code> 中取出所有可供调用的类，并进行清零操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">loadable_classes</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="n">loadable_classes_allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">loadable_classes_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中 <code>loadable_classes</code> 指向用于保存类信息的内存的首地址，<code>loadable_classes_allocated</code> 标识已分配的内存空间大小，<code>loadable_classes_used</code> 则标识已使用的内存空间大小。</p>

<p>然后，循环调用所有类的 +load 方法。<strong>注意</strong>，这里是（调用分类的 +load 方法也是如此）直接使用函数内存地址的方式 <code>(*load_method)(cls, SEL_load);</code> 对 +load 方法进行调用的，而不是使用发送消息 <code>objc_msgSend</code> 的方式。</p>

<p>这样的调用方式就使得 +load 方法拥有了一个非常有趣的特性，那就是子类、父类和分类中的 +load 方法的实现是被区别对待的。也就是说如果子类没有实现 +load 方法，那么当它被加载时 runtime 是不会去调用父类的 +load 方法的。同理，当一个类和它的分类都实现了 +load 方法时，两个方法都会被调用。因此，我们常常可以利用这个特性做一些“邪恶”的事情，比如说方法混淆（<a href="http://nshipster.com/method-swizzling/">Method Swizzling</a>）。</p>

<h2>+initialize</h2>

<p>+initialize 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。也就是说 +initialize 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize 方法是永远不会被调用的。那这样设计有什么好处呢？好处是显而易见的，那就是节省系统资源，避免浪费。</p>

<p>同样的，我们还是结合 runtime 的源码来加深对 +initialize 方法的理解。打开文件 <code>objc-runtime-new.mm</code> ，找到以下函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">IMP</span> <span class="nf">lookUpImpOrForward</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">sel</span><span class="p">,</span> <span class="kt">id</span> <span class="n">inst</span><span class="p">,</span>
</span><span class='line'>                       <span class="kt">bool</span> <span class="n">initialize</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cache</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">resolver</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>        <span class="n">rwlock_unlock_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">runtimeLock</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">initialize</span>  <span class="o">&amp;&amp;</span>  <span class="o">!</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isInitialized</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">_class_initialize</span> <span class="p">(</span><span class="n">_class_getNonMetaClass</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">inst</span><span class="p">));</span>
</span><span class='line'>        <span class="c1">// If sel == initialize, _class_initialize will send +initialize and </span>
</span><span class='line'>        <span class="c1">// then the messenger will send +initialize again after this </span>
</span><span class='line'>        <span class="c1">// procedure finishes. Of course, if this is not being called </span>
</span><span class='line'>        <span class="c1">// from the messenger then it won&#39;t happen. 2778172</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// The lock is held to make method-lookup + cache-fill atomic </span>
</span><span class='line'>    <span class="c1">// with respect to method addition. Otherwise, a category could </span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当我们给某个类发送消息时，runtime 会调用这个函数在类中查找相应方法的实现或进行消息转发。从第 8-14 的关键代码我们可以看出，当类没有初始化时 runtime 会调用 <code>void _class_initialize(Class cls)</code> 函数对该类进行初始化。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">_class_initialize</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="kt">Class</span> <span class="n">supercls</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">reallyInitialize</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Make sure super is done initializing BEFORE beginning to initialize cls.</span>
</span><span class='line'>    <span class="c1">// See note about deadlock above.</span>
</span><span class='line'>    <span class="n">supercls</span> <span class="o">=</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">superclass</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">supercls</span>  <span class="o">&amp;&amp;</span>  <span class="o">!</span><span class="n">supercls</span><span class="o">-&gt;</span><span class="n">isInitialized</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">_class_initialize</span><span class="p">(</span><span class="n">supercls</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Try to atomically set CLS_INITIALIZING.</span>
</span><span class='line'>    <span class="n">monitor_enter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">classInitLock</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isInitialized</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isInitializing</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">cls</span><span class="o">-&gt;</span><span class="n">setInitializing</span><span class="p">();</span>
</span><span class='line'>        <span class="n">reallyInitialize</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">monitor_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">classInitLock</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">reallyInitialize</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// We successfully set the CLS_INITIALIZING bit. Initialize the class.</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Record that we&#39;re initializing this class so we can message it.</span>
</span><span class='line'>        <span class="n">_setThisThreadIsInitializingClass</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Send the +initialize message.</span>
</span><span class='line'>        <span class="c1">// Note that +initialize is sent to the superclass (again) if </span>
</span><span class='line'>        <span class="c1">// this class doesn&#39;t implement +initialize. 2157218</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">PrintInitializing</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&quot;INITIALIZE: calling +[%s initialize]&quot;</span><span class="p">,</span>
</span><span class='line'>                         <span class="n">cls</span><span class="o">-&gt;</span><span class="n">nameForLogging</span><span class="p">());</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">((</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">Class</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">cls</span><span class="p">,</span> <span class="n">SEL_initialize</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">PrintInitializing</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&quot;INITIALIZE: finished +[%s initialize]&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中，第 7-12 行代码对入参的父类进行了递归调用，以确保父类优先于子类初始化。另外，最关键的是第 36 行代码（暴露了 +initialize 方法的本质），runtime 使用了发送消息 <code>objc_msgSend</code> 的方式对 +initialize 方法进行调用。也就是说 +initialize 方法的调用与普通方法的调用是一样的，走的都是发送消息的流程。换言之，如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 +initialize 方法，那么就会对这个类中的实现造成覆盖。</p>

<p>因此，如果一个子类没有实现 +initialize 方法，那么父类的实现是会被执行多次的。有时候，这可能是你想要的；但如果我们想确保自己的 +initialize 方法只执行一次，避免多次执行可能带来的副作用时，我们可以使用下面的代码来实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">initialize</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nb">self</span> <span class="o">==</span> <span class="p">[</span><span class="n">ClassName</span> <span class="nb">self</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ... do the initialization ...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>通过阅读 runtime 的源码，我们知道了 +load 和 +initialize 方法实现的细节，明白了它们的调用机制和各自的特点。下面我们绘制一张表格，以更加直观的方式来巩固我们对它们的理解：</p>

<p>
    <table border="1" width="100%">
        <tr>
            <th></th>        
            <th>+load</th>        
            <th>+initialize</th>        
        </tr>
        <tr>
            <td>调用时机</td>        
            <td>被添加到 runtime 时</td>        
            <td>收到第一条消息前，可能永远不调用</td>        
        </tr>
        <tr>
            <td>调用顺序</td>        
            <td>父类->子类->分类</td>        
            <td>父类->子类</td>        
        </tr>
        <tr>
            <td>调用次数</td>        
            <td>1次</td>        
            <td>多次</td>        
        </tr>
        <tr>
            <td>是否需要显式调用父类实现</td>        
            <td>否</td>        
            <td>否</td>        
        </tr>
        <tr>
            <td>是否沿用父类的实现</td>        
            <td>否</td>        
            <td>是</td>        
        </tr>
        <tr>
            <td>分类中的实现</td>        
            <td>类和分类都执行</td>        
            <td>覆盖类中的方法，只执行分类的实现</td>        
        </tr>
    </table>
</p>


<h2>参考链接</h2>

<ul>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.html">https://www.mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.html</a></li>
<li><a href="http://blog.iderzheng.com/objective-c-load-vs-initialize/">http://blog.iderzheng.com/objective-c-load-vs-initialize/</a></li>
<li><a href="http://nshipster.com/method-swizzling/">http://nshipster.com/method-swizzling/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C 对象模型]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/04/25/objective-c-object-model/"/>
    <updated>2015-04-25T19:38:02+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/04/25/objective-c-object-model</id>
    <content type="html"><![CDATA[<p>Objective-C 是一门面向对象的程序设计语言，它的对象模型是基于类来建立的。我们可以在苹果开源的 <a href="http://opensource.apple.com/tarballs/objc4/">runtime</a>（我下载的是当前的最新版本 <code>objc4-646.tar.gz</code> ）中发现 Objective-C 对象模型的实现细节。</p>

<h2>对象</h2>

<p>在 Objective-C 中，每一个对象都是某个类的实例，且这个对象的 <code>isa</code>（在 64 位 CPU 下，<code>isa</code> 已经不再是一个简单的指针，在本文中我们暂且把它当作普通指针来理解，后面我会单独写一篇博文来详细介绍 <code>Non-pointer isa</code> ）指针指向它所属的类。</p>

<p>打开刚下载的 runtime 工程，在文件 <code>objc-private.h</code> 的第 127-232 行我们可以找到 Objective-C 中的对象的定义 <code>struct objc_object</code> 。是的，Objective-C 中的对象本质上是结构体对象，其中 <code>isa</code> 是它唯一的私有成员变量。</p>

<p><img src="http://leichunfeng.github.io/images/objc_object.jpg" title="Objective-C 对象的定义" alt="Objective-C 对象的定义"></p>

<p>在同一个文件的第 51-52 行我们可以找到 <code>Class</code> 和 <code>id</code> 类型的定义，它们分别是 <code>struct objc_class</code> 和 <code>struct objc_object</code> 类型的指针。这也是为什么 <code>id</code> 类型可以指向任意对象的原因。其中 <code>struct objc_class</code> 就是 Objective-C 中的类的定义，在下一节将会详细介绍。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">objc_class</span> <span class="o">*</span><span class="kt">Class</span><span class="p">;</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">objc_object</span> <span class="o">*</span><span class="kt">id</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>类</h2>

<p>对象的类不仅描述了对象的数据：对象占用的内存大小、成员变量的类型和布局等，而且也描述了对象的行为：对象能够响应的消息、实现的实例方法等。因此，当我们调用实例方法 <code>[receiver message]</code> 给一个对象发送消息时，这个对象能否响应这个消息就需要通过 <code>isa</code> 找到它所属的类（当然还有 superclass，本文主要内容不是这个，所以不展开）才能知道。</p>

<p>打开文件 <code>objc-runtime-new.h</code> ，在第 687-902 行我们可以找到 Objective-C 中的类的定义 <code>struct objc_class</code> 。同样的，Objective-C 中类也是一个结构体对象，并且继承了 <code>struct objc_object</code> 。</p>

<p><img src="http://leichunfeng.github.io/images/objc_class.jpg" title="Objective-C 类的定义" alt="Objective-C 类的定义"></p>

<p>所以，Objective-C 中的类本质上也是对象，我们称之为类对象。按照我们前面所说的所有的对象都是某个类的实例，那么类对象又是什么类的实例呢？答案就是我们将在下一节介绍的元类。</p>

<p>在 Objective-C 中有一个非常特殊的类 <code>NSObject</code> ，绝大部分的类都继承自它。它是 Objective-C 中的两个根类（rootclass）之一，另外一个是 NSProxy（本文不讨论）。同样的，我们打开文件 <code>NSObject.h</code> ，可以看到 <code>NSObject</code> 类其实就只有一个成员变量 <code>isa</code> ，所有继承自 <code>NSObject</code> 的类也都会有这个成员变量。</p>

<p><img src="http://leichunfeng.github.io/images/nsobject.jpg" title="NSObject 类" alt="NSObject 类"></p>

<h2>元类</h2>

<p>我们上面提到，本质上 Objective-C 中的类也是对象，它也是某个类的实例，这个类我们称之为元类（metaclass）。</p>

<p>因此，我们也可以通过调用类方法，比如 <code>[NSObject new]</code>，给类对象发送消息。同样的，类对象能否响应这个消息也要通过 <code>isa</code> 找到类对象所属的类（元类）才能知道。也就是说，实例方法是保存在类中的，而类方法是保存在元类中的。</p>

<p>那元类也是对象吗？是的话那它又是什么类的实例呢？是的，没错，元类也是对象（元类对象），元类也是某个类的实例，这个类我们称之为根元类（root metaclass）。不过，有一点比较特殊，那就是所有的元类所属的类都是同一个根元类（当然根元类也是元类，所以它所属的类也是根元类，即它本身）。根元类指的就是根类的元类，具体来说就是根类 <code>NSObject</code> 对应的元类。</p>

<p>因此，理论上我们也可以给元类发送消息，但是 Objective-C 倾向于隐藏元类，不想让大家知道元类的存在。元类是为了保持 Objective-C 对象模型在设计上的完整性而引入的，比如用来保存类方法等，它主要是用来给编译器使用的。</p>

<p>说了这么多，大家可能已经有点绕迷糊了，下面我们看一张图，一切自会明了。</p>

<p><img src="http://leichunfeng.github.io/images/object_model.png" title="Objective-C 对象模型" alt="Objective-C 对象模型"></p>

<h2>参考链接</h2>

<ul>
<li><a href="http://www.devtang.com/blog/2013/10/15/objective-c-object-model/">http://www.devtang.com/blog/2013/10/15/objective-c-object-model/</a></li>
<li><a href="http://husbandman.diandian.com/post/2012-08-17/40036035008">http://husbandman.diandian.com/post/2012-08-17/40036035008</a></li>
<li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[结合 Reveal 谈谈 MBProgressHUD 的用法]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/03/16/talking-about-the-usage-of-mbprogresshud-combined-with-reveal/"/>
    <updated>2015-03-16T12:32:51+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/03/16/talking-about-the-usage-of-mbprogresshud-combined-with-reveal</id>
    <content type="html"><![CDATA[<p>我的博客已经好几个月没有更新了，想想还真是有些难过。究其原因主要是工作占用了我绝大部分的时间，包含工作日的晚上和大部分周末。剩余的很小部分空余时间，我都用来开发个人 iOS 应用 GitBucket 了。</p>

<p>GitBucket 是一个 GitHub 的 iOS 客户端，使用 <a href="http://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM</a> 模式和 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">RAC</a> 框架进行开发。目前 GitBucket 的项目代码 <a href="https://github.com/leichunfeng/MVVMReactiveCocoa">MVVMReactiveCocoa</a> 已经在 GitHub 上开源了出来。开发这个应用的主要目的是希望提供一个使用 MVVM 模式和 RAC 框架开发的完整应用，能够对学习 MVVM 模式和 RAC 框架的 iOS 开发者有所帮助。昨天，我已经向 App Store 提交了 GitBucket v1.0 版本，相信很快大家就可以下载使用了。</p>

<p>言归正传，接下来我们结合 <a href="http://revealapp.com/">Reveal</a> 来谈谈 <a href="https://github.com/jdg/MBProgressHUD">MBProgressHUD</a> 的用法。这里主要讨论的是什么情况下导航栏上的按钮可用，什么情况下不可用，及其原因。</p>

<p><strong>注</strong>：本博文的程序代码可以在 <a href="https://github.com/leichunfeng/MBProgressHUD">leichunfeng/MBProgressHUD</a> 上找到，读者可以克隆下来亲自运行下看看效果。</p>

<h2>关于 self.navigationController.view</h2>

<p>相信看过 MBProgressHUD 官方例子 <code>HudDemo</code> 代码的同学应该看到过下述代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">HUD</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MBProgressHUD</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithView</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">navigationController</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>当时，你可能会对 <code>self.navigationController.view</code> 有些疑惑，这是什么玩意？其实，如果我们查看下 <code>UINavigationController.h</code> 文件就会发现，<code>UINavigationController</code> 其实是继承自 <code>UIViewController</code> 的，那么它拥有 <code>view</code> 属性也就不奇怪了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NS_CLASS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">2</span><span class="n">_0</span><span class="p">)</span> <span class="k">@interface</span> <span class="bp">UINavigationController</span> : <span class="bp">UIViewController</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面，我们会结合 Reveal 清楚地看到 <code>self.navigationController.view</code> 到底是什么东西，稍安勿躁。</p>

<h2>显示 MBProgressHUD</h2>

<p>初始化 MBProgressHUD 时需要我们传入一个 <code>UIView</code> 类型的参数 <code>view</code>，而显示 MBProgressHUD 的原理其实就是用 <code>addSubview</code> 方法将 MBProgressHUD 添加为这个 <code>view</code> 的子视图。</p>

<p>我们先来看看未显示 MBProgressHUD 时，应用的视图层次结构。其中 1 为 <code>UIWindow</code> ，即 <code>self.view.window</code>，2 是 <code>UINavigationController</code> 的 <code>view</code> ，即我们前面提到的 <code>self.navigationController.view</code> ，3 为 <code>self.view</code> ，4 为导航栏 <code>UINavigationBar</code> ，即 <code>self.navigationController.navigationBar</code> 。</p>

<p><img src="http://leichunfeng.github.io/images/show-mbprogresshud.jpg" title="应用的视图层次结构" alt="应用的视图层次结构"></p>

<p>通过这张图，我们清楚地看到了 <code>self.view.window</code> 、<code>self.navigationController.view</code> 、<code>self.view</code> 和 <code>self.navigationController.navigationBar</code> 在应用的视图层次中所处的位置，以及它们之间的层次关系。</p>

<p>下面，我们就对比一下 MBProgressHUD 分别在 <code>self.view.window</code> 、<code>self.navigationController.view</code> 和 <code>self.view</code> 上显示时应用的视图层次结构，以及导航栏上按钮的可用情况。</p>

<h3>方式 1 - On self.view.window</h3>

<p>使用这种方式时，MBProgressHUD 被添加到了 <code>self.view.window</code> 上，它与 <code>self.navigationController.view</code> 在视图层次上是平级的，同为 <code>self.view.window</code> 的子视图。但是由于 MBProgressHUD 是后添加的，所以它处于 <code>self.navigationController.view</code> 的上方，因此导航栏上的按钮均不可点击。</p>

<p><img src="http://leichunfeng.github.io/images/on-self.view.window.jpg" title="应用的视图层次结构" alt="应用的视图层次结构"></p>

<h3>方式 2 - On self.navigationController.view</h3>

<p>使用这种方式时，MBProgressHUD 被添加到了 <code>self.navigationController.view</code> 上，它与 <code>self.navigationController.navigationBar</code> 在视图层次上是平级的，同为 <code>self.navigationController.view</code> 的子视图。但是由于 MBProgressHUD 是后添加的，所以它处于 <code>self.navigationController.navigationBar</code> 的上方，因此导航栏上的按钮也均不可点击。</p>

<p><img src="http://leichunfeng.github.io/images/on-self.navigationController.view.jpg" title="应用的视图层次结构" alt="应用的视图层次结构"></p>

<h3>方式 3 - On self.view</h3>

<p>使用这种方式时，MBProgressHUD 被添加到了 <code>self.view</code> 上，不管 <code>self.view</code> 或 MBProgressHUD 是否占满整个屏幕，<code>self.navigationController.navigationBar</code> 永远处于 MBProgressHUD 的上方。因此，导航栏上的按钮一直是可点击的。</p>

<p><img src="http://leichunfeng.github.io/images/on-self.view.jpg" title="应用的视图层次结构" alt="应用的视图层次结构"></p>

<h2>总结</h2>

<p>当你需要让导航栏上的按钮不可点击的时候，可以选择使用 <code>方式 1</code> 或 <code>方式 2</code> 显示 MBProgressHUD 。反之，可以选择 <code>方式 3</code> 。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[将 Octopress 博客从 GitHub 迁移到 GitCafe]]></title>
    <link href="http://leichunfeng.github.io/blog/2014/11/15/migrate-octopress-blog-from-github-to-gitcafe/"/>
    <updated>2014-11-15T13:38:20+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2014/11/15/migrate-octopress-blog-from-github-to-gitcafe</id>
    <content type="html"><![CDATA[<p>在<a href="http://blog.leichunfeng.com/blog/2014/11/11/use-octopress-plus-github-pages-to-setup-a-personal-blog/">上一篇博文</a>中我们提到了因为 GitHub 毕竟是国外的（你懂的）代码托管网站，所以我们博客的访问速度始终还是比较慢的。因此，如果你想让你的博客访问速度有飞一般的感觉的话，那么就跟我一样将你的 Octopress 博客从 GitHub 迁移到 GitCafe 上吧！</p>

<h2>迁移原理</h2>

<p><strong>注意</strong>，这里所说的迁移并非就是要完全抛弃 GitHub ，我们不需要这么极端。而是指我们在将博客内容 <code>push</code> 到 GitHub 的时候，也顺便 <code>push</code> 一份到 GitCafe 上。然后用 GitCafe 上的那份作为我们对外的博客使用，而 GitHub 上的那份则作为备份留存。这样，当我们哪天想再用回 GitHub 的时候，只要将我们的域名重新指回 GitHub 的博客地址就可以了，反之亦然。</p>

<p>在开始之前，我想大概谈一谈迁移的原理，理解了原理后你可能都不需要看下面的迁移步骤，自己就能轻松搞定了。我们知道，Octopress 其实为我们建立了两个分支，<code>source</code> 分支充当书桌，<code>master</code> 分支则用于存放最终生成的 <code>HTML</code> 博文。但有一点我们需要特别注意，那就是 Octopress 对这两个分支的操作其实是在本地两个不同的 Git 仓库中进行的。其中，对 <code>source</code> 分支的操作在 <code>octopress</code> 仓库中进行，而对 <code>master</code> 分支的操作则在 <code>_deploy</code> 仓库中进行。因此，接下来我们需要做的就已经比较明确了，只需要给 <code>_deploy</code> 仓库添加一个新的 GitCafe 远程仓库，然后将博客内容顺道 <code>push</code> 一份到 GitCafe 上就 OK 了。</p>

<h2>准备工作</h2>

<ol>
<li>注册 <a href="http://gitcafe.com/signup?invited_by=leichunfeng">GitCafe</a> 账号。</li>
<li>添加 SSH 公钥到你的 GitCafe 账号下，可参考 GitCafe 官方帮助文档中的<a href="https://gitcafe.com/GitCafe/Help/wiki/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AE-Git#wiki">《如何安装和设置 Git》</a>。</li>
<li>创建一个与你的 GitCafe 用户名相同名称的项目，例如 <a href="https://gitcafe.com/leichunfeng/leichunfeng">leichunfeng</a> 。</li>
</ol>


<h2>添加远程仓库</h2>

<p>运行以下命令，给 <code>_deploy</code> 仓库添加你的 GitCafe 仓库为新的远程仓库。记得先将 <code>git@gitcafe.com:leichunfeng/leichunfeng.git</code> 替换为你刚创建的 GitCafe 仓库的 SSH 地址。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">cd</span> <span class="n">_deploy</span>
</span><span class='line'><span class="n">git</span> <span class="n">remote</span> <span class="n">add</span> <span class="n">gitcafe</span> <span class="n">git</span><span class="vi">@gitcafe</span><span class="o">.</span><span class="n">com</span><span class="ss">:leichunfeng</span><span class="o">/</span><span class="n">leichunfeng</span><span class="o">.</span><span class="n">git</span>
</span></code></pre></td></tr></table></div></figure>


<h2>修改发布脚本</h2>

<p>为了实现在我们将博客内容 <code>push</code> 到 GitHub 的时候，也顺便 <code>push</code> 一份到 GitCafe 上，我们需要对 Octopress 的发布脚本稍作修改。这里，我们只需要在 <code>Rakefile</code> 文件中的 <code>:deploy</code> 部分添加以下三行代码就可以了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">## Pushing generated </span><span class="si">#{</span><span class="n">deploy_dir</span><span class="si">}</span><span class="s2"> website&quot;</span>
</span><span class='line'><span class="no">Bundler</span><span class="o">.</span><span class="n">with_clean_env</span> <span class="p">{</span> <span class="nb">system</span> <span class="s2">&quot;git push origin </span><span class="si">#{</span><span class="n">deploy_branch</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">}</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">## Github Pages deploy complete&quot;</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">## Pushing generated </span><span class="si">#{</span><span class="n">deploy_dir</span><span class="si">}</span><span class="s2"> website&quot;</span> <span class="c1"># 此行为新增代码</span>
</span><span class='line'><span class="no">Bundler</span><span class="o">.</span><span class="n">with_clean_env</span> <span class="p">{</span> <span class="nb">system</span> <span class="s2">&quot;git push gitcafe </span><span class="si">#{</span><span class="n">deploy_branch</span><span class="si">}</span><span class="s2">:gitcafe-pages&quot;</span> <span class="p">}</span> <span class="c1"># 此行为新增代码</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">## GitCafe Pages deploy complete&quot;</span> <span class="c1"># 此行为新增代码</span>
</span></code></pre></td></tr></table></div></figure>


<p>细心的你也许会有所发现，我们 <code>push</code> 到 GitCafe 上的远程分支名与 <code>push</code> 到 GitHub 上的远程分支名是不一样的。这是因为 GitHub 使用的是 <code>master</code> 分支来存放页面内容，而 GitCafe 则使用的是 <code>gitcafe-pages</code> 分支。不过，对这个我们不需要太过关心，知道是怎么回事就可以了，换汤不换药。</p>

<p>接下来，运行一下发布命令试试效果吧！</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="n">deploy</span>
</span></code></pre></td></tr></table></div></figure>


<h2>自定义域名</h2>

<p>GitCafe 的自定义域名设置要比 GitHub 的友好得多，它不仅提供了图形界面，而且支持给一个项目设置多个域名。进入<code>项目设置</code>界面，然后在<code>Pages 服务</code>栏目中添加你自己的域名。</p>

<p><img src="http://leichunfeng.github.io/images/gitcafe-custom-domains-new.jpg" title="GitCafe 自定义域名" alt="GitCafe 自定义域名"></p>

<p>同样的，你需要登陆你的域名注册商的管理平台，在你的域名下新增相应的 <code>A</code> 或 <code>CNAME</code> 解析记录。如果你需要将域名指向一个 <code>IPv4</code> 地址（例如：<code>leichunfeng.com</code> -> <code>207.226.141.135</code> ），则需要增加 <code>A</code> 记录；而如果你需要将域名指向另一个域名（例如：<code>blog.leichunfeng.com</code> -> <code>leichunfeng.gitcafe.io</code> ），实现与被指向域名相同的访问效果，则需要增加 <code>CNAME</code> 记录。</p>

<p><img src="http://leichunfeng.github.io/images/net-resolve-record-new.jpg" title="万网解析记录" alt="万网解析记录"></p>

<h2>添加对 GitCafe 的感谢</h2>

<p>GitCafe 是国内为数不多的做得不错的代码托管网站，目前还处于创业阶段。如果你也想跟我一样，在博客底部添加对 GitCafe 的感谢，可以通过修改 <code>source/_includes/custom/footer.html</code> 文件来实现。<strong>注意</strong>，记得将 <code>http://gitcafe.com/signup?invited_by=leichunfeng</code> 中的 <code>leichunfeng</code> 替换成你的 GitCafe 用户名。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;p&gt;</span>
</span><span class='line'>  Copyright <span class="ni">&amp;copy;</span> 2015-11-09 11:52:46 +0800 - 雷纯锋 -
</span><span class='line'>  <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">&quot;credit&quot;</span><span class="nt">&gt;</span>Powered by <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://octopress.org&quot;</span><span class="nt">&gt;</span>Octopress<span class="nt">&lt;/a&gt;&lt;/span&gt;</span>
</span><span class='line'>  <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">&quot;credit&quot;</span><span class="nt">&gt;</span> - 感谢 <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://gitcafe.com/signup?invited_by=leichunfeng&quot;</span> <span class="na">target=</span><span class="s">&quot;_blank&quot;</span><span class="nt">&gt;</span>GitCafe<span class="nt">&lt;/a&gt;</span> 为本站提供存储空间<span class="nt">&lt;/span&gt;</span>
</span><span class='line'><span class="nt">&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>至此，迁移工作就全部完成了。Enjoy ！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Octopress+GitHub Pages 搭建个人博客]]></title>
    <link href="http://leichunfeng.github.io/blog/2014/11/11/use-octopress-plus-github-pages-to-setup-a-personal-blog/"/>
    <updated>2014-11-11T21:47:07+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2014/11/11/use-octopress-plus-github-pages-to-setup-a-personal-blog</id>
    <content type="html"><![CDATA[<p>序言中提到周末折腾了两天时间，终于用 Octopress 成功搭建起了自己专属的技术博客，那么本文就来细说一下如何使用 Octopress+GitHub Pages 搭建个人博客。</p>

<h2>Octopress</h2>

<p><a href="http://octopress.org/">Octopress</a> 是一款基于 <a href="https://github.com/jekyll/jekyll">Jekyll</a> 的功能强大的博客框架，是对 Jekyll 的进一步封装，号称是给黑客使用的，用起来比 Jekyll 简单很多，不需要太多的设置，只需要 <a href="https://github.com/imathis/octopress">clone 或者 fork Octopress</a>，安装依赖和主题就可以了。当然，这个时候你的博客还比较粗糙，如果你想让你的博客访问速度更快，有分享和评论功能，以及每篇博文的最后都带上原文链接的话，你需要做的还比较多，不过不用担心，Follow me，我会为你娓娓道来。</p>

<h2>GitHub Pages</h2>

<p><a href="https://pages.github.com/">GitHub Pages</a> 是 GitHub 推出的用于建立用户、组织和项目站点的工具，每个 GitHub 账号和组织都可以建立一个站点以及无数个项目站点。我们要建立个人博客自然使用的是 GitHub Pages 的用户站点功能，建立用户站点非常简单，稍后我们再展开来谈。</p>

<h2>安装 Octopress</h2>

<p>前面我们提到了安装 Octopress 只需要简单的几个步骤就可以了，下面我们一步步来。</p>

<h3>准备工作</h3>

<ol>
<li>安装 <a href="http://git-scm.com/">Git</a> 。</li>
<li>安装 Ruby 1.9.3 及以上版本。</li>
</ol>


<p>你可以使用 <code>ruby --version</code> 查看一下你安装的 <code>Ruby</code> 版本，如果低于 1.9.3，你可以使用 <a href="http://octopress.org/docs/setup/rbenv/">rbenv</a> 或 <a href="http://octopress.org/docs/setup/rvm/">RVM</a> 来安装更高版本。</p>

<h3>克隆 Octopress</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">git</span> <span class="nb">clone</span> <span class="ss">git</span><span class="p">:</span><span class="sr">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">imathis</span><span class="o">/</span><span class="n">octopress</span><span class="o">.</span><span class="n">git</span> <span class="n">octopress</span>
</span><span class='line'><span class="n">cd</span> <span class="n">octopress</span>
</span></code></pre></td></tr></table></div></figure>


<h3>安装依赖</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">gem</span> <span class="n">install</span> <span class="n">bundler</span>
</span><span class='line'><span class="n">rbenv</span> <span class="n">rehash</span> <span class="c1"># 如果你使用的是 rbenv 的话，执行下这句，不是的话可以略过</span>
</span><span class='line'><span class="n">bundle</span> <span class="n">install</span>
</span></code></pre></td></tr></table></div></figure>


<h3>安装 Octopress 默认主题</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="n">install</span>
</span></code></pre></td></tr></table></div></figure>


<h3>配置 Octopress</h3>

<p>至此，你的 Octopress 就已经安装好了，接下来我们对 Octopress 进行一些简单的配置。我们需要修改的只有 <code>_config.yml</code> 一个文件，这个文件包含 <code>Main Configs</code> 、<code>Jekyll &amp; Plugins</code> 和 <code>3rd Party Settings</code> 三个部分。在这里，我们只需要修改 <code>Main Configs</code> 中的 <code>title</code> 、<code>subtitle</code> 和 <code>author</code> 。说明，后面我们会通过 Octopress 提供的 <code>rake setup_github_pages</code> 命令自动修改 <code>url</code> ，这里先不用管。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="ss">title</span><span class="p">:</span> <span class="err">雷纯锋的技术博客</span>
</span><span class='line'><span class="ss">subtitle</span><span class="p">:</span> <span class="err">记录自己学习的点滴，收获分享知识的乐趣</span>
</span><span class='line'><span class="ss">author</span><span class="p">:</span> <span class="err">雷纯锋</span>
</span></code></pre></td></tr></table></div></figure>


<h2>写博文的方法</h2>

<p>用 Octopress 写博文主要是通过执行 Octopress 提供的 <code>rake</code> 命令来完成的，下面简单介绍一下，更多的详细信息可以查看 Octopress 官方文档中的 <a href="http://octopress.org/docs/blogging/">Blogging Basics</a> 。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="n">new_post</span><span class="o">[</span><span class="s2">&quot;title&quot;</span><span class="o">]</span> <span class="c1"># 在 source/_posts 目录下创建一篇新博文</span>
</span><span class='line'><span class="n">rake</span> <span class="n">generate</span>          <span class="c1"># 生成博文到 public 目录下</span>
</span><span class='line'><span class="n">rake</span> <span class="n">watch</span>             <span class="c1"># 查看 source 和 sass 目录的变化，且有变化时重新生成博文</span>
</span><span class='line'><span class="n">rake</span> <span class="n">preview</span>           <span class="c1"># 在 http://localhost:4000/ 预览博文</span>
</span></code></pre></td></tr></table></div></figure>


<p>Octopress 博文采用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> 语法进行书写，Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，它的作用一目了然，因此你可能只需要 5-10 分钟就能快速上手。Markdown 免费编辑器非常多，我本人非常酷爱 Sublime Text ，它绝对可以称得上编辑器中的神器。所以我的博文都是使用 <a href="http://www.sublimetext.com/3">Sublime Text 3</a>+<a href="https://github.com/SublimeText-Markdown/MarkdownEditing">MarkdownEditing</a> 插件进行书写的，书写起来感觉非常惬意。这感觉美妙极了，很难用言语来表达，是我梦寐以求的书写感受，所以也<strong>强烈推荐</strong>你试一试，Who with who knows 。</p>

<h2>发布 Octopress 到 GitHub Pages</h2>

<p>首先，你需要创建一个新的 <a href="https://github.com/repositories/new">GitHub 仓库</a> ，这个仓库的名称为 <code>username.github.io</code> ，其中 <code>username</code> 为你的 GitHub 用户名，例如 <code>leichunfeng.github.io</code> 。接下来，我们使用 Octopress 提供的 <code>rake setup_github_pages</code> 命令来完成一些与 GitHub Pages 相关的配置工作，其中就包括我们前面提到的 <code>_config.yml</code> 文件中的 <code>url</code> 。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="n">setup_github_pages</span>
</span></code></pre></td></tr></table></div></figure>


<p>根据提示需要我们输入 GitHub 仓库的 URL ，拷贝我们刚刚创建的仓库的 SSH 或 HTTPS URL ，例如 <code>git@github.com:leichunfeng/leichunfeng.github.io.git</code> ，粘贴并回车。这个看似简单的 <code>rake</code> 命令其实偷偷地为我们做了很多复杂的工作，包括修改 octopress 远程仓库 origin 的名称为 octopress 、添加我们的 GitHub 仓库为新的 origin 远程仓库和配置 <code>_config.yml</code> 文件中的 <code>url</code> 等等，更多的详细信息可以查看 Octopress 官方文档中的 <a href="http://octopress.org/docs/deploying/github/">Deploying to GitHub Pages</a> 。</p>

<p>接下来，运行以下命令。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="n">generate</span>
</span><span class='line'><span class="n">rake</span> <span class="n">deploy</span> <span class="c1"># 发布博文到 GitHub Pages</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，别忘记提交你的博客源文件。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">git</span> <span class="n">add</span> <span class="o">.</span>
</span><span class='line'><span class="n">git</span> <span class="n">commit</span> <span class="o">-</span><span class="n">m</span> <span class="s1">&#39;your message&#39;</span>
</span><span class='line'><span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="n">source</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这里，我还是想大概谈一谈 Octopress 的工作原理，不然你可能也会跟我刚接触 Octopress 时一样充满疑惑。Octopress 其实为我们建立了两个分支，一个是 <code>source</code> 分支，就像我们的书桌，用于存放我们书写时需要用到的各种工具，包括原始的 markdown 文件、生成博文用的插件、主题和脚本等等。另一个是 <code>master</code> 分支，其实就是 <code>public</code> 目录中的内容，用于存放最终生成的 <code>HTML</code> 博文。当我们执行 <code>rake generate</code> 命令时，Octopress 会为我们生成 <code>HTML</code> 博文到 <code>public</code> 目录下。当执行 <code>rake deploy</code> 命令时，Octopress 则会将 <code>public</code> 目录中的内容提交并同步到 <code>GitHub Pages</code> 。建议你自己亲自对比一下运行以上命令前后 octopress 目录中文件的变化，这样可以快速地熟悉 Octopress 的工作原理。</p>

<p>到这里，你的个人博客就已经搭建成功了，你可以使用 <code>http://username.github.io</code> 来访问你的博客了，给自己一点掌声吧！不过如果你希望你的博客能够更加与众不同的话，那么我们还有一些事情需要去做，休息一会，我们继续。</p>

<h3>自定义域名</h3>

<p>如果你也跟我一样有自己的域名的话，可以使用自己的域名指向你的博客地址。首先，你需要在 <code>source</code> 目录下建立一个名为 <code>CNAME</code> 的文件，这个文件只需要一行内容，就是你自己的域名。不过需要特别注意的一点就是这个域名不要带上 <code>http(s)://</code> 网址前缀，例如我的域名 <code>blog.leichunfeng.com</code> 。最后，运行 <code>rake</code> 命令重新生成并发布博文。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">echo</span> <span class="s1">&#39;your-domain.com&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">source</span><span class="o">/</span><span class="no">CNAME</span>
</span><span class='line'><span class="c1"># 或者</span>
</span><span class='line'><span class="n">echo</span> <span class="s1">&#39;blog.your-domain.com&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">source</span><span class="o">/</span><span class="no">CNAME</span>
</span><span class='line'>
</span><span class='line'><span class="n">rake</span> <span class="n">generate</span>
</span><span class='line'><span class="n">rake</span> <span class="n">deploy</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来，你需要登陆你的域名注册商的管理平台，在你的域名下新增一条解析记录。如果你想使用子域名，例如 <code>blog.example.com</code> ，你需要新增的就是一条记录类型为 <code>CNAME</code> ，记录值为 <code>username.github.io</code> 的解析记录。如果你想使用顶级域名，例如 <code>example.com</code> ，那么你需要新增的就是一条记录类型为 <code>A</code> ，记录值为 <code>192.30.252.153</code> or <code>192.30.252.154</code> 的解析记录。大概过 1 个小时左右，你就可以使用你自己的域名来访问你的博客了。怎么样，这种感觉是不是非常美妙？</p>

<h2>高级配置</h2>

<p>如果你希望你的博客具有微博分享和评论功能的话，可以参考下<code>唐巧</code>的博文 <a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/">《象写程序一样写博客：搭建基于github的博客》</a> 中的<code>高级配置</code>章节，这里不再赘述。不过，我建议你最好在注册了<a href="http://www.uyan.cc/">友言</a>或 <a href="http://www.jiathis.com/">JiaThis</a> 的账号后再点击<code>获取代码</code>，这样获取到的代码就会带有你的 <code>uid</code> ，那么你就可以通过友言或 JiaThis 的管理后台查看你的统计数据了。</p>

<h3>优化博客的访问速度</h3>

<ol>
<li>删除或注释配置 <code>_config.yml</code> 文件中有关 <code>Twitter</code> 的部分。</li>
<li>修改 <code>source/_includes/custom/head.html</code> 文件，删除 <code>google</code> 的自定义字体。<strong>注意</strong>，如果使用注释的方式会造成最终生成出来的 <code>HTML</code> 页面的 <code>body</code>
部分也被注释。</li>
<li>修改 <code>source/_includes/head.html</code> 文件中 <code>jquery.min.js</code> 的链接地址。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>将 <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</span><span class='line'>替换为 <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>添加原文链接</h3>

<p>给你的每篇博文最后添加上原文链接，这样不管是其他人转载或是分享你的博文，读者都能够根据原文链接轻松地访问到你的原始博文。要实现这个目的并不难，但是我不想因为这样而破坏了博文原本的结构和布局，还要让读者在阅读博文的时候毫无违和感，谁让我是一个偏执狂呢！我查看过不少这方面的博文，其中<a href="http://codemacro.com/2012/07/26/post-footer-plugin-for-octopress/">《为octopress每篇文章添加一个文章信息》</a>还算比较接近我的需求，但还不够完美，且太复杂。于是我决定自己动手实现，结果已如你所见。</p>

<ul>
<li>创建 <code>source/_includes/post/original_link.html</code> 文件，内容只有一行代码。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">echo</span> <span class="s1">&#39;&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.leichunfeng.com{#{page.url}#}&quot;&gt;http://blog.leichunfeng.com{#{page.url}#}&lt;/a&gt;&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">source</span><span class="o">/</span><span class="n">_includes</span><span class="o">/</span><span class="n">post</span><span class="o">/</span><span class="n">original_link</span><span class="o">.</span><span class="n">html</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>修改 <code>source/_layouts/post.html</code> 文件，在 <code>{#% include post/categories.html %#}</code> 后面添加一行代码。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">{</span><span class="c1">#% include post/categories.html %#}</span>
</span><span class='line'><span class="p">{</span><span class="c1">#% include post/original_link.html %#} &lt;!-- 添加这一行代码 --&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意</strong>，请记得将第一步中的 <code>blog.leichunfeng.com</code> 替换成你自己的博客域名，将上述两步中的 <code>#</code> 号去掉。</p>

<p>到这里，本文就已经接近尾声了，不过我们对博客访问速度的追求仍然没有结束。因为 GitHub 毕竟是国外的（你懂的）代码托管网站，所以我们博客的访问速度始终还是比较慢的。在下一篇博文中我将向大家介绍如何<a href="http://blog.leichunfeng.com/blog/2014/11/15/migrate-octopress-blog-from-github-to-gitcafe/">《将 Octopress 博客从 GitHub 迁移到 GitCafe》</a>，到时你的博客的访问速度也会跟我的一样，飞一般的感觉。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[序言]]></title>
    <link href="http://leichunfeng.github.io/blog/2014/11/11/preface/"/>
    <updated>2014-11-11T18:49:07+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2014/11/11/preface</id>
    <content type="html"><![CDATA[<p>周末折腾了两天时间，终于用 <a href="http://octopress.org/">Octopress</a> 成功搭建起了自己专属的技术博客。不过在正式开始写第一篇技术博客之前，我还是想先写一篇序言，聊一聊自己此时此刻的想法，就当作是为博客开个头吧。</p>

<p>其实，我非常羡慕那些文笔好的人，可以自由自在地用文字抒发自己的想法和情感，挥洒自如。其中，我的一个大学室友的文笔就非常不错，他在大学期间就写了一本比较受欢迎的小说 — <a href="http://www.qidian.com/Book/2279600.aspx">《魔兽法师的荣耀》</a>，让我顿时对他刮目相看，没有想到平时懒散惯了的屌丝也会有如此文艺的一面。因此，作为一直被世人所调侃的程序员中的一份子，我也一直想让自己变得文艺一点，力争摆脱屌丝的高大形象，希望能改变一点人们对程序员的世俗眼光。其中，写作应该算是一种比较优雅的方式，可以让我在自由自在表达自己情感的同时，让自己稍稍带上些文雅的气息。</p>

<p>从毕业到现在已经有近两年半的时间了，光阴稍纵即逝。期间经历了太多的事情，让我深知人生不易，且行且珍惜的道理。我是一个怀旧的人，我现在仍然时常会想起大学时美好的时光，回忆那大学生活的点滴，因为那是一种无忧远虑、不问世事的田园生活，因为那时我也有一个完整的家，因为那是我人生中的一笔非常宝贵的财富。</p>

<p>因此，我希望从现在开始能够将自己学习的点滴都用文字记录下来，因为这将是我人生中的另一笔非常宝贵的财富。虽然接下来我所要写的很多技术文章别人可能都已经写过了，但是在我看来这些都是我所亲身经历过的，每个人的理解和感悟也并不会完全一样。虽然我的文笔并不好，但是我确信我能够做到言之有物、言之有理。</p>

<p>我觉得我是幸运的，因为我在短短两年半的时间内就有机会接触到比较多的开发语言和编程知识，比如<a href="https://developer.apple.com/devcenter/ios/index.action">iOS</a>、<a href="http://developer.android.com/index.html">Android</a>、<a href="http://www.java.com/zh_CN/">Java</a>、<a href="http://www.html5.com/">HTML5</a>、<a href="http://www.appcan.cn/">AppCan</a>、<a href="http://phonegap.com/">PhoneGap</a>等。我是一个懒惰的码农，却一直在为不成为码农而不懈努力，并希望成为一名优秀的程序员。我的惰性是一直存在的，但在加入程序员队伍后变得愈发强烈，并且与日俱增。</p>

<p>因为懒得在手机上用拼音输入而学习双拼输入法，因为懒得在电脑上用全拼输入而学习五笔输入法，因为懒得写重复的代码而学习《重构 改善既有代码的设计》和《大话设计模式》，因为懒得用鼠标点击而记忆各种快捷键&hellip;但是往往后者需要花费比前者更多的时间和精力，这是多么矛盾啊。</p>

<p>虽说是技术博客，但是我想本博客所涉及到的范围应该不仅仅只是局限于程序层面，只要是我觉得有意思的东西我都会考虑写上来，比如接下来我可能会考虑写一篇《一分钟学会双拼输入法》的文章，因为已经有好些人加我QQ希望学习双拼输入法了。</p>

<p>最后，我是一个乐于分享的人，希望本博客能够作为我与读者分享和交流的一扇窗户，透过这扇窗我能够结交更多志同道合的朋友。</p>
]]></content>
  </entry>
  
</feed>
