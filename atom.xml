<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[雷纯锋的技术博客]]></title>
  <link href="http://leichunfeng.github.io/atom.xml" rel="self"/>
  <link href="http://leichunfeng.github.io/"/>
  <updated>2017-02-23T17:24:45+08:00</updated>
  <id>http://leichunfeng.github.io/</id>
  <author>
    <name><![CDATA[雷纯锋]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[谈谈 iOS 中图片的解压缩]]></title>
    <link href="http://leichunfeng.github.io/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/"/>
    <updated>2017-02-20T10:47:56+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios</id>
    <content type="html"><![CDATA[<p>对于大多数 iOS 应用来说，图片往往是最占用手机内存的资源之一，同时也是不可或缺的组成部分。将一张图片从磁盘中加载出来，并最终显示到屏幕上，中间其实经过了一系列复杂的处理过程，其中就包括了对图片的解压缩。</p>

<h2>图片加载的工作流</h2>

<p>概括来说，从磁盘中加载一张图片，并将它显示到屏幕上，中间的<a href="https://github.com/path/FastImageCache#the-problem">主要工作流</a>如下：</p>

<ol>
<li>假设我们使用 <code>+imageWithContentsOfFile:</code> 方法从磁盘中加载一张图片，这个时候的图片并没有解压缩；</li>
<li>然后将生成的 <code>UIImage</code> 赋值给 <code>UIImageView</code> ；</li>
<li>接着一个隐式的 <code>CATransaction</code> 捕获到了 <code>UIImageView</code> 图层树的变化；</li>
<li>在主线程的下一个 run loop 到来时，Core Animation 提交了这个隐式的 transaction ，这个过程可能会对图片进行 copy 操作，而受图片是否<strong>字节对齐</strong>等因素的影响，这个 copy 操作可能会涉及以下部分或全部步骤：

<ol>
<li>分配内存缓冲区用于管理文件 IO 和解压缩操作；</li>
<li>将文件数据从磁盘读到内存中；</li>
<li>将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作；</li>
<li>最后 Core Animation 使用未压缩的位图数据渲染 <code>UIImageView</code> 的图层。</li>
</ol>
</li>
</ol>


<p>在上面的步骤中，我们提到了图片的解压缩是一个非常耗时的 CPU 操作，并且它默认是在主线程中执行的。那么当需要加载的图片比较多时，就会对我们应用的响应性造成严重的影响，尤其是在快速滑动的列表上，这个问题会表现得更加突出。</p>

<h2>为什么需要解压缩</h2>

<p>既然图片的解压缩需要消耗大量的 CPU 时间，那么我们为什么还要对图片进行解压缩呢？是否可以不经过解压缩，而直接将图片显示到屏幕上呢？答案是否定的。要想弄明白这个问题，我们首先需要知道什么是<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-SW3">位图</a>：</p>

<blockquote><p>A bitmap image (or sampled image) is an array of pixels (or samples). Each pixel represents a single point in the image. JPEG, TIFF, and PNG graphics files are examples of bitmap images.</p></blockquote>

<p>其实，位图就是一个像素数组，数组中的每个像素就代表着图片中的一个点。我们在应用中经常用到的 JPEG 和 PNG 图片就是位图。下面，我们来看一个具体的例子，这是一张 PNG 图片，像素为 30 × 30 ，文件大小为 843B ：</p>

<p><img src="http://blog.leichunfeng.com/images/check_green.png" alt="位图" /></p>

<p>我们使用<a href="https://developer.apple.com/library/content/qa/qa1509/_index.html">下面的代码</a>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">@&quot;check_green&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">CFDataRef</span> <span class="n">rawData</span> <span class="o">=</span> <span class="n">CGDataProviderCopyData</span><span class="p">(</span><span class="n">CGImageGetDataProvider</span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="bp">CGImage</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>就可以获取到这个图片的原始像素数据，大小为 3600B ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span>
</span><span class='line'><span class="mo">01020102</span> <span class="mo">032</span><span class="n">c023c</span> <span class="mo">056704</span><span class="mi">8</span><span class="n">c</span> <span class="mo">07</span><span class="mi">8</span><span class="n">d06bf</span> <span class="mi">08</span><span class="n">a006d9</span> <span class="mi">09</span><span class="n">b307f3</span> <span class="mi">09</span><span class="n">b307f3</span> <span class="mi">08</span><span class="n">a006d9</span> <span class="mo">07</span><span class="mi">8</span><span class="n">d06bf</span>
</span><span class='line'><span class="mo">056704</span><span class="mi">8</span><span class="n">c</span> <span class="mo">032</span><span class="n">c023c</span> <span class="mo">01020102</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span>
</span><span class='line'><span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span>
</span><span class='line'><span class="mo">00000000</span> <span class="mo">0106010</span><span class="mi">8</span> <span class="mo">05570476</span> <span class="mi">09</span><span class="n">ab07e9</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span>
</span><span class='line'><span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">ab07e9</span> <span class="mo">05570476</span> <span class="mo">0106010</span><span class="mi">8</span> <span class="mo">00000000</span>
</span><span class='line'><span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span>
</span><span class='line'><span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">033</span><span class="n">d0353</span> <span class="mi">08</span><span class="n">a607e2</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">08</span><span class="n">a607e2</span> <span class="mo">033</span><span class="n">d0353</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span>
</span><span class='line'><span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span>
</span><span class='line'><span class="mo">00000000</span> <span class="mo">0106010</span><span class="mi">8</span> <span class="mo">05570476</span> <span class="mi">09</span><span class="n">ab07e9</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span>
</span><span class='line'><span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">bb07ff</span> <span class="mi">09</span><span class="n">ab07e9</span> <span class="mo">05570476</span> <span class="mo">0106010</span><span class="mi">8</span> <span class="mo">00000000</span>
</span><span class='line'><span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span>
</span><span class='line'><span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">01020102</span> <span class="mo">032</span><span class="n">c023c</span> <span class="mo">056704</span><span class="mi">8</span><span class="n">c</span>
</span><span class='line'><span class="mo">07</span><span class="mi">8</span><span class="n">d06bf</span> <span class="mi">08</span><span class="n">a006d9</span> <span class="mi">09</span><span class="n">b307f3</span> <span class="mi">09</span><span class="n">b307f3</span> <span class="mi">08</span><span class="n">a006d9</span> <span class="mo">07</span><span class="mi">8</span><span class="n">d06bf</span> <span class="mo">056704</span><span class="mi">8</span><span class="n">c</span> <span class="mo">032</span><span class="n">c023c</span> <span class="mo">01020102</span>
</span><span class='line'><span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span> <span class="mo">00000000</span>
</span></code></pre></td></tr></table></div></figure>


<p>也就是说，这张文件大小为 843B 的 PNG 图片解压缩后的大小是 3600B ，是原始文件大小的 4.27 倍。那么这个 3600B 是怎么得来的呢？与图片的文件大小或者像素有什么必然的联系吗？事实上，解压缩后的图片大小与原始文件大小之间没有任何关系，而只与图片的像素有关：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="err">解压缩后的图片大小</span> <span class="o">=</span> <span class="err">图片的像素宽</span> <span class="mi">30</span> <span class="o">*</span> <span class="err">图片的像素高</span> <span class="mi">30</span> <span class="o">*</span> <span class="err">每个像素所占的字节数</span> <span class="mi">4</span>
</span></code></pre></td></tr></table></div></figure>


<p>至于这个公式是怎么得来的，我们后面会有详细的说明，现在只需要知道即可。</p>

<p>至此，我们已经知道了什么是位图，并且直观地看到了它的原始像素数据，那么它与我们经常提到的图片的二进制数据有什么联系吗？是同一个东西吗？事实上，这二者是完全独立的两个东西，它们之间没有必然的联系。为了加深理解，我把这个图片拖进 Sublime Text 2 中，得到了这个图片的二进制数据，大小与原始文件大小一致，为 843B ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="mi">8950</span> <span class="mf">4e47</span> <span class="mi">0</span><span class="n">d0a</span> <span class="mi">1</span><span class="n">a0a</span> <span class="mo">0000</span> <span class="mo">000</span><span class="n">d</span> <span class="mi">4948</span> <span class="mi">4452</span> <span class="mo">0000</span> <span class="mo">001</span><span class="n">e</span> <span class="mo">0000</span> <span class="mo">001</span><span class="n">e</span> <span class="mi">0806</span> <span class="mo">0000</span> <span class="mo">003</span><span class="n">b</span> <span class="mi">30</span><span class="n">ae</span> <span class="n">a200</span>
</span><span class='line'><span class="mo">0000</span> <span class="mo">0173</span> <span class="mi">5247</span> <span class="mi">4200</span> <span class="n">aece</span> <span class="mi">1</span><span class="n">ce9</span> <span class="mo">0000</span> <span class="mo">0305</span> <span class="mi">4944</span> <span class="mi">4154</span> <span class="mi">480</span><span class="n">d</span> <span class="n">c557</span> <span class="mi">4</span><span class="n">d68</span> <span class="mi">1341</span> <span class="mi">149</span><span class="n">e</span> <span class="mi">3709</span> <span class="n">da4d</span>
</span><span class='line'><span class="mi">09</span><span class="n">c6</span> <span class="mi">8</span><span class="n">a56</span> <span class="mi">2385</span> <span class="mf">9e14</span> <span class="n">f458</span> <span class="mf">4f</span><span class="n">a2</span> <span class="n">d092</span> <span class="n">f4a6</span> <span class="mi">28</span><span class="n">d8</span> <span class="mi">2222</span> <span class="n">de04</span> <span class="mi">3</span><span class="n">d09</span> <span class="n">a1d0</span> <span class="mi">7</span><span class="n">a50</span> <span class="mi">0954</span> <span class="mi">8</span><span class="n">bad</span> <span class="mi">2</span><span class="n">d05</span>
</span><span class='line'><span class="mf">4f</span><span class="n">de</span> <span class="mi">3</span><span class="n">c89</span> <span class="mi">482</span><span class="n">b</span> <span class="mi">2</span><span class="n">ad6</span> <span class="mi">8334</span> <span class="n">d183</span> <span class="n">e049</span> <span class="n">ef9e</span> <span class="mi">4</span><span class="n">a41</span> <span class="mi">48</span><span class="n">b0</span> <span class="mi">42</span><span class="n">eb</span> <span class="n">a549</span> <span class="mi">6893</span> <span class="mi">1</span><span class="n">ddf</span> <span class="mi">9</span><span class="n">bcd</span> <span class="n">b4d9</span> <span class="n">d9d9</span>
</span><span class='line'><span class="mi">4</span><span class="n">dd8</span> <span class="n">a43a</span> <span class="n">b0d9</span> <span class="mi">9</span><span class="n">d79</span> <span class="mf">3f</span><span class="n">df</span> <span class="n">bc79</span> <span class="mf">3ff</span><span class="mi">3</span> <span class="mo">02</span><span class="n">ac</span> <span class="mi">8591</span> <span class="mi">1559</span> <span class="mf">3e97</span> <span class="mi">9</span><span class="n">b3e</span> <span class="mi">5</span><span class="n">b05</span> <span class="n">fb32</span> <span class="mi">6330</span> <span class="n">c098</span> <span class="mi">48</span><span class="n">a2</span>
</span><span class='line'><span class="mi">183</span><span class="n">d</span> <span class="mi">340</span><span class="n">a</span> <span class="n">b886</span> <span class="mf">8ff</span><span class="mi">8</span> <span class="mf">1e15</span> <span class="n">fced</span> <span class="mi">587</span><span class="n">a</span> <span class="n">e26b</span> <span class="mi">16</span><span class="n">b2</span> <span class="n">b643</span> <span class="n">f2ff</span> <span class="mf">057f</span> <span class="mi">1263</span> <span class="n">fd9f</span> <span class="n">fbbb</span> <span class="mi">7</span><span class="n">ed7</span> <span class="mi">7</span><span class="n">edd</span>
</span><span class='line'><span class="mi">1142</span> <span class="mi">8</span><span class="n">c09</span> <span class="mi">268</span><span class="n">e</span> <span class="mf">04f</span><span class="mi">1</span> <span class="mi">2</span><span class="n">a1a</span> <span class="mi">3058</span> <span class="mo">03</span><span class="mi">80</span> <span class="n">b9c3</span> <span class="mi">91</span><span class="n">de</span> <span class="n">a7ab</span> <span class="mi">43</span><span class="n">ab</span> <span class="mi">15</span><span class="n">b5</span> <span class="n">aebf</span> <span class="mi">7</span><span class="n">d81</span> <span class="n">ad65</span> <span class="n">eb0a</span> <span class="mi">5</span><span class="n">a31</span>
</span><span class='line'><span class="mf">8f4f</span> <span class="mf">9f</span><span class="mi">2</span><span class="n">e</span> <span class="n">d4da</span> <span class="mi">1</span><span class="n">c7e</span> <span class="n">e249</span> <span class="mi">64</span><span class="n">ca</span> <span class="n">c3e5</span> <span class="n">d726</span> <span class="mi">7</span><span class="n">eae</span> <span class="mf">2f</span><span class="n">a2</span> <span class="mi">7510</span> <span class="n">cb75</span> <span class="mi">3</span><span class="n">d62</span> <span class="n">cc5e</span> <span class="mi">0</span><span class="n">c0f</span> <span class="mi">4</span><span class="n">a5a</span> <span class="mi">69</span><span class="n">c3</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="mi">36</span><span class="n">ac</span> <span class="n">b11e</span> <span class="mi">7006</span> <span class="n">f71b</span> <span class="mi">5386</span> <span class="n">a2b7</span> <span class="mf">1e48</span> <span class="n">ad82</span> <span class="n">a26a</span> <span class="mi">2880</span> <span class="mi">95</span><span class="n">db</span> <span class="mf">3f</span><span class="mi">8</span><span class="n">b</span> <span class="n">f525</span> <span class="n">b880</span> <span class="n">e0ed</span> <span class="mi">7221</span> <span class="mf">75f</span><span class="mi">1</span>
</span><span class='line'><span class="n">fa02</span> <span class="mi">2</span><span class="n">cd4</span> <span class="mi">1</span><span class="n">af7</span> <span class="mi">1</span><span class="n">d0e</span> <span class="mi">546</span><span class="n">a</span> <span class="mf">98e5</span> <span class="n">d4ae</span> <span class="mi">342</span><span class="n">a</span> <span class="mi">337</span><span class="n">e</span> <span class="mi">6</span><span class="n">b96</span> <span class="mf">134f</span> <span class="mi">1</span><span class="n">ba0</span> <span class="mi">0</span><span class="n">c0b</span> <span class="n">c83b</span> <span class="n">a0f2</span> <span class="mi">3593</span> <span class="mi">7</span><span class="n">b5c</span>
</span><span class='line'><span class="mi">6</span><span class="n">ca9</span> <span class="n">b541</span> <span class="n">cb4f</span> <span class="mi">254</span><span class="n">e</span> <span class="n">df58</span> <span class="n">d958</span> <span class="mi">8955</span> <span class="n">a0fc</span> <span class="mi">2638</span> <span class="mi">658</span><span class="n">c</span> <span class="mi">2660</span> <span class="n">f986</span> <span class="n">b5f1</span> <span class="n">f4dd</span> <span class="mf">63f</span><span class="mi">2</span> <span class="mi">5</span><span class="n">aec</span> <span class="n">ce59</span>
</span><span class='line'><span class="n">e3b6</span> <span class="n">b0a7</span> <span class="n">cdac</span> <span class="n">ee55</span> <span class="mi">145</span><span class="n">c</span> <span class="n">c7dc</span> <span class="mf">8f</span><span class="mi">60</span> <span class="n">f53f</span> <span class="n">e0a6</span> <span class="n">b436</span> <span class="n">e3c0</span> <span class="mi">27</span><span class="n">b0</span> <span class="mi">8</span><span class="n">ecf</span> <span class="mi">5054</span> <span class="mi">336</span><span class="n">a</span> <span class="n">ccd0</span> <span class="n">e1d8</span>
</span><span class='line'><span class="mi">2335</span> <span class="mf">1f</span><span class="mi">78</span> <span class="mi">323</span><span class="n">d</span> <span class="mi">6141</span> <span class="mi">09</span><span class="n">c3</span> <span class="n">c1aa</span> <span class="mf">5f</span><span class="mi">8</span><span class="n">b</span> <span class="mf">4e37</span> <span class="mi">0899</span> <span class="n">e6b0</span> <span class="n">ed72</span> <span class="mi">4046</span> <span class="mi">759</span><span class="n">e</span> <span class="n">d262</span> <span class="mi">5247</span> <span class="mi">9</span><span class="n">d01</span> <span class="mi">1689</span>
</span><span class='line'><span class="n">a976</span> <span class="mf">55f</span><span class="n">b</span> <span class="n">c993</span> <span class="mi">6</span><span class="n">ed5</span> <span class="mi">7</span><span class="n">d10</span> <span class="mf">8ff</span><span class="mi">4</span> <span class="n">b162</span> <span class="n">fe6f</span> <span class="n">cd1e</span> <span class="n">ee4a</span> <span class="n">d4bb</span> <span class="n">c18e</span> <span class="mi">594</span><span class="n">e</span> <span class="mi">96</span><span class="n">ea</span> <span class="mi">1</span><span class="n">da6</span> <span class="n">c762</span> <span class="mi">6539</span>
</span><span class='line'><span class="n">bdff</span> <span class="mi">7943</span> <span class="n">afc0</span> <span class="n">c91f</span> <span class="n">bdd1</span> <span class="n">a327</span> <span class="mf">28f</span><span class="n">c</span> <span class="mf">29f</span><span class="mi">7</span> <span class="n">d47a</span> <span class="n">b337</span> <span class="n">f192</span> <span class="mi">0</span><span class="n">cc9</span> <span class="mf">36f</span><span class="n">a</span> <span class="mi">5497</span> <span class="mf">73f</span><span class="mi">9</span> <span class="mi">5827</span> <span class="n">aa39</span>
</span><span class='line'><span class="mi">1599</span> <span class="mi">4</span><span class="n">eff</span> <span class="mf">69f</span><span class="n">b</span> <span class="mi">0</span><span class="n">b0d</span> <span class="mf">1f</span><span class="mi">7</span><span class="n">a</span> <span class="mi">96</span><span class="n">cd</span> <span class="mi">3</span><span class="n">eb0</span> <span class="mi">7800</span> <span class="mo">0000</span> <span class="mo">004</span><span class="mi">9</span> <span class="mi">454</span><span class="n">e</span> <span class="mi">44</span><span class="n">ae</span> <span class="mi">4260</span> <span class="mi">82</span>
</span></code></pre></td></tr></table></div></figure>


<p>事实上，不管是 JPEG 还是 PNG 图片，都是一种压缩的位图图形格式。只不过 PNG 图片是无损压缩，并且支持 alpha 通道，而 JPEG 图片则是有损压缩，可以指定 0-100% 的压缩比。值得一提的是，在苹果的 SDK 中专门提供了两个函数用来生成 PNG 和 JPEG 图片：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// return image as PNG. May return nil if image has no CGImageRef or invalid bitmap format</span>
</span><span class='line'><span class="n">UIKIT_EXTERN</span> <span class="bp">NSData</span> <span class="o">*</span> <span class="n">__nullable</span> <span class="nf">UIImagePNGRepresentation</span><span class="p">(</span><span class="bp">UIImage</span> <span class="o">*</span> <span class="n">__nonnull</span> <span class="n">image</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)                           </span>
</span><span class='line'><span class="n">UIKIT_EXTERN</span> <span class="bp">NSData</span> <span class="o">*</span> <span class="n">__nullable</span> <span class="nf">UIImageJPEGRepresentation</span><span class="p">(</span><span class="bp">UIImage</span> <span class="o">*</span> <span class="n">__nonnull</span> <span class="n">image</span><span class="p">,</span> <span class="n">CGFloat</span> <span class="n">compressionQuality</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，在将磁盘中的图片渲染到屏幕之前，必须先要得到图片的原始像素数据，才能执行后续的绘制操作，这就是为什么需要对图片解压缩的原因。</p>

<h2>强制解压缩的原理</h2>

<p>既然图片的解压缩不可避免，而我们也不想让它在主线程执行，影响我们应用的响应性，那么是否有比较好的解决方案呢？答案是肯定的。</p>

<p>我们前面已经提到了，当未解压缩的图片将要渲染到屏幕时，系统会在主线程对图片进行解压缩，而如果图片已经解压缩了，系统就不会再对图片进行解压缩。因此，也就有了业内的解决方案，在子线程提前对图片进行强制解压缩。</p>

<p>而强制解压缩的原理就是对图片进行重新绘制，得到一张新的解压缩后的位图。其中，用到的最核心的函数是 <code>CGBitmapContextCreate</code> ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cm">/* Create a bitmap context. The context draws into a bitmap which is `width&#39;</span>
</span><span class='line'><span class="cm">   pixels wide and `height&#39; pixels high. The number of components for each</span>
</span><span class='line'><span class="cm">   pixel is specified by `space&#39;, which may also specify a destination color</span>
</span><span class='line'><span class="cm">   profile. The number of bits for each component of a pixel is specified by</span>
</span><span class='line'><span class="cm">   `bitsPerComponent&#39;. The number of bytes per pixel is equal to</span>
</span><span class='line'><span class="cm">   `(bitsPerComponent * number of components + 7)/8&#39;. Each row of the bitmap</span>
</span><span class='line'><span class="cm">   consists of `bytesPerRow&#39; bytes, which must be at least `width * bytes</span>
</span><span class='line'><span class="cm">   per pixel&#39; bytes; in addition, `bytesPerRow&#39; must be an integer multiple</span>
</span><span class='line'><span class="cm">   of the number of bytes per pixel. `data&#39;, if non-NULL, points to a block</span>
</span><span class='line'><span class="cm">   of memory at least `bytesPerRow * height&#39; bytes. If `data&#39; is NULL, the</span>
</span><span class='line'><span class="cm">   data for context is allocated automatically and freed when the context is</span>
</span><span class='line'><span class="cm">   deallocated. `bitmapInfo&#39; specifies whether the bitmap should contain an</span>
</span><span class='line'><span class="cm">   alpha channel and how it&#39;s to be generated, along with whether the</span>
</span><span class='line'><span class="cm">   components are floating-point or integer. */</span>
</span><span class='line'><span class="n">CG_EXTERN</span> <span class="n">CGContextRef</span> <span class="n">__nullable</span> <span class="nf">CGBitmapContextCreate</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">__nullable</span> <span class="n">data</span><span class="p">,</span>
</span><span class='line'>    <span class="kt">size_t</span> <span class="n">width</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">height</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bitsPerComponent</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytesPerRow</span><span class="p">,</span>
</span><span class='line'>    <span class="n">CGColorSpaceRef</span> <span class="n">cg_nullable</span> <span class="n">space</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">bitmapInfo</span><span class="p">)</span>
</span><span class='line'>    <span class="n">CG_AVAILABLE_STARTING</span><span class="p">(</span><span class="n">__MAC_10_0</span><span class="p">,</span> <span class="n">__IPHONE_2_0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>顾名思义，这个函数用于创建一个位图上下文，用来绘制一张宽 <code>width</code> 像素，高 <code>height</code> 像素的位图。这个函数的注释比较长，参数也比较难理解，但是先别着急，我们先来了解下相关的知识，然后再回过头来理解这些参数，就会比较简单了。</p>

<h3>Pixel Format</h3>

<p>我们前面已经提到了，位图其实就是一个像素数组，而<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBECCFG">像素格式</a>则是用来描述每个像素的组成格式，它包括以下信息：</p>

<ul>
<li>Bits per component ：一个像素中每个独立的颜色分量使用的 bit 数；</li>
<li>Bits per pixel ：一个像素使用的总 bit 数；</li>
<li>Bytes per row ：位图中的每一行使用的字节数。</li>
</ul>


<p>有一点需要注意的是，对于位图来说，像素格式并不是随意组合的，目前只支持以下有限的 <a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-BCIBHHBB">17 种特定组合</a>：</p>

<p><img src="http://blog.leichunfeng.com/images/Supported Pixel Formats.png" width="738" /></p>

<p>从上图可知，对于 iOS 来说，只支持 8 种像素格式。其中颜色空间为 Null 的 1 种，Gray 的 2 种，RGB 的 5 种，CMYK 的 0 种。换句话说，iOS 并不支持 CMYK 的颜色空间。另外，在表格的第 2 列中，除了像素格式外，还指定了 bitmap information constant ，我们在后面会详细介绍。</p>

<h3>Color and Color Spaces</h3>

<p>在上面我们提到了<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_color/dq_color.html#//apple_ref/doc/uid/TP30001066-CH205-TPXREF101">颜色空间</a>，那么什么是颜色空间呢？它跟颜色有什么关系呢？在 Quartz 中，一个颜色是由一组值来表示的，比如 0, 0, 1 。而颜色空间则是用来说明如何解析这些值的，离开了颜色空间，它们将变得毫无意义。比如，下面的值都表示蓝色：</p>

<p><img src="http://blog.leichunfeng.com/images/blue_color.png" width="483" /></p>

<p>如果不知道颜色空间，那么我们根本无法知道这些值所代表的颜色。比如 0, 0, 1 在 RGB 下代表蓝色，而在 BGR 下则代表的是红色。在 RGB 和 BGR 两种颜色空间下，绿色是相同的，而红色和蓝色则相互对调了。因此，对于同一张图片，使用 RGB 和 BGR 两种颜色空间可能会得到两种不一样的效果：</p>

<p><img src="http://blog.leichunfeng.com/images/color_profiles.png" alt="color_profiles" /></p>

<p>是不是感觉非常有意思呢？</p>

<h3>Color Spaces and Bitmap Layout</h3>

<p>我们前面已经知道了，像素格式是用来描述每个像素的组成格式的，比如每个像素使用的总 bit 数。而要想确保 Quartz 能够正确地解析这些 bit 所代表的含义，我们还需要提供<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHEGIB">位图的布局信息</a> <code>CGBitmapInfo</code> ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">CF_OPTIONS</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">CGBitmapInfo</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">kCGBitmapAlphaInfoMask</span> <span class="o">=</span> <span class="mh">0x1F</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">kCGBitmapFloatInfoMask</span> <span class="o">=</span> <span class="mh">0xF00</span><span class="p">,</span>
</span><span class='line'>    <span class="n">kCGBitmapFloatComponents</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">kCGBitmapByteOrderMask</span>     <span class="o">=</span> <span class="n">kCGImageByteOrderMask</span><span class="p">,</span>
</span><span class='line'>    <span class="n">kCGBitmapByteOrderDefault</span>  <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">),</span>
</span><span class='line'>    <span class="n">kCGBitmapByteOrder16Little</span> <span class="o">=</span> <span class="n">kCGImageByteOrder16Little</span><span class="p">,</span>
</span><span class='line'>    <span class="n">kCGBitmapByteOrder32Little</span> <span class="o">=</span> <span class="n">kCGImageByteOrder32Little</span><span class="p">,</span>
</span><span class='line'>    <span class="n">kCGBitmapByteOrder16Big</span>    <span class="o">=</span> <span class="n">kCGImageByteOrder16Big</span><span class="p">,</span>
</span><span class='line'>    <span class="n">kCGBitmapByteOrder32Big</span>    <span class="o">=</span> <span class="n">kCGImageByteOrder32Big</span>
</span><span class='line'><span class="p">}</span> <span class="n">CG_AVAILABLE_STARTING</span><span class="p">(</span><span class="n">__MAC_10_0</span><span class="p">,</span> <span class="n">__IPHONE_2_0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>它主要提供了三个方面的布局信息：</p>

<ul>
<li>alpha 的信息；</li>
<li>颜色分量是否为浮点数；</li>
<li>像素格式的字节顺序。</li>
</ul>


<p>其中，alpha 的信息由枚举值 <code>CGImageAlphaInfo</code> 来表示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">CF_ENUM</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">CGImageAlphaInfo</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">kCGImageAlphaNone</span><span class="p">,</span>               <span class="cm">/* For example, RGB. */</span>
</span><span class='line'>    <span class="n">kCGImageAlphaPremultipliedLast</span><span class="p">,</span>  <span class="cm">/* For example, premultiplied RGBA */</span>
</span><span class='line'>    <span class="n">kCGImageAlphaPremultipliedFirst</span><span class="p">,</span> <span class="cm">/* For example, premultiplied ARGB */</span>
</span><span class='line'>    <span class="n">kCGImageAlphaLast</span><span class="p">,</span>               <span class="cm">/* For example, non-premultiplied RGBA */</span>
</span><span class='line'>    <span class="n">kCGImageAlphaFirst</span><span class="p">,</span>              <span class="cm">/* For example, non-premultiplied ARGB */</span>
</span><span class='line'>    <span class="n">kCGImageAlphaNoneSkipLast</span><span class="p">,</span>       <span class="cm">/* For example, RBGX. */</span>
</span><span class='line'>    <span class="n">kCGImageAlphaNoneSkipFirst</span><span class="p">,</span>      <span class="cm">/* For example, XRGB. */</span>
</span><span class='line'>    <span class="n">kCGImageAlphaOnly</span>                <span class="cm">/* No color data, alpha data only */</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的注释其实已经比较清楚了，它同样也提供了三个方面的 alpha 信息：</p>

<ul>
<li>是否包含 alpha ；</li>
<li>如果包含 alpha ，那么 alpha 信息所处的位置，在像素的<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E4%BD%8E%E6%9C%89%E6%95%88%E4%BD%8D">最低有效位</a>，比如 RGBA ，还是<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%AB%98%E6%9C%89%E6%95%88%E4%BD%8D">最高有效位</a>，比如 ARGB ；</li>
<li>如果包含 alpha ，那么每个颜色分量是否已经乘以 alpha 的值，这种做法可以加速图片的渲染时间，因为它避免了渲染时的额外乘法运算。比如，对于 RGB 颜色空间，用已经乘以 alpha 的数据来渲染图片，每个像素都可以避免 3 次乘法运算，红色乘以 alpha ，绿色乘以 alpha 和蓝色乘以 alpha 。</li>
</ul>


<p>那么我们在解压缩图片的时候应该使用哪个值呢？根据 <a href="http://stackoverflow.com/questions/23723564/which-cgimagealphainfo-should-we-use">Which CGImageAlphaInfo should we use</a> 和官方文档中对 <code>UIGraphicsBeginImageContextWithOptions</code> 函数的讨论：</p>

<blockquote><p>You use this function to configure the drawing environment for rendering into a bitmap. The format for the bitmap is a ARGB 32-bit integer pixel format using host-byte order. If the opaque parameter is YES, the alpha channel is ignored and the bitmap is treated as fully opaque (kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrder32Host). Otherwise, each pixel uses a premultipled ARGB format (kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host).</p></blockquote>

<p>我们可以知道，当图片不包含 alpha 的时候使用 <code>kCGImageAlphaNoneSkipFirst</code> ，否则使用 <code>kCGImageAlphaPremultipliedFirst</code> 。另外，这里也提到了字节顺序应该使用 32 位的主机字节顺序 <code>kCGBitmapByteOrder32Host</code> ，而这个值具体是什么，我们后面再讨论。</p>

<p>至于颜色分量是否为浮点数，这个就比较简单了，直接逻辑或 <code>kCGBitmapFloatComponents</code> 就可以了。更详细的内容就不展开了，因为我们一般用不上这个值。</p>

<p>接下来，我们来简单地了解下像素格式的<a href="https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/ByteOrdering.html#//apple_ref/doc/uid/20001150-CJBEJBHH">字节顺序</a>，它是由枚举值 <code>CGImageByteOrderInfo</code> 来表示的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">CF_ENUM</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">CGImageByteOrderInfo</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">kCGImageByteOrderMask</span>     <span class="o">=</span> <span class="mh">0x7000</span><span class="p">,</span>
</span><span class='line'>    <span class="n">kCGImageByteOrder16Little</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">),</span>
</span><span class='line'>    <span class="n">kCGImageByteOrder32Little</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">),</span>
</span><span class='line'>    <span class="n">kCGImageByteOrder16Big</span>    <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">),</span>
</span><span class='line'>    <span class="n">kCGImageByteOrder32Big</span>    <span class="o">=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="n">CG_AVAILABLE_STARTING</span><span class="p">(</span><span class="n">__MAC_10_12</span><span class="p">,</span> <span class="n">__IPHONE_10_0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>它主要提供了两个方面的字节顺序信息：</p>

<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.B0.8F.E7.AB.AF.E5.BA.8F">小端模式</a>还是<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F#.E5.A4.A7.E7.AB.AF.E5.BA.8F">大端模式</a>；</li>
<li>数据以 16 位还是 32 位为单位。</li>
</ul>


<p>对于 iPhone 来说，采用的是小端模式，但是为了保证应用的向后兼容性，我们可以使用系统提供的宏，来避免 <a href="https://en.wikipedia.org/wiki/Hard_coding">Hardcoding</a> ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#ifdef __BIG_ENDIAN__</span>
</span><span class='line'>    <span class="cp">#define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Big</span>
</span><span class='line'>    <span class="cp">#define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Big</span>
</span><span class='line'><span class="cp">#else </span><span class="cm">/* Little endian. */</span><span class="cp"></span>
</span><span class='line'>    <span class="cp">#define kCGBitmapByteOrder16Host kCGBitmapByteOrder16Little</span>
</span><span class='line'>    <span class="cp">#define kCGBitmapByteOrder32Host kCGBitmapByteOrder32Little</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>根据前面的讨论，我们知道字节顺序的值应该使用的是 32 位的主机字节顺序 <code>kCGBitmapByteOrder32Host</code> ，这样的话不管当前设备采用的是小端模式还是大端模式，字节顺序始终与其保持一致。</p>

<p>下面，我们来看一张图，它非常形象地展示了在使用 16 或 32 位像素格式的 CMYK 和 RGB 颜色空间下，一个像素是如何被表示的：</p>

<p><img src="http://blog.leichunfeng.com/images/pixel%20formats.png" alt="pixel formats" /></p>

<p>我们从图中可以看出，在 32 位像素格式下，每个颜色分量使用 8 位；而在 16 位像素格式下，每个颜色分量则使用 5 位。</p>

<p>好了，了解完这些相关知识后，我们再回过头来看看 <code>CGBitmapContextCreate</code> 函数中每个参数所代表的具体含义：</p>

<ul>
<li><code>data</code> ：如果不为 <code>NULL</code> ，那么它应该指向一块大小至少为 <code>bytesPerRow * height</code> 字节的内存；如果 为 <code>NULL</code> ，那么系统就会为我们自动分配和释放所需的内存，所以一般指定 <code>NULL</code> 即可；</li>
<li><code>width</code> 和 <code>height</code> ：位图的宽度和高度，分别赋值为图片的像素宽度和像素高度即可；</li>
<li><code>bitsPerComponent</code> ：像素的每个颜色分量使用的 bit 数，在 RGB 颜色空间下指定 8 即可；</li>
<li><code>bytesPerRow</code> ：位图的每一行使用的字节数，大小至少为 <code>width * bytes per pixel</code> 字节。有意思的是，当我们指定 0 时，系统不仅会为我们自动计算，而且还会进行 cache line alignment 的优化，更多信息可以查看 <a href="http://stackoverflow.com/questions/23790837/what-is-byte-alignment-cache-line-alignment-for-core-animation-why-it-matters">what is byte alignment (cache line alignment) for Core Animation? Why it matters?</a> 和 <a href="http://stackoverflow.com/questions/15935074/why-is-my-images-bytes-per-row-more-than-its-bytes-per-pixel-times-its-width">Why is my image&rsquo;s Bytes per Row more than its Bytes per Pixel times its Width?</a> ，亲测可用；</li>
<li><code>space</code> ：就是我们前面提到的颜色空间，一般使用 RGB 即可；</li>
<li><code>bitmapInfo</code> ：就是我们前面提到的位图的布局信息。</li>
</ul>


<p>到这里，你已经掌握了强制解压缩图片需要用到的最核心的函数，点个赞。</p>

<h2>开源库的实现</h2>

<p>接下来，我们来看看在三个比较流行的开源库 <a href="https://github.com/ibireme/YYKit">YYKit</a> 、<a href="https://github.com/rs/SDWebImage">SDWebImage</a> 和 <a href="https://github.com/Flipboard/FLAnimatedImage">FLAnimatedImage</a> 中，对图片的强制解压缩是如何实现的。</p>

<p>首先，我们来看看 YYKit 中的相关代码，用于解压缩图片的函数 <code>YYCGImageCreateDecodedCopy</code> 存在于 <a href="https://github.com/ibireme/YYKit/blob/master/YYKit/Image/YYImageCoder.m">YYImageCoder</a> 类中，核心代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CGImageRef</span> <span class="nf">YYCGImageCreateDecodedCopy</span><span class="p">(</span><span class="n">CGImageRef</span> <span class="n">imageRef</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="n">decodeForDisplay</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">decodeForDisplay</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// decode with redraw (may lose some precision)</span>
</span><span class='line'>        <span class="n">CGImageAlphaInfo</span> <span class="n">alphaInfo</span> <span class="o">=</span> <span class="n">CGImageGetAlphaInfo</span><span class="p">(</span><span class="n">imageRef</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">kCGBitmapAlphaInfoMask</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">BOOL</span> <span class="n">hasAlpha</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">alphaInfo</span> <span class="o">==</span> <span class="n">kCGImageAlphaPremultipliedLast</span> <span class="o">||</span>
</span><span class='line'>            <span class="n">alphaInfo</span> <span class="o">==</span> <span class="n">kCGImageAlphaPremultipliedFirst</span> <span class="o">||</span>
</span><span class='line'>            <span class="n">alphaInfo</span> <span class="o">==</span> <span class="n">kCGImageAlphaLast</span> <span class="o">||</span>
</span><span class='line'>            <span class="n">alphaInfo</span> <span class="o">==</span> <span class="n">kCGImageAlphaFirst</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">hasAlpha</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// BGRA8888 (premultiplied) or BGRX8888</span>
</span><span class='line'>        <span class="c1">// same as UIGraphicsBeginImageContext() and -[UIView drawRect:]</span>
</span><span class='line'>        <span class="n">CGBitmapInfo</span> <span class="n">bitmapInfo</span> <span class="o">=</span> <span class="n">kCGBitmapByteOrder32Host</span><span class="p">;</span>
</span><span class='line'>        <span class="n">bitmapInfo</span> <span class="o">|=</span> <span class="n">hasAlpha</span> <span class="o">?</span> <span class="nl">kCGImageAlphaPremultipliedFirst</span> <span class="p">:</span> <span class="n">kCGImageAlphaNoneSkipFirst</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">CGContextRef</span> <span class="n">context</span> <span class="o">=</span> <span class="n">CGBitmapContextCreate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">YYCGColorSpaceGetDeviceRGB</span><span class="p">(),</span> <span class="n">bitmapInfo</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">context</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">CGContextDrawImage</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="n">imageRef</span><span class="p">);</span> <span class="c1">// decode</span>
</span><span class='line'>        <span class="n">CGImageRef</span> <span class="n">newImage</span> <span class="o">=</span> <span class="n">CGBitmapContextCreateImage</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
</span><span class='line'>        <span class="n">CFRelease</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">newImage</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>它接受一个原始的位图参数 <code>imageRef</code> ，最终返回一个新的解压缩后的位图 <code>newImage</code> ，中间主要经过了以下三个步骤：</p>

<ul>
<li>使用 <code>CGBitmapContextCreate</code> 函数创建一个位图上下文；</li>
<li>使用 <code>CGContextDrawImage</code> 函数将原始位图绘制到上下文中；</li>
<li>使用 <code>CGBitmapContextCreateImage</code> 函数创建一张新的解压缩后的位图。</li>
</ul>


<p>事实上，SDWebImage 和 FLAnimatedImage 中对图片的解压缩过程与上述完全一致，只是传递给 <code>CGBitmapContextCreate</code> 函数的部分参数存在细微的差别，如下表所示：</p>

<p><img src="http://blog.leichunfeng.com/images/CGBitmapContextCreate.png" width="720" /></p>

<p>在上表中，用浅绿色背景标记的参数即为我们在前面的分析中所推荐的参数，用这些参数解压缩后的图片渲染的速度会更快。因此，从理论上说 YYKit 中的解压缩算法是三者之中最优的。</p>

<h2>性能对比</h2>

<p>口说无凭，因此我编写了一个小的测试程序，来简单地对比一下这三个开源库的解压缩性能，源码可以在 <a href="https://github.com/leichunfeng/Image-Decompression-Benchmark">GitHub</a> 上找到。</p>

<p>采用的测试样例分别为 5 张 PNG 图片和 5 张 JPEG 图片，像素依次为 128x96 、256x192 、512x384 、1024x768 和 2048x1536 ，它们其实都长一个样：</p>

<p><img src="http://blog.leichunfeng.com/images/128x96.png" alt="128x96" /></p>

<p>首先，我们来了解下测试的原理，我们可以将从磁盘加载一张图片到最终渲染到屏幕上的过程划分为三个阶段：</p>

<ul>
<li>初始化阶段：从磁盘初始化图片，生成一个未解压缩的 <code>UIImage</code> 对象；</li>
<li>解压缩阶段：分别使用 YYKit 、SDWebImage 和 FLAnimatedImage 对第 1 步中得到的 <code>UIImage</code> 对象进行解压缩，得到一个新的解压缩后的 <code>UIImage</code> 对象；</li>
<li>绘制阶段：将第 2 步中得到的 <code>UIImage</code> 对象绘制到屏幕上。</li>
</ul>


<p>这里我们以绘制阶段的耗时为依据来评测解压缩的性能，解压缩的算法越优秀，那么得到的图片就越符合系统渲染时的需求，绘制的时间也就越短。为了让测试的结果更准确，我们对每张图片都解压缩 10 次，然后取平均值。说明，本次使用的测试设备是 iPhone 5s 。</p>

<p>首先，我们来看看解压缩 PNG 图片的测试结果：</p>

<p><img src="http://blog.leichunfeng.com/images/decompress_png_compare.png" width="320" /></p>

<p>相应的柱状图如下：</p>

<p><img src="http://blog.leichunfeng.com/images/decompress_png.png" width="600" /></p>

<p>从上图可以看出，就我们采用的测试样例来说，解压缩 PNG 图片的性能 SDWebImage 最好，FLAnimatedImage 次之，YYKit 最差。这与我们前面的理论结果有一定的差距，可能是测试样例太少，也可能这就是真实结果。另外，需要说明的是，我们这里使用的 PNG 图片都是不带 alpha 值，因为 SDWebImage 不支持解压缩带 alpha 值的 PNG 图片。</p>

<p>接着，我们再来看看解压缩 JPEG 图片的测试结果：</p>

<p><img src="http://blog.leichunfeng.com/images/decompress_jpeg_compare.png" width="320" /></p>

<p>相应的柱状图如下：</p>

<p><img src="http://blog.leichunfeng.com/images/decompress_jpeg.png" width="600" /></p>

<p>这次 YYKit 终于翻盘了，解压缩 JPEG 图片的性能最好，SDWebImage 和 FLAnimatedImage 并列第二。</p>

<h2>总结</h2>

<p>其实，要理解 iOS 中图片的解压缩并不难，重点是要理解位图的概念。而图片解压缩的过程其实就是将图片的二进制数据转换成像素数据的过程。了解这些知识，将有助于我们更好地处理图片，管理好它们所占用的内存。</p>

<h2>参考链接</h2>

<p><a href="https://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/">https://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/</a>
<br>
<a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html">https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html</a>
<br>
<a href="https://github.com/path/FastImageCache">https://github.com/path/FastImageCache</a>
<br>
<a href="http://stackoverflow.com/questions/23790837/what-is-byte-alignment-cache-line-alignment-for-core-animation-why-it-matters">http://stackoverflow.com/questions/23790837/what-is-byte-alignment-cache-line-alignment-for-core-animation-why-it-matters</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Fast Enumeration 的实现原理]]></title>
    <link href="http://leichunfeng.github.io/blog/2016/06/20/objective-c-fast-enumeration-implementation-principle/"/>
    <updated>2016-06-20T20:30:53+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2016/06/20/objective-c-fast-enumeration-implementation-principle</id>
    <content type="html"><![CDATA[<p>在 Objective-C 2.0 中提供了快速枚举的语法，它是我们遍历集合元素的首选方法，因为它具有以下优点：</p>

<ul>
<li>比直接使用 <code>NSEnumerator</code> 更高效；</li>
<li>语法非常简洁；</li>
<li>如果集合在遍历的过程中被修改，它会抛出异常；</li>
<li>可以同时执行多个枚举。</li>
</ul>


<p>那么问题来了，它是如何做到的呢？我想，你应该也跟我一样，对 Objective-C 中快速枚举的实现原理非常感兴趣，事不宜迟，让我们来一探究竟吧。</p>

<h2>解析 NSFastEnumeration 协议</h2>

<p>在 Objective-C 中，我们要想实现快速枚举就必须要实现 <a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/NSFastEnumeration_protocol/Reference/NSFastEnumeration.html">NSFastEnumeration</a> 协议，在这个协议中，只声明了一个必须实现的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> Returns by reference a C array of objects over which the sender should iterate, and as the return value the number of objects in the array.</span>
</span><span class='line'>
</span><span class='line'><span class="cm"> @param state  Context information that is used in the enumeration to, in addition to other possibilities, ensure that the collection has not been mutated.</span>
</span><span class='line'><span class="cm"> @param buffer A C array of objects over which the sender is to iterate.</span>
</span><span class='line'><span class="cm"> @param len    The maximum number of objects to return in stackbuf.</span>
</span><span class='line'><span class="cm"> </span>
</span><span class='line'><span class="cm"> @discussion The state structure is assumed to be of stack local memory, so you can recast the passed in state structure to one more suitable for your iteration.</span>
</span><span class='line'>
</span><span class='line'><span class="cm"> @return The number of objects returned in stackbuf. Returns 0 when the iteration is finished.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSUInteger</span><span class="p">)</span><span class="nf">countByEnumeratingWithState:</span><span class="p">(</span><span class="n">NSFastEnumerationState</span> <span class="o">*</span><span class="p">)</span><span class="nv">state</span>
</span><span class='line'>                                  <span class="nf">objects:</span><span class="p">(</span><span class="kt">id</span> <span class="n">__unsafe_unretained</span> <span class="p">[])</span><span class="nv">stackbuf</span>
</span><span class='line'>                                    <span class="nf">count:</span><span class="p">(</span><span class="bp">NSUInteger</span><span class="p">)</span><span class="nv">len</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中，结构体 <code>NSFastEnumerationState</code> 的定义如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">__unsafe_unretained</span> <span class="n">__nullable</span> <span class="o">*</span> <span class="n">__nullable</span> <span class="n">itemsPtr</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span> <span class="n">__nullable</span> <span class="n">mutationsPtr</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">extra</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span> <span class="n">NSFastEnumerationState</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>说实话，刚开始看到这个方法的时候，其实我是拒绝的，原因你懂的。好吧，先不吐槽了，言归正传，下面，我们将对这个方法进行全方位的剖析：</p>

<p>首先，我们需要了解的最重要的一点，那就是这个方法的目的是什么？概括地说，这个方法就是用于返回一系列的 C 数组，以供调用者进行遍历。为什么是一系列的 C 数组呢？因为，在一个 <code>for/in</code> 循环中，这个方法其实会被调用多次，每一次调用都会返回一个 C 数组。至于为什么是 C 数组，那当然是为了提高效率了。</p>

<p>既然要返回 C 数组，也就意味着我们需要返回一个数组的指针和数组的长度。是的，我想你应该已经猜到了，数组的长度就是通过这个方法的返回值来提供的，而数组的指针则是通过结构体 <code>NSFastEnumerationState</code> 的 <code>itemsPtr</code> 字段进行返回的。所以，这两个值就一起定义了这个方法返回的 C 数组。</p>

<p>通常来说，<code>NSFastEnumeration</code> 允许我们直接返回一个指向内部存储的指针，但是并非所有的数据结构都能够满足内存连续的要求。因此，<code>NSFastEnumeration</code> 还为我们提供了另外一种实现方案，我们可以将元素拷贝到调用者提供的一个 C 数组上，即 <code>stackbuf</code> ，它的长度由参数 <code>len</code> 指定。</p>

<p>在本文的开头，我们提到了如果集合在遍历的过程中被修改的话，<code>NSFastEnumeration</code> 就会抛出异常。而这个功能就是通过 <code>mutationsPtr</code> 字段来实现的，它指向一个这样的值，这个值在集合被修改时会发现改变。因此，我们就可以利用它来判断集合在遍历的过程中是否被修改。</p>

<p>现在，我们还剩下 <code>NSFastEnumerationState</code> 中的 <code>state</code> 和 <code>extra</code> 字段没有进行介绍。实际上，它们是调用者提供给被调用者自由使用的两个字段，调用者根本不关心这两个字段的值。因此，我们可以利用它们来存储任何对自身有用的值。</p>

<h2>揭密快速枚举的内部实现</h2>

<p>说了这么多，感觉好像 <code>NSFastEnumeration</code> 是你设计的一样，你到底是怎么知道的呢？额，我说我是瞎猜的，你信么？好了，不开玩笑了。接下来，我们就一起来探究一下快速枚举的内部实现。假设，我们有一个 <code>main.m</code> 文件，其中的代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="l">@[</span> <span class="mi">@1</span><span class="p">,</span> <span class="mi">@2</span><span class="p">,</span> <span class="mi">@3</span> <span class="l">]</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="n">number</span> <span class="k">in</span> <span class="n">array</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">([</span><span class="n">number</span> <span class="nl">isEqualToNumber</span><span class="p">:</span><span class="mi">@1</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>接着，我们使用下面的 clang 命令将 <code>main.m</code> 文件重写成 C++ 代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">clang</span> <span class="o">-</span><span class="n">rewrite</span><span class="o">-</span><span class="n">objc</span> <span class="n">main</span><span class="p">.</span><span class="n">m</span>
</span></code></pre></td></tr></table></div></figure>


<p>得到 <code>main.cpp</code> 文件，其中 <code>main</code> 函数的代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 创建数组 @[ @1, @2, @3 ]</span>
</span><span class='line'>    <span class="bp">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="p">((</span><span class="bp">NSArray</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">Class</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">,</span> <span class="k">const</span> <span class="n">ObjectType</span> <span class="o">*</span><span class="p">,</span> <span class="bp">NSUInteger</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;NSArray&quot;</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;arrayWithObjects:count:&quot;</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span> <span class="kt">id</span> <span class="o">*</span><span class="p">)</span><span class="n">__NSContainer_literal</span><span class="p">(</span><span class="mi">3U</span><span class="p">,</span> <span class="p">((</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">Class</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">,</span> <span class="kt">int</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;NSNumber&quot;</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;numberWithInt:&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="p">((</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">Class</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">,</span> <span class="kt">int</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;NSNumber&quot;</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;numberWithInt:&quot;</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="p">((</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">Class</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">,</span> <span class="kt">int</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;NSNumber&quot;</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;numberWithInt:&quot;</span><span class="p">),</span> <span class="mi">3</span><span class="p">)).</span><span class="n">arr</span><span class="p">,</span> <span class="mi">3U</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="bp">NSNumber</span> <span class="o">*</span> <span class="n">number</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 初始化结构体 NSFastEnumerationState</span>
</span><span class='line'>        <span class="k">struct</span> <span class="n">__objcFastEnumerationState</span> <span class="n">enumState</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 初始化数组 stackbuf</span>
</span><span class='line'>        <span class="kt">id</span> <span class="n">__rw_items</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">id</span> <span class="n">l_collection</span> <span class="o">=</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span> <span class="n">array</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 第一次调用 - countByEnumeratingWithState:objects:count: 方法，形参和实参的对应关系如下：</span>
</span><span class='line'>        <span class="c1">// state -&gt; &amp;enumState</span>
</span><span class='line'>        <span class="c1">// stackbuf -&gt; __rw_items</span>
</span><span class='line'>        <span class="c1">// len -&gt; 16</span>
</span><span class='line'>        <span class="n">_WIN_NSUInteger</span> <span class="n">limit</span> <span class="o">=</span>
</span><span class='line'>            <span class="p">((</span><span class="n">_WIN_NSUInteger</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__objcFastEnumerationState</span> <span class="o">*</span><span class="p">,</span> <span class="kt">id</span> <span class="o">*</span><span class="p">,</span> <span class="n">_WIN_NSUInteger</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)</span>
</span><span class='line'>            <span class="p">((</span><span class="kt">id</span><span class="p">)</span><span class="n">l_collection</span><span class="p">,</span>
</span><span class='line'>            <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;countByEnumeratingWithState:objects:count:&quot;</span><span class="p">),</span>
</span><span class='line'>            <span class="o">&amp;</span><span class="n">enumState</span><span class="p">,</span> <span class="p">(</span><span class="kt">id</span> <span class="o">*</span><span class="p">)</span><span class="n">__rw_items</span><span class="p">,</span> <span class="p">(</span><span class="n">_WIN_NSUInteger</span><span class="p">)</span><span class="mi">16</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 获取 mutationsPtr 的初始值</span>
</span><span class='line'>            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">startMutations</span> <span class="o">=</span> <span class="o">*</span><span class="n">enumState</span><span class="p">.</span><span class="n">mutationsPtr</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// 外层的 do/while 循环，用于调用 - countByEnumeratingWithState:objects:count: 方法，获取 C 数组</span>
</span><span class='line'>            <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>                <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>                <span class="c1">// 内层的 do/while 循环，用于遍历获取到的 C 数组</span>
</span><span class='line'>                <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>                    <span class="c1">// 判断 mutationsPtr 的值是否有发生变化，如果有则使用 objc_enumerationMutation 函数抛出异常</span>
</span><span class='line'>                    <span class="k">if</span> <span class="p">(</span><span class="n">startMutations</span> <span class="o">!=</span> <span class="o">*</span><span class="n">enumState</span><span class="p">.</span><span class="n">mutationsPtr</span><span class="p">)</span> <span class="n">objc_enumerationMutation</span><span class="p">(</span><span class="n">l_collection</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>                    <span class="c1">// 使用指针的算术运算获取相应的集合元素，这是快速枚举之所以高效的关键所在</span>
</span><span class='line'>                    <span class="n">number</span> <span class="o">=</span> <span class="p">(</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="p">)</span><span class="n">enumState</span><span class="p">.</span><span class="n">itemsPtr</span><span class="p">[</span><span class="n">counter</span><span class="o">++</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>                    <span class="p">{</span>
</span><span class='line'>                        <span class="k">if</span> <span class="p">(((</span><span class="kt">BOOL</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">,</span> <span class="bp">NSNumber</span> <span class="o">*</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)</span><span class="n">number</span><span class="p">,</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;isEqualToNumber:&quot;</span><span class="p">),</span> <span class="p">((</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">Class</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">,</span> <span class="kt">int</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;NSNumber&quot;</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;numberWithInt:&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
</span><span class='line'>                            <span class="c1">// continue 语句的实现，使用 goto 语句无条件转移到内层 do 语句的末尾，跳过中间的所有代码</span>
</span><span class='line'>                            <span class="k">goto</span> <span class="n">__continue_label_1</span><span class="p">;</span>
</span><span class='line'>                        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>                        <span class="n">NSLog</span><span class="p">((</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_cr_xxw2w3rd5_n493ggz9_l4bcw0000gn_T_main_fc7b79_mi_0</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>                        <span class="c1">// break 语句的实现，使用 goto 语句无条件转移到最外层 if 语句的末尾，跳出嵌套的两层循环</span>
</span><span class='line'>                        <span class="k">goto</span> <span class="n">__break_label_1</span><span class="p">;</span>
</span><span class='line'>                    <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>                    <span class="c1">// goto 语句标号，用来实现 continue 语句</span>
</span><span class='line'>                    <span class="nl">__continue_label_1</span><span class="p">:</span> <span class="p">;</span>
</span><span class='line'>                <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">counter</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">limit</span> <span class="o">=</span>
</span><span class='line'>                <span class="p">((</span><span class="n">_WIN_NSUInteger</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__objcFastEnumerationState</span> <span class="o">*</span><span class="p">,</span> <span class="kt">id</span> <span class="o">*</span><span class="p">,</span> <span class="n">_WIN_NSUInteger</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)</span>
</span><span class='line'>                <span class="p">((</span><span class="kt">id</span><span class="p">)</span><span class="n">l_collection</span><span class="p">,</span>
</span><span class='line'>                <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;countByEnumeratingWithState:objects:count:&quot;</span><span class="p">),</span>
</span><span class='line'>                <span class="o">&amp;</span><span class="n">enumState</span><span class="p">,</span> <span class="p">(</span><span class="kt">id</span> <span class="o">*</span><span class="p">)</span><span class="n">__rw_items</span><span class="p">,</span> <span class="p">(</span><span class="n">_WIN_NSUInteger</span><span class="p">)</span><span class="mi">16</span><span class="p">)));</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">number</span> <span class="o">=</span> <span class="p">((</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// goto 语句标号，用来实现 break 语句</span>
</span><span class='line'>            <span class="nl">__break_label_1</span><span class="p">:</span> <span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">number</span> <span class="o">=</span> <span class="p">((</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上代码所示，快速枚举其实就是用两层 <code>do/while</code> 循环来实现的，外层循环负责调用 <code>- countByEnumeratingWithState:objects:count:</code> 方法，获取 C 数组，而内层循环则负责遍历获取到的 C 数组。同时，我想你应该也注意到了它是如何利用 <code>mutationsPtr</code> 来检测集合在遍历过程中的突变的，以及使用 <a href="https://developer.apple.com/reference/objectivec/1418744-objc_enumerationmutation?language=objc">objc_enumerationMutation</a> 函数来抛出异常。</p>

<p>正如我们前面提到的，在快速枚举的实现中，确实没有用到结构体 <code>NSFastEnumerationState</code> 中的 <code>state</code> 和 <code>extra</code> 字段，它们只是提供给 <code>- countByEnumeratingWithState:objects:count:</code> 方法的实现者自由使用的字段。</p>

<p>值得一提的是，我特意在 <code>main.m</code> 中加入了 <code>continue</code> 和 <code>break</code> 语句。因此，我们有机会看到了在 <code>for/in</code> 语句中是如何利用 goto 来实现 <code>continue</code> 和 <code>break</code> 语句的。</p>

<h2>实现 NSFastEnumeration 协议</h2>

<p>看到这里，我相信你对 Objective-C 中快速枚举的实现原理已经有了一个比较清晰地认识。下面，我们就一起来动手实现一下 <code>NSFastEnumeration</code> 协议。</p>

<p>我们前面已经提到了，<code>NSFastEnumeration</code> 在设计上允许我们使用两种不同的方式来实现它。如果集合中的元素在内存上是连续的，那么我们可以直接返回这段内存的首地址；如果不连续，比如链表，就只能使用调用者提供的 C 数组 <code>stackbuf</code> 了，将我们的元素拷贝到这个 C 数组上。</p>

<p>接下来，我们将通过一个自定义的集合类 <code>Array</code> ，来演示这两种不同的实现 <code>NSFastEnumeration</code> 协议的方式。<strong>注</strong>：完整的项目代码可以在<a href="https://github.com/leichunfeng/FastEnumerationSample">这里</a>找到。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">Array</span> : <span class="bp">NSObject</span> <span class="o">&lt;</span><span class="bp">NSFastEnumeration</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nl">initWithCapacity</span><span class="p">:(</span><span class="bp">NSUInteger</span><span class="p">)</span><span class="n">numItems</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Array</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="bp">NSNumber</span> <span class="o">*&gt;</span> <span class="n">_list</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithCapacity:</span><span class="p">(</span><span class="bp">NSUInteger</span><span class="p">)</span><span class="nv">numItems</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="bp">NSUInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numItems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="l">@(</span><span class="n">random</span><span class="p">()</span><span class="l">)</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#define USE_STACKBUF 1</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSUInteger</span><span class="p">)</span><span class="nf">countByEnumeratingWithState:</span><span class="p">(</span><span class="n">NSFastEnumerationState</span> <span class="o">*</span><span class="p">)</span><span class="nv">state</span> <span class="nf">objects:</span><span class="p">(</span><span class="kt">id</span> <span class="n">__unsafe_unretained</span> <span class="p">[])</span><span class="nv">stackbuf</span> <span class="nf">count:</span><span class="p">(</span><span class="bp">NSUInteger</span><span class="p">)</span><span class="nv">len</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 这个方法的返回值，即我们需要返回的 C 数组的长度</span>
</span><span class='line'>    <span class="bp">NSUInteger</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 我们前面已经提到了，这个方法是会被多次调用的</span>
</span><span class='line'>    <span class="c1">// 因此，我们需要使用 state-&gt;state 来保存当前遍历到了 _list 的什么位置</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">countOfItemsAlreadyEnumerated</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 当 countOfItemsAlreadyEnumerated 为 0 时，表示第一次调用这个方法</span>
</span><span class='line'>    <span class="c1">// 我们可以在这里做一些初始化的设置</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">countOfItemsAlreadyEnumerated</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 我们前面已经提到了，state-&gt;mutationsPtr 是用来追踪集合在遍历过程中的突变的</span>
</span><span class='line'>        <span class="c1">// 它不能为 NULL ，并且也不应该指向 self</span>
</span><span class='line'>        <span class="c1">//</span>
</span><span class='line'>        <span class="c1">// 这里，因为我们的 Array 类是不可变的，所以我们不需要追踪它的突变</span>
</span><span class='line'>        <span class="c1">// 因此，我们的做法是将它指向 state-&gt;extra 的其中一个值</span>
</span><span class='line'>        <span class="c1">// 因为我们知道 NSFastEnumeration 协议本身并没有用到 state-&gt;extra</span>
</span><span class='line'>        <span class="c1">//</span>
</span><span class='line'>        <span class="c1">// 但是，如果你的集合是可变的，那么你可以考虑将 state-&gt;mutationsPtr 指向一个内部变量</span>
</span><span class='line'>        <span class="c1">// 而这个内部变量的值会在你的集合突变时发生变化</span>
</span><span class='line'>        <span class="n">state</span><span class="o">-&gt;</span><span class="n">mutationsPtr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">extra</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#if USE_STACKBUF</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 判断我们是否已经遍历完 _list</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">countOfItemsAlreadyEnumerated</span> <span class="o">&lt;</span> <span class="n">_list</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 我们知道 state-&gt;itemsPtr 就是这个方法返回的 C 数组指针，它不能为 NULL</span>
</span><span class='line'>        <span class="c1">// 在这里，我们将 state-&gt;itemsPtr 指向调用者提供的 C 数组 stackbuf</span>
</span><span class='line'>        <span class="n">state</span><span class="o">-&gt;</span><span class="n">itemsPtr</span> <span class="o">=</span> <span class="n">stackbuf</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 将 _list 中的元素填充到 stackbuf 中，直到以下两个条件中的任意一个满足时为止</span>
</span><span class='line'>        <span class="c1">// 1. 已经遍历完 _list 中的所有元素</span>
</span><span class='line'>        <span class="c1">// 2. 已经填充满 stackbuf</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span><span class="n">countOfItemsAlreadyEnumerated</span> <span class="o">&lt;</span> <span class="n">_list</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 取出 _list 中的元素填充到 stackbuf 中</span>
</span><span class='line'>            <span class="n">stackbuf</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">_list</span><span class="p">[</span><span class="n">countOfItemsAlreadyEnumerated</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// 更新我们的遍历位置</span>
</span><span class='line'>            <span class="n">countOfItemsAlreadyEnumerated</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// 更新我们返回的 C 数组的长度，使之与 state-&gt;itemsPtr 中的元素个数相匹配</span>
</span><span class='line'>            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 判断我们是否已经遍历完 _list</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">countOfItemsAlreadyEnumerated</span> <span class="o">&lt;</span> <span class="n">_list</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 直接将 state-&gt;itemsPtr 指向内部的 C 数组指针，因为它的内存地址是连续的</span>
</span><span class='line'>        <span class="n">__unsafe_unretained</span> <span class="k">const</span> <span class="kt">id</span> <span class="o">*</span> <span class="n">const_array</span> <span class="o">=</span> <span class="n">_list</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
</span><span class='line'>        <span class="n">state</span><span class="o">-&gt;</span><span class="n">itemsPtr</span> <span class="o">=</span> <span class="p">(</span><span class="n">__typeof__</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">itemsPtr</span><span class="p">))</span><span class="n">const_array</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 因为我们一次性返回了 _list 中的所有元素</span>
</span><span class='line'>        <span class="c1">// 所以，countOfItemsAlreadyEnumerated 和 count 的值均为 _list 中的元素个数</span>
</span><span class='line'>        <span class="n">countOfItemsAlreadyEnumerated</span> <span class="o">=</span> <span class="n">_list</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span><span class='line'>        <span class="n">count</span> <span class="o">=</span> <span class="n">_list</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 将本次调用得到的 countOfItemsAlreadyEnumerated 保存到 state-&gt;state 中</span>
</span><span class='line'>    <span class="c1">// 因为 NSFastEnumeration 协议本身并没有用到 state-&gt;state</span>
</span><span class='line'>    <span class="c1">// 所以，我们可以将这个值保留到下一次调用</span>
</span><span class='line'>    <span class="n">state</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">countOfItemsAlreadyEnumerated</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 返回 C 数组的长度</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>我已经在上面的代码中添加了必要的注释，相信你理解起来应该没有什么难度。不过，值得一提的是，在第二种方式的实现中，我们用到了 ARC 下不同所有权对象之间的相互转换，代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">__unsafe_unretained</span> <span class="k">const</span> <span class="kt">id</span> <span class="o">*</span> <span class="n">const_array</span> <span class="o">=</span> <span class="n">_list</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
</span><span class='line'><span class="n">state</span><span class="o">-&gt;</span><span class="n">itemsPtr</span> <span class="o">=</span> <span class="p">(</span><span class="n">__typeof__</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">itemsPtr</span><span class="p">))</span><span class="n">const_array</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实，这里面涉及到两次类型转换，第一次是从 <code>__strong NSNumber *</code> 类型转换到 <code>__unsafe_unretained const id *</code> 类型，第二次是从 <code>__unsafe_unretained const id *</code> 类型转换到 <code>id __unsafe_unretained *</code> 类型，更多信息可以查看 <a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">AutomaticReferenceCounting</a> 中的 4.3.3 小节。</p>

<p>另外，我在前面的文章<a href="http://blog.leichunfeng.com/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/">《ReactiveCocoa v2.5 源码解析之架构总览》</a>中，已经有提到过，<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/tree/v2.5">ReactiveCocoa</a> 中的 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/ReactiveCocoa/RACSequence.m">RACSequence</a> 类其实是实现了 <code>NSFastEnumeration</code> 协议的。因为 <code>RACSequence</code> 中的元素在内存上并不连续，所以它采用的是第一种实现方式。对此感兴趣的同学，可以去看看它的实现源码，这里不再赘述。</p>

<h2>总结</h2>

<p>本文从 <code>NSFastEnumeration</code> 协议的定义出发，解析了 <code>- countByEnumeratingWithState:objects:count:</code> 方法中的返回值以及各个参数的含义；接着，我们使用 <code>clang -rewrite-objc</code> 命令探究了快速枚举的内部实现；最后，通过一个自定义的集合类 <code>Array</code> 演示了两种实现 <code>NSFastEnumeration</code> 协议的方式，希望本文能够对你有所帮助。</p>

<h2>参考链接</h2>

<p><a href="https://www.mikeash.com/pyblog/friday-qa-2010-04-16-implementing-fast-enumeration.html">https://www.mikeash.com/pyblog/friday-qa-2010-04-16-implementing-fast-enumeration.html</a>
<a href="https://zh.wikipedia.org/wiki/Objective-C#.E5.BF.AB.E9.80.9F.E6.9E.9A.E4.B8.BE">https://zh.wikipedia.org/wiki/Objective-C#.E5.BF.AB.E9.80.9F.E6.9E.9A.E4.B8.BE</a>
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Collections/Articles/Enumerators.html#//apple_ref/doc/uid/20000135-SW1">https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Collections/Articles/Enumerators.html#//apple_ref/doc/uid/20000135-SW1</a></p>

<p><strong>版权声明</strong>：我已将本文在微信公众平台的发表权「独家代理」给 iOS 开发（iOSDevTips）微信公众号。扫下方二维码即可关注「iOS 开发」：</p>

<p><img src="http://blog.devtang.com/images/weixin-qr.jpg" alt="iOS 开发二维码" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MVVM With ReactiveCocoa]]></title>
    <link href="http://leichunfeng.github.io/blog/2016/02/27/mvvm-with-reactivecocoa/"/>
    <updated>2016-02-27T22:17:12+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2016/02/27/mvvm-with-reactivecocoa</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel">MVVM</a> 是一种软件架构模式，它是 <a href="https://en.wikipedia.org/wiki/Martin_Fowler">Martin Fowler</a> 的 <a href="http://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> 的一种变体，最先由微软的架构师 John Gossman 在 2005 年提出，并应用在微软的 <a href="https://en.wikipedia.org/wiki/Windows_Presentation_Foundation">WPF</a> 和 <a href="https://en.wikipedia.org/wiki/Microsoft_Silverlight">Silverlight</a> 软件开发中。<code>MVVM</code> 衍生于 <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a> ，是对 <code>MVC</code> 的一种演进，它促进了 <code>UI</code> 代码与业务逻辑的分离。</p>

<p><strong>说明</strong>：本文将采用理论与实践相结合的方式，重点介绍一个使用 <code>MVVM</code> 和 <code>RAC</code> 开发的 <code>iOS</code> 开源项目 <a href="https://github.com/leichunfeng/MVVMReactiveCocoa">MVVMReactiveCocoa</a> ，目的是希望能为你实践 <code>MVVM</code> 提供帮助。不过，在正式开始介绍正文之前，请你先思考以下三个问题：</p>

<ul>
<li><code>MVC</code> 与 <code>MVVM</code> 有什么异同点，<code>MVC</code> 到 <code>MVVM</code> 是怎样演进的；</li>
<li><code>RAC</code> 在 <code>MVVM</code> 中扮演什么样的角色，<code>MVVM</code> 是否一定要结合 <code>RAC</code> 使用；</li>
<li>如何将一个现有的 <code>MVC</code> 应用转变成一个 <code>MVVM</code> 应用，有哪些需要注意的地方。</li>
</ul>


<p>带着以上问题，我们一起进入正文。</p>

<p><strong>名词解释</strong>：本文中的 <code>RAC</code> 为 <code>ReactiveCocoa</code> 的缩写。</p>

<h2>MVC</h2>

<p><code>MVC</code> 是 <code>iOS</code> 开发中使用最普遍的架构模式，同时也是苹果官方推荐的架构模式。<code>MVC</code> 代表的是 <code>Model–view–controller</code> ，它们之间的关系如下：</p>

<p><img src="http://blog.leichunfeng.com/images/M-V-C.png" width="409" /></p>

<p>是的，<code>MVC</code> 看上去棒极了，<code>model</code> 代表数据，<code>view</code> 代表 <code>UI</code> ，而 <code>controller</code> 则负责协调它们两者之间的关系。然而，尽管从技术上看 <code>view</code> 和 <code>controller</code> 是相互独立的，但事实上它们几乎总是结对出现，一个 <code>view</code> 只能与一个 <code>controller</code> 进行匹配，反之亦然。既然如此，那我们为何不将它们看作一个整体呢：</p>

<p><img src="http://blog.leichunfeng.com/images/M-VC.png" width="409" /></p>

<p>因此，<code>M-VC</code> 可能是对 <code>iOS</code> 中的 <code>MVC</code> 模式更为准确的解读。在一个典型的 <code>MVC</code> 应用中，<code>controller</code> 由于承载了过多的逻辑，往往会变得臃肿不堪，所以 <code>MVC</code> 也经常被人调侃成 <a href="https://twitter.com/Colin_Campbell/status/293167951132098560">Massive View Controller</a> ：</p>

<blockquote><p>iOS architecture, where MVC stands for Massive View Controller.</p></blockquote>

<p>坦白说，有一部分逻辑确实是属于 <code>controller</code> 的，但是也有一部分逻辑是不应该被放置在 <code>controller</code> 中的。比如，将 <code>model</code> 中的 <code>NSDate</code> 转换成 <code>view</code> 可以展示的 <code>NSString</code> 等。在 <code>MVVM</code> 中，我们将这些逻辑统称为展示逻辑。</p>

<h2>MVVM</h2>

<p>因此，一种可以很好地解决 <code>Massive View Controller</code> 问题的办法就是将 <code>controller</code> 中的展示逻辑抽取出来，放置到一个专门的地方，而这个地方就是 <code>viewModel</code> 。其实，我们只要在上图中的 <code>M-VC</code> 之间放入 <code>VM</code> ，就可以得到 <code>MVVM</code> 模式的结构图：</p>

<p><img src="http://blog.leichunfeng.com/images/M-V-VM.png" width="409" /></p>

<p>从上图中，我们可以非常清楚地看到 <code>MVVM</code> 中四个组件之间的关系。<strong>注</strong>：除了 <code>view</code> 、<code>viewModel</code> 和 <code>model</code> 之外，<code>MVVM</code> 中还有一个非常重要的隐含组件 <code>binder</code> ：</p>

<ul>
<li><code>view</code> ：由 <code>MVC</code> 中的 <code>view</code> 和 <code>controller</code> 组成，负责 <code>UI</code> 的展示，绑定 <code>viewModel</code> 中的属性，触发 <code>viewModel</code> 中的命令；</li>
<li><code>viewModel</code> ：从 <code>MVC</code> 的 <code>controller</code> 中抽取出来的展示逻辑，负责从 <code>model</code> 中获取 <code>view</code> 所需的数据，转换成 <code>view</code> 可以展示的数据，并暴露公开的属性和命令供 <code>view</code> 进行绑定；</li>
<li><code>model</code> ：与 <code>MVC</code> 中的 <code>model</code> 一致，包括数据模型、访问数据库的操作和网络请求等；</li>
<li><code>binder</code> ：在 <code>MVVM</code> 中，声明式的数据和命令绑定是一个隐含的约定，它可以让开发者非常方便地实现 <code>view</code> 和 <code>viewModel</code> 的同步，避免编写大量繁杂的样板化代码。在微软的 <code>MVVM</code> 实现中，使用的是一种被称为 <a href="https://en.wikipedia.org/wiki/Extensible_Application_Markup_Language">XAML</a> 的标记语言。</li>
</ul>


<h2>ReactiveCocoa</h2>

<p>尽管，在 <code>iOS</code> 开发中，系统并没有提供类似的框架可以让我们方便地实现 <code>binder</code> 功能，不过，值得庆幸的是，<code>GitHub</code> 开源的 <code>RAC</code> ，给了我们一个非常不错的选择。</p>

<p><code>RAC</code> 是一个 <code>iOS</code> 中的函数式响应式编程框架，它受 <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">Functional Reactive Programming</a> 的启发，是 <a href="https://github.com/jspahrsummers">Justin Spahr-Summers</a> 和 <a href="https://github.com/joshaber">Josh Abernathy</a> 在开发 <a href="https://desktop.github.com/">GitHub for Mac</a> 过程中的一个副产品，它提供了一系列用来组合和转换值流的 <code>API</code> 。如需了解更多关于 <code>RAC</code> 的信息，可以阅读我的上一篇文章<a href="http://blog.leichunfeng.com/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/">《ReactiveCocoa v2.5 源码解析之架构总览》</a>。</p>

<p>在 <code>iOS</code> 的 <code>MVVM</code> 实现中，我们可以使用 <code>RAC</code> 来在 <code>view</code> 和 <code>viewModel</code> 之间充当 <code>binder</code> 的角色，优雅地实现两者之间的同步。此外，我们还可以把 <code>RAC</code> 用在 <code>model</code> 层，使用 <code>Signal</code> 来代表异步的数据获取操作，比如读取文件、访问数据库和网络请求等。<strong>说明</strong>，<code>RAC</code> 的后一个应用场景是与 <code>MVVM</code> 无关的，也就是说，我们同样可以在 <code>MVC</code> 的 <code>model</code> 层这么用。</p>

<h2>小结</h2>

<p>综上所述，我们只要将 <code>MVC</code> 中的 <code>controller</code> 中的展示逻辑抽取出来，放置到 <code>viewModel</code> 中，然后通过一定的技术手段，比如 <code>RAC</code> 来同步 <code>view</code> 和 <code>viewModel</code> ，就完成了 <code>MVC</code> 到 <code>MVVM</code> 的转变。</p>

<blockquote><p>Talk is cheap. Show me the code.</p></blockquote>

<p>下面，我们直接上代码，一起来看一个 <code>MVC</code> 模式转换成 <code>MVVM</code> 模式的示例。首先是 <code>model</code> 层的代码 <code>Person</code> ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">Person</span> : <span class="bp">NSObject</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initwithSalutation:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">salutation</span> <span class="nf">firstName:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">firstName</span> <span class="nf">lastName:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">lastName</span> <span class="nf">birthdate:</span><span class="p">(</span><span class="bp">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="nv">birthdate</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">salutation</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">firstName</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">lastName</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="bp">NSDate</span> <span class="o">*</span><span class="n">birthdate</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后是 <code>view</code> 层的代码 <code>PersonViewController</code> ，在 <code>viewDidLoad</code> 方法中，我们将 <code>Person</code> 中的属性进行一定的转换后，赋值给相应的 <code>view</code> 进行展示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">salutation</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">nameLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;%@ %@ %@&quot;</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">salutation</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">firstName</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">lastName</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">nameLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;%@ %@&quot;</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">firstName</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">lastName</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSDateFormatter</span> <span class="o">*</span><span class="n">dateFormatter</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSDateFormatter</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">setDateFormat</span><span class="p">:</span><span class="s">@&quot;EEEE MMMM d, yyyy&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">birthdateLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">stringFromDate</span><span class="p">:</span><span class="n">model</span><span class="p">.</span><span class="n">birthdate</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来，我们引入一个 <code>viewModel</code> ，将 <code>PersonViewController</code> 中的展示逻辑抽取到这个 <code>PersonViewModel</code> 中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">PersonViewModel</span> : <span class="bp">NSObject</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithPerson:</span><span class="p">(</span><span class="n">Person</span> <span class="o">*</span><span class="p">)</span><span class="nv">person</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="n">Person</span> <span class="o">*</span><span class="n">person</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">nameText</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">birthdateText</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">PersonViewModel</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithPerson:</span><span class="p">(</span><span class="n">Person</span> <span class="o">*</span><span class="p">)</span><span class="nv">person</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>       <span class="n">_person</span> <span class="o">=</span> <span class="n">person</span><span class="p">;</span>
</span><span class='line'>  
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">person</span><span class="p">.</span><span class="n">salutation</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">_nameText</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;%@ %@ %@&quot;</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">person</span><span class="p">.</span><span class="n">salutation</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">person</span><span class="p">.</span><span class="n">firstName</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">person</span><span class="p">.</span><span class="n">lastName</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">_nameText</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;%@ %@&quot;</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">person</span><span class="p">.</span><span class="n">firstName</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">person</span><span class="p">.</span><span class="n">lastName</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  
</span><span class='line'>      <span class="bp">NSDateFormatter</span> <span class="o">*</span><span class="n">dateFormatter</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSDateFormatter</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>      <span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">setDateFormat</span><span class="p">:</span><span class="s">@&quot;EEEE MMMM d, yyyy&quot;</span><span class="p">];</span>
</span><span class='line'>      <span class="n">_birthdateText</span> <span class="o">=</span> <span class="p">[</span><span class="n">dateFormatter</span> <span class="nl">stringFromDate</span><span class="p">:</span><span class="n">person</span><span class="p">.</span><span class="n">birthdate</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>最终，<code>PersonViewController</code> 将会变得非常轻量级：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">nameLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">viewModel</span><span class="p">.</span><span class="n">nameText</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">birthdateLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">viewModel</span><span class="p">.</span><span class="n">birthdateText</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>怎么样？其实 <code>MVVM</code> 并没有想像中的那么难吧，而且更重要的是它也没有破坏 <code>MVC</code> 的现有结构，只不过是移动了一些代码，仅此而已。好了，说了这么多，那 <code>MVVM</code> 相比 <code>MVC</code> 到底有哪些好处呢？我想，主要可以归纳为以下三点：</p>

<ul>
<li>由于展示逻辑被抽取到了 <code>viewModel</code> 中，所以 <code>view</code> 中的代码将会变得非常轻量级；</li>
<li>由于 <code>viewModel</code> 中的代码是与 <code>UI</code> 无关的，所以它具有良好的可测试性；</li>
<li>对于一个封装了大量业务逻辑的 <code>model</code> 来说，改变它可能会比较困难，并且存在一定的风险。在这种场景下，<code>viewModel</code> 可以作为 <code>model</code> 的适配器使用，从而避免对 <code>model</code> 进行较大的改动。</li>
</ul>


<p>通过前面的示例，我们对第一点已经有了一定的感触；至于第三点，可能对于一个复杂的大型应用来说，才会比较明显；下面，我们还是使用前面的示例，来直观地感受下第二点好处：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">SpecBegin</span><span class="p">(</span><span class="n">Person</span><span class="p">)</span>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">salutation</span> <span class="o">=</span> <span class="s">@&quot;Dr.&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">firstName</span> <span class="o">=</span> <span class="s">@&quot;first&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">lastName</span> <span class="o">=</span> <span class="s">@&quot;last&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">NSDate</span> <span class="o">*</span><span class="n">birthdate</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDate</span> <span class="nl">dateWithTimeIntervalSince1970</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">it</span> <span class="p">(</span><span class="s">@&quot;should use the salutation available. &quot;</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">Person</span> <span class="o">*</span><span class="n">person</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Person</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSalutation</span><span class="p">:</span><span class="n">salutation</span> <span class="nl">firstName</span><span class="p">:</span><span class="n">firstName</span> <span class="nl">lastName</span><span class="p">:</span><span class="n">lastName</span> <span class="nl">birthdate</span><span class="p">:</span><span class="n">birthdate</span><span class="p">];</span>
</span><span class='line'>        <span class="n">PersonViewModel</span> <span class="o">*</span><span class="n">viewModel</span> <span class="o">=</span> <span class="p">[[</span><span class="n">PersonViewModel</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithPerson</span><span class="p">:</span><span class="n">person</span><span class="p">];</span>
</span><span class='line'>        <span class="n">expect</span><span class="p">(</span><span class="n">viewModel</span><span class="p">.</span><span class="n">nameText</span><span class="p">).</span><span class="n">to</span><span class="p">.</span><span class="n">equal</span><span class="p">(</span><span class="s">@&quot;Dr. first last&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">it</span> <span class="p">(</span><span class="s">@&quot;should not use an unavailable salutation. &quot;</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">Person</span> <span class="o">*</span><span class="n">person</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Person</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSalutation</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">firstName</span><span class="p">:</span><span class="n">firstName</span> <span class="nl">lastName</span><span class="p">:</span><span class="n">lastName</span> <span class="nl">birthdate</span><span class="p">:</span><span class="n">birthdate</span><span class="p">];</span>
</span><span class='line'>        <span class="n">PersonViewModel</span> <span class="o">*</span><span class="n">viewModel</span> <span class="o">=</span> <span class="p">[[</span><span class="n">PersonViewModel</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithPerson</span><span class="p">:</span><span class="n">person</span><span class="p">];</span>
</span><span class='line'>        <span class="n">expect</span><span class="p">(</span><span class="n">viewModel</span><span class="p">.</span><span class="n">nameText</span><span class="p">).</span><span class="n">to</span><span class="p">.</span><span class="n">equal</span><span class="p">(</span><span class="s">@&quot;first last&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">it</span> <span class="p">(</span><span class="s">@&quot;should use the correct date format. &quot;</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">Person</span> <span class="o">*</span><span class="n">person</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Person</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSalutation</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">firstName</span><span class="p">:</span><span class="n">firstName</span> <span class="nl">lastName</span><span class="p">:</span><span class="n">lastName</span> <span class="nl">birthdate</span><span class="p">:</span><span class="n">birthdate</span><span class="p">];</span>
</span><span class='line'>        <span class="n">PersonViewModel</span> <span class="o">*</span><span class="n">viewModel</span> <span class="o">=</span> <span class="p">[[</span><span class="n">PersonViewModel</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithPerson</span><span class="p">:</span><span class="n">person</span><span class="p">];</span>
</span><span class='line'>        <span class="n">expect</span><span class="p">(</span><span class="n">viewModel</span><span class="p">.</span><span class="n">birthdateText</span><span class="p">).</span><span class="n">to</span><span class="p">.</span><span class="n">equal</span><span class="p">(</span><span class="s">@&quot;Thursday January 1, 1970&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="n">SpecEnd</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于 <code>MVVM</code> 来说，我们可以把 <code>view</code> 看作是 <code>viewModel</code> 的可视化形式，<code>viewModel</code> 提供了 <code>view</code> 所需的数据和命令。因此，<code>viewModel</code> 的可测试性可以帮助我们极大地提高应用的质量。</p>

<h2>MVVMReactiveCocoa</h2>

<p>接下来，我们进入本文的第二部分，重点介绍一个使用 <code>MVVM</code> 和 <code>RAC</code> 开发的开源项目 <code>MVVMReactiveCocoa</code> 。<strong>说明</strong>，本文将主要介绍这个应用的架构和设计思路，希望可以为你实践 <code>MVVM</code> 提供一个真实的参考案例，有些架构并非是 <code>MVVM</code> 所必须的，而是我们为了更顺畅地使用 <code>MVVM</code> 而引入的，特别是 <code>ViewModel-Based Navigation</code> 。所以，请你在实践的过程中能够结合自身应用的实际情况做出相应的取舍，灵活处理。最后，我们将以登录界面为例，一起探讨下 <code>MVVM</code> 的实践思路。</p>

<p><strong>说明</strong>，以下内容均基于 <code>MVVMReactiveCocoa</code> 的 <a href="https://github.com/leichunfeng/MVVMReactiveCocoa/tree/v2.1.1">v2.1.1</a> 标签进行展开，并且对部分无关代码做了删减。</p>

<h3>类图</h3>

<p>为了方便我们从宏观上了解 <code>MVVMReactiveCocoa</code> 的整体结构，我们先来看看它的类图：</p>

<p><img src="http://blog.leichunfeng.com/images/MVVMReactiveCocoa-v2.1.1.png" alt="MVVMReactiveCocoa-v2.1.1" /></p>

<p>从上图中，我们可以看到，在 <code>MVVMReactiveCocoa</code> 中主要有两大继承体系：</p>

<ul>
<li>用蓝色标识出来的 <code>viewModel</code> 的继承体系，基类为 <code>MRCViewModel</code> ；</li>
<li>用红色标识出来的 <code>view</code> 的继承体系，基类为 <code>MRCViewController</code> 。</li>
</ul>


<p>除了提供与系统基类 <code>UIViewController</code> 相对应的基类 <code>MRCViewModel/MRCViewController</code> 外，还提供了与系统基类 <code>UITableViewController</code> 和 <code>UITabBarController</code> 相对应的基类 <code>MRCTableViewModel/MRCTableViewController</code> 和 <code>MRCTabBarViewModel/MRCTabBarController</code> ，其中基类 <code>MRCTableViewModel/MRCTableViewController</code> 的使用最为普遍。</p>

<p><strong>说明</strong>，之所以通过基类的方式来组织 <code>MVVMReactiveCocoa</code> ，一方面是因为主要开发者只有我一个人，这个方案非常容易实施；另一方面是因为通过基类的方式可以尽可能简单地实现代码重用，提高开发效率。</p>

<h3>服务总线</h3>

<p>经过前面的探讨，我们已经知道了 <code>MVVM</code> 中的 <code>viewModel</code> 的主要职责就是从 <code>model</code> 层获取 <code>view</code> 所需的数据，并且将这些数据转换成 <code>view</code> 能够展示的形式。因此，为了方便 <code>viewModel</code> 层调用 <code>model</code> 层中的所有服务，并且统一管理这些服务的创建，我使用抽象工厂模式将 <code>model</code> 层的所有服务集中管理了起来，结构图如下：</p>

<p><img src="http://blog.leichunfeng.com/images/service-bus.png" width="558" /></p>

<p>从上图中，我们可以看出，在服务总线类 <code>MRCViewModelServices/MRCViewModelServicesImpl</code> 中，主要包括以下三个方面的内容：</p>

<ul>
<li>应用自有的服务类，用柚黄色进行了标识，包括 <code>MRCAppStoreService/MRCAppStoreServiceImpl</code> 和 <code>MRCRepositoryService/MRCRepositoryServiceImpl</code> 两个服务类；</li>
<li>第三方 <code>GitHub</code> 提供的 <code>API</code> 框架，用天蓝色进行了标识，主要包括 <code>OCTClient</code> 服务类；</li>
<li>应用的导航服务，用藻绿色进行了标识，包括 <code>MRCNavigationProtocol</code> 协议和实现类 <code>MRCViewModelServicesImpl</code> 等。</li>
</ul>


<p>其中，前两者都是以信号的形式对 <code>viewModel</code> 层提供服务，代表异步的网络请求等数据获取操作，而我们在 <code>viewModel</code> 层则可以通过订阅信号的形式获取到所需的数据。此外，服务总线还实现了 <code>MRCNavigationProtocol</code> 协议，它的内容如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@protocol</span> <span class="nc">MRCNavigationProtocol</span> <span class="o">&lt;</span><span class="bp">NSObject</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">pushViewModel</span><span class="p">:(</span><span class="n">MRCViewModel</span> <span class="o">*</span><span class="p">)</span><span class="n">viewModel</span> <span class="nl">animated</span><span class="p">:(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">animated</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">popViewModelAnimated:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">popToRootViewModelAnimated:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">presentViewModel:</span><span class="p">(</span><span class="n">MRCViewModel</span> <span class="o">*</span><span class="p">)</span><span class="nv">viewModel</span> <span class="nf">animated:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="nf">completion:</span><span class="p">(</span><span class="n">VoidBlock</span><span class="p">)</span><span class="nv">completion</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dismissViewModelAnimated:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="nf">completion:</span><span class="p">(</span><span class="n">VoidBlock</span><span class="p">)</span><span class="nv">completion</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">resetRootViewModel:</span><span class="p">(</span><span class="n">MRCViewModel</span> <span class="o">*</span><span class="p">)</span><span class="nv">viewModel</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>看上去是不是有点眼熟？是的，<code>MRCNavigationProtocol</code> 协议其实就是参照系统的导航操作定义出来的，用来实现 <code>ViewModel-Based</code> 的导航服务。<strong>注意</strong>，服务总线类 <code>MRCViewModelServicesImpl</code> 其实并没有真正实现 <code>MRCNavigationProtocol</code> 协议中声明的操作，只不过是实现了一些空操作而已：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">pushViewModel:</span><span class="p">(</span><span class="n">MRCViewModel</span> <span class="o">*</span><span class="p">)</span><span class="nv">viewModel</span> <span class="nf">animated:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">popViewModelAnimated:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">popToRootViewModelAnimated:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">presentViewModel:</span><span class="p">(</span><span class="n">MRCViewModel</span> <span class="o">*</span><span class="p">)</span><span class="nv">viewModel</span> <span class="nf">animated:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="nf">completion:</span><span class="p">(</span><span class="n">VoidBlock</span><span class="p">)</span><span class="nv">completion</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dismissViewModelAnimated:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="nf">completion:</span><span class="p">(</span><span class="n">VoidBlock</span><span class="p">)</span><span class="nv">completion</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">resetRootViewModel:</span><span class="p">(</span><span class="n">MRCViewModel</span> <span class="o">*</span><span class="p">)</span><span class="nv">viewModel</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么，我们是怎么实现 <code>ViewModel-Based</code> 的导航操作的呢？用 <code>MRCViewModelServicesImpl</code> 来实现这些空操作到底有什么用意？为什么要这么做，目的是为了什么？兄台，莫急，请接着看下一小节的内容。</p>

<h3>ViewModel-Based Navigation</h3>

<p>我们先来思考一个问题，就是我们为什么要实现 <code>ViewModel-Based</code> 的导航操作呢？直接在 <code>view</code> 层使用系统的 <code>push/present</code> 等操作来完成导航不就好了么？我总结了一下这么做的理由，主要有以下三点：</p>

<ul>
<li>从理论上来说，<code>MVVM</code> 模式的应用应该是以 <code>viewModel</code> 为驱动来运转的；</li>
<li>根据我们前面对 <code>MVVM</code> 的探讨，<code>viewModel</code> 提供了 <code>view</code> 所需的数据和命令。因此，我们往往可以直接在命令执行成功后使用 <code>doNext</code> 顺带就把导航操作给做了，一气呵成；</li>
<li>这样可以使 <code>view</code> 更加轻量级，只需要绑定 <code>viewModel</code> 提供的数据和命令即可。</li>
</ul>


<p>既然如此，那我们究竟要如何实现 <code>ViewModel-Based</code> 的导航操作呢？我们都知道 <code>iOS</code> 中的导航操作无外乎两种，<code>push/pop</code> 和 <code>present/dismiss</code> ，前者是 <code>UINavigationController</code> 特有的功能，而后者是所有 <code>UIViewController</code> 都具备的功能。<strong>注意</strong>，<code>UINavigationController</code> 也是 <code>UIViewController</code> 的子类，所以它也同样具备 <code>present/dismiss</code> 的功能。因此，从本质上来说，不管我们要实现什么样的导航操作，最终都是离不开 <code>push/pop</code> 和 <code>present/dismiss</code> 的。</p>

<p>目前，<code>MVVMReactiveCocoa</code> 的做法是在 <code>view</code> 层维护一个 <code>NavigationController</code> 的堆栈 <code>MRCNavigationControllerStack</code> ，不管是 <code>push/pop</code> 还是 <code>present/dismiss</code> ，都使用栈顶的 <code>NavigationController</code> 来执行导航操作，并且保证 <code>present</code> 出来的是一个 <code>NavigationController</code> 。</p>

<p>接下来，我们一起来看看 <code>MVVMReactiveCocoa</code> 在执行了 <code>push/pop</code> 或 <code>present/dismiss</code> 操作后视图层次结构的变化过程。首先，我们来看看用户在登录成功后进入到首页时应用的视图层次结构图：</p>

<p><img src="http://blog.leichunfeng.com/images/view-model-based1.png" width="671" /></p>

<p>此时，应用展示的界面是 <code>NewsViewController</code> 。在 <code>MRCNavigationControllerStack</code> 堆栈中只有 <code>NavigationController0</code> 一个元素；而 <code>NavigationController1</code> 并没有在 <code>MRCNavigationControllerStack</code> 堆栈中，这是因为需要支持 <code>TabBarController</code> 的滑动切换而设计的视图层次结构，是首页比较特殊的一个地方。更多信息可以查看 <code>GitHub</code> 开源库 <a href="https://github.com/leichunfeng/WXTabBarController">WXTabBarController</a> ，在这里，我们不用太过于关心这个问题，只需要理解原理就好了。</p>

<p>接下来，当用户在 <code>NewsViewController</code> 界面，点击了某一个 <code>cell</code> ，通过 <code>push</code> 的方式，进入到仓库详情界面时，应用的视图层次结构图如下：</p>

<p><img src="http://blog.leichunfeng.com/images/view-model-based2.png" width="184" /></p>

<p>应用通过 <code>MRCNavigationControllerStack</code> 栈顶的元素 <code>NavigationController0</code> ，将仓库详情界面 <code>push</code> 到了自身的堆栈中。此时，应用展示的界面是被 <code>push</code> 进来的仓库详情界面 <code>RepoDetailViewController</code> 。最后，当用户在仓库详情界面，点击左下角的切换分支按钮，通过 <code>present</code> 的方式，弹出分支选择界面时，应用的视图层次结构图如下：</p>

<p><img src="http://blog.leichunfeng.com/images/view-model-based3.png" width="454" /></p>

<p>应用通过 <code>MRCNavigationControllerStack</code> 栈顶的元素 <code>NavigationController0</code> ，将 <code>NavigationController5</code> 以 <code>present</code> 的方式弹出来。此时，应用展示的是 <code>NavigationController5</code> 的根视图 <code>SelectBranchOrTagViewController</code> 。<strong>说明</strong>，由于 <code>pop</code> 和 <code>dismiss</code> 与 <code>push</code> 和 <code>present</code> 互为逆操作，所以只要按照从下到上的顺序看上面的视图层次结构图即可，这里不再赘述。</p>

<p>等等，如果我没有记错的话，<code>MRCNavigationControllerStack</code> 堆栈是在 <code>view</code> 层，而服务总线类 <code>MRCViewModelServicesImpl</code> 是在 <code>viewModel</code> 层的。据我所知，<code>viewModel</code> 层是不能引入 <code>view</code> 层的任何东西的，更严格的说，是不能引入任何 <code>UIKit</code> 中的东西的，否则就违背了 <code>MVVM</code> 的基本原则，并且也会散失 <code>viewModel</code> 的可测试性。在这个前提下，你要如何让这两者产生关联呢？</p>

<p>没错，这就是 <code>MRCViewModelServicesImpl</code> 中之所以实现那些空操作的目的所在了。<code>viewModel</code> 通过调用 <code>MRCViewModelServicesImpl</code> 中的空操作来表明需要执行相应的导航操作，而 <code>MRCNavigationControllerStack</code> 则通过 <code>Hook</code> 来捕获这些空操作，然后使用栈顶的 <code>NavigationController</code> 来执行真正的导航操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">registerNavigationHooks</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">@</span><span class="n">weakify</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>    <span class="p">[[(</span><span class="bp">NSObject</span> <span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">.</span><span class="n">services</span>
</span><span class='line'>        <span class="nl">rac_signalForSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">pushViewModel</span><span class="p">:</span><span class="nl">animated</span><span class="p">:)]</span>
</span><span class='line'>        <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">RACTuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">@</span><span class="n">strongify</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>            <span class="bp">UIViewController</span> <span class="o">*</span><span class="n">viewController</span> <span class="o">=</span> <span class="p">(</span><span class="bp">UIViewController</span> <span class="o">*</span><span class="p">)[</span><span class="n">MRCRouter</span><span class="p">.</span><span class="n">sharedInstance</span> <span class="nl">viewControllerForViewModel</span><span class="p">:</span><span class="n">tuple</span><span class="p">.</span><span class="n">first</span><span class="p">];</span>
</span><span class='line'>            <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">navigationControllers</span><span class="p">.</span><span class="n">lastObject</span> <span class="nl">pushViewController</span><span class="p">:</span><span class="n">viewController</span> <span class="nl">animated</span><span class="p">:[</span><span class="n">tuple</span><span class="p">.</span><span class="n">second</span> <span class="n">boolValue</span><span class="p">]];</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[[(</span><span class="bp">NSObject</span> <span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">.</span><span class="n">services</span>
</span><span class='line'>        <span class="nl">rac_signalForSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">popViewModelAnimated</span><span class="p">:)]</span>
</span><span class='line'>        <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">RACTuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="p">@</span><span class="n">strongify</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>            <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">navigationControllers</span><span class="p">.</span><span class="n">lastObject</span> <span class="nl">popViewControllerAnimated</span><span class="p">:[</span><span class="n">tuple</span><span class="p">.</span><span class="n">first</span> <span class="n">boolValue</span><span class="p">]];</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[[(</span><span class="bp">NSObject</span> <span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">.</span><span class="n">services</span>
</span><span class='line'>        <span class="nl">rac_signalForSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">popToRootViewModelAnimated</span><span class="p">:)]</span>
</span><span class='line'>        <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">RACTuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">@</span><span class="n">strongify</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>            <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">navigationControllers</span><span class="p">.</span><span class="n">lastObject</span> <span class="nl">popToRootViewControllerAnimated</span><span class="p">:[</span><span class="n">tuple</span><span class="p">.</span><span class="n">first</span> <span class="n">boolValue</span><span class="p">]];</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[[(</span><span class="bp">NSObject</span> <span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">.</span><span class="n">services</span>
</span><span class='line'>        <span class="nl">rac_signalForSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">presentViewModel</span><span class="p">:</span><span class="nl">animated</span><span class="p">:</span><span class="nl">completion</span><span class="p">:)]</span>
</span><span class='line'>        <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">RACTuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="p">@</span><span class="n">strongify</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>            <span class="bp">UIViewController</span> <span class="o">*</span><span class="n">viewController</span> <span class="o">=</span> <span class="p">(</span><span class="bp">UIViewController</span> <span class="o">*</span><span class="p">)[</span><span class="n">MRCRouter</span><span class="p">.</span><span class="n">sharedInstance</span> <span class="nl">viewControllerForViewModel</span><span class="p">:</span><span class="n">tuple</span><span class="p">.</span><span class="n">first</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="bp">UINavigationController</span> <span class="o">*</span><span class="n">presentingViewController</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">navigationControllers</span><span class="p">.</span><span class="n">lastObject</span><span class="p">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">viewController</span> <span class="nl">isKindOfClass</span><span class="p">:</span><span class="bp">UINavigationController</span><span class="p">.</span><span class="k">class</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">viewController</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MRCNavigationController</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithRootViewController</span><span class="p">:</span><span class="n">viewController</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="p">[</span><span class="nb">self</span> <span class="nl">pushNavigationController</span><span class="p">:(</span><span class="bp">UINavigationController</span> <span class="o">*</span><span class="p">)</span><span class="n">viewController</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="p">[</span><span class="n">presentingViewController</span> <span class="nl">presentViewController</span><span class="p">:</span><span class="n">viewController</span> <span class="nl">animated</span><span class="p">:[</span><span class="n">tuple</span><span class="p">.</span><span class="n">second</span> <span class="n">boolValue</span><span class="p">]</span> <span class="nl">completion</span><span class="p">:</span><span class="n">tuple</span><span class="p">.</span><span class="n">third</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[[(</span><span class="bp">NSObject</span> <span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">.</span><span class="n">services</span>
</span><span class='line'>        <span class="nl">rac_signalForSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">dismissViewModelAnimated</span><span class="p">:</span><span class="nl">completion</span><span class="p">:)]</span>
</span><span class='line'>        <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">RACTuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">@</span><span class="n">strongify</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>            <span class="p">[</span><span class="nb">self</span> <span class="n">popNavigationController</span><span class="p">];</span>
</span><span class='line'>            <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">navigationControllers</span><span class="p">.</span><span class="n">lastObject</span> <span class="nl">dismissViewControllerAnimated</span><span class="p">:[</span><span class="n">tuple</span><span class="p">.</span><span class="n">first</span> <span class="n">boolValue</span><span class="p">]</span> <span class="nl">completion</span><span class="p">:</span><span class="n">tuple</span><span class="p">.</span><span class="n">second</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[[(</span><span class="bp">NSObject</span> <span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">.</span><span class="n">services</span>
</span><span class='line'>        <span class="nl">rac_signalForSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">resetRootViewModel</span><span class="p">:)]</span>
</span><span class='line'>        <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">RACTuple</span> <span class="o">*</span><span class="n">tuple</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">@</span><span class="n">strongify</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>            <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">navigationControllers</span> <span class="n">removeAllObjects</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="bp">UIViewController</span> <span class="o">*</span><span class="n">viewController</span> <span class="o">=</span> <span class="p">(</span><span class="bp">UIViewController</span> <span class="o">*</span><span class="p">)[</span><span class="n">MRCRouter</span><span class="p">.</span><span class="n">sharedInstance</span> <span class="nl">viewControllerForViewModel</span><span class="p">:</span><span class="n">tuple</span><span class="p">.</span><span class="n">first</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">viewController</span> <span class="nl">isKindOfClass</span><span class="p">:[</span><span class="bp">UINavigationController</span> <span class="k">class</span><span class="p">]])</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">viewController</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MRCNavigationController</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithRootViewController</span><span class="p">:</span><span class="n">viewController</span><span class="p">];</span>
</span><span class='line'>                <span class="p">((</span><span class="bp">UINavigationController</span> <span class="o">*</span><span class="p">)</span><span class="n">viewController</span><span class="p">).</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>                <span class="p">[</span><span class="nb">self</span> <span class="nl">pushNavigationController</span><span class="p">:(</span><span class="bp">UINavigationController</span> <span class="o">*</span><span class="p">)</span><span class="n">viewController</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">MRCSharedAppDelegate</span><span class="p">.</span><span class="n">window</span><span class="p">.</span><span class="n">rootViewController</span> <span class="o">=</span> <span class="n">viewController</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过 <code>Hook</code> 的方式，我们最终实现了 <code>ViewModel-Based</code> 的导航操作，并且在 <code>viewModel</code> 层中也没有引入 <code>view</code> 层的任意东西，实现了解耦合。</p>

<h4>Router</h4>

<p>还有一点值得一提的是，我们在 <code>viewModel</code> 中调用导航操作的时候，只传入了 <code>viewModel</code> 的实例作为参数，那么我们在 <code>MRCNavigationControllerStack</code> 中执行真正的导航操作时，怎么才能知道要跳转到哪个界面呢？为此，我们配置了一个从 <code>viewModel</code> 到 <code>view</code> 的映射，并且约定了一个统一的初始化 <code>view</code> 的方法 <code>initWithViewModel:</code> ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">MRCViewController</span> <span class="o">*</span><span class="p">)</span><span class="nf">viewControllerForViewModel:</span><span class="p">(</span><span class="n">MRCViewModel</span> <span class="o">*</span><span class="p">)</span><span class="nv">viewModel</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">viewController</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">viewModelViewMappings</span><span class="p">[</span><span class="n">NSStringFromClass</span><span class="p">(</span><span class="n">viewModel</span><span class="p">.</span><span class="k">class</span><span class="p">)];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSParameterAssert</span><span class="p">([</span><span class="n">NSClassFromString</span><span class="p">(</span><span class="n">viewController</span><span class="p">)</span> <span class="nl">isSubclassOfClass</span><span class="p">:[</span><span class="n">MRCViewController</span> <span class="k">class</span><span class="p">]]);</span>
</span><span class='line'>    <span class="n">NSParameterAssert</span><span class="p">([</span><span class="n">NSClassFromString</span><span class="p">(</span><span class="n">viewController</span><span class="p">)</span> <span class="nl">instancesRespondToSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">initWithViewModel</span><span class="p">:)]);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="p">[[</span><span class="n">NSClassFromString</span><span class="p">(</span><span class="n">viewController</span><span class="p">)</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithViewModel</span><span class="p">:</span><span class="n">viewModel</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nf">viewModelViewMappings</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="l">@{</span>
</span><span class='line'>      <span class="s">@&quot;MRCLoginViewModel&quot;</span><span class="o">:</span> <span class="s">@&quot;MRCLoginViewController&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="s">@&quot;MRCHomepageViewModel&quot;</span><span class="o">:</span> <span class="s">@&quot;MRCHomepageViewController&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="s">@&quot;MRCRepoDetailViewModel&quot;</span><span class="o">:</span> <span class="s">@&quot;MRCRepoDetailViewController&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>    <span class="l">}</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>登录界面</h3>

<p>最后，我们一起来看看登录界面中 <code>viewModel</code> 和 <code>view</code> 的部分关键代码，探讨一下 <code>MVVM</code> 的具体实践过程。<strong>说明</strong>，我们将会尽可能地回避具体的业务逻辑，重点关注 <code>MVVM</code> 的实践思路。下面是登录界面的截图：</p>

<p><img src="http://blog.leichunfeng.com/images/login.jpg" width="320" /></p>

<p>其中，主要的界面元素有：</p>

<ul>
<li>一个用于展示用户头像的按钮 <code>avatarButton</code> ；</li>
<li>用于输入账号和密码的输入框 <code>usernameTextField</code> 和 <code>passwordTextField</code> ；</li>
<li>一个直接登录的按钮 <code>loginButton</code> 和一个跳转到浏览器授权登录的按钮 <code>browserLoginButton</code> 。</li>
</ul>


<p><strong>分析</strong>：根据我们前面对 <code>MVVM</code> 的探讨，<code>viewModel</code> 需要提供 <code>view</code> 所需的数据和命令。因此，<code>MRCLoginViewModel.h</code> 头文件的内容大致如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">MRCLoginViewModel</span> : <span class="nc">MRCViewModel</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="bp">NSURL</span> <span class="o">*</span><span class="n">avatarURL</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">username</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">password</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="n">RACSignal</span> <span class="o">*</span><span class="n">validLoginSignal</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="n">RACCommand</span> <span class="o">*</span><span class="n">loginCommand</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="n">RACCommand</span> <span class="o">*</span><span class="n">browserLoginCommand</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>非常直观，其中需要特别说明的是 <code>validLoginSignal</code> 属性代表的是登录按钮是否可用，它将会与 <code>view</code> 中登录按钮的 <code>enabled</code> 属性进行绑定。接着，我们来看看 <code>MRCLoginViewModel.m</code> 的实现文件中的部分关键代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">MRCLoginViewModel</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">initialize</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="n">initialize</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">RAC</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">avatarURL</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[</span><span class="n">RACObserve</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
</span><span class='line'>        <span class="nl">map</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">username</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="p">[[</span><span class="n">OCTUser</span> <span class="nl">mrc_fetchUserWithRawLogin</span><span class="p">:</span><span class="n">username</span><span class="p">]</span> <span class="n">avatarURL</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}]</span>
</span><span class='line'>        <span class="n">distinctUntilChanged</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">validLoginSignal</span> <span class="o">=</span> <span class="p">[[</span><span class="n">RACSignal</span>
</span><span class='line'>      <span class="nl">combineLatest</span><span class="p">:</span><span class="l">@[</span> <span class="n">RACObserve</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">username</span><span class="p">),</span> <span class="n">RACObserve</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">password</span><span class="p">)</span> <span class="l">]</span>
</span><span class='line'>        <span class="nl">reduce</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">username</span><span class="p">,</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">password</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="l">@(</span><span class="n">username</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">password</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="l">)</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}]</span>
</span><span class='line'>        <span class="n">distinctUntilChanged</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">@</span><span class="n">weakify</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">doNext</span><span class="p">)(</span><span class="n">OCTClient</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">OCTClient</span> <span class="o">*</span><span class="n">authenticatedClient</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">@</span><span class="n">strongify</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>        <span class="n">MRCHomepageViewModel</span> <span class="o">*</span><span class="n">viewModel</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MRCHomepageViewModel</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithServices</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">services</span> <span class="nl">params</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>            <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">services</span> <span class="nl">resetRootViewModel</span><span class="p">:</span><span class="n">viewModel</span><span class="p">];</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">OCTClient</span> <span class="nl">setClientID</span><span class="p">:</span><span class="n">MRC_CLIENT_ID</span> <span class="nl">clientSecret</span><span class="p">:</span><span class="n">MRC_CLIENT_SECRET</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">loginCommand</span> <span class="o">=</span> <span class="p">[[</span><span class="n">RACCommand</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSignalBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">oneTimePassword</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="p">@</span><span class="n">strongify</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>        <span class="n">OCTUser</span> <span class="o">*</span><span class="n">user</span> <span class="o">=</span> <span class="p">[</span><span class="n">OCTUser</span> <span class="nl">userWithRawLogin</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">username</span> <span class="nl">server</span><span class="p">:</span><span class="n">OCTServer</span><span class="p">.</span><span class="n">dotComServer</span><span class="p">];</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">[[</span><span class="n">OCTClient</span>
</span><span class='line'>          <span class="nl">signInAsUser</span><span class="p">:</span><span class="n">user</span> <span class="nl">password</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">password</span> <span class="nl">oneTimePassword</span><span class="p">:</span><span class="n">oneTimePassword</span> <span class="nl">scopes</span><span class="p">:</span><span class="n">OCTClientAuthorizationScopesUser</span> <span class="o">|</span> <span class="n">OCTClientAuthorizationScopesRepository</span> <span class="nl">note</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">noteURL</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">fingerprint</span><span class="p">:</span><span class="nb">nil</span><span class="p">]</span>
</span><span class='line'>            <span class="nl">doNext</span><span class="p">:</span><span class="n">doNext</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">browserLoginCommand</span> <span class="o">=</span> <span class="p">[[</span><span class="n">RACCommand</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSignalBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">[[</span><span class="n">OCTClient</span>
</span><span class='line'>          <span class="nl">signInToServerUsingWebBrowser</span><span class="p">:</span><span class="n">OCTServer</span><span class="p">.</span><span class="n">dotComServer</span> <span class="nl">scopes</span><span class="p">:</span><span class="n">OCTClientAuthorizationScopesUser</span> <span class="o">|</span> <span class="n">OCTClientAuthorizationScopesRepository</span><span class="p">]</span>
</span><span class='line'>            <span class="nl">doNext</span><span class="p">:</span><span class="n">doNext</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>当用户输入的用户名发生变化时，调用 <code>model</code> 层的方法查询本地数据库中缓存的用户数据，并返回 <code>avatarURL</code> 属性;</li>
<li>当用户输入的用户名或密码发生变化时，判断用户名和密码的长度是否均大于 <code>0</code> ，如果是则登录按钮可用，否则不可用;</li>
<li>当 <code>loginCommand</code> 或 <code>browserLoginCommand</code> 命令执行成功时，调用 <code>doNext</code> 代码块，使用服务总线中的方法 <code>resetRootViewModel:</code> 进入首页。</li>
</ul>


<p>接下来，我们来看看 <code>MRCLoginViewController</code> 中的部分关键代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">MRCLoginViewController</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">bindViewModel</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="n">bindViewModel</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">@</span><span class="n">weakify</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>    <span class="p">[</span><span class="n">RACObserve</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">viewModel</span><span class="p">,</span> <span class="n">avatarURL</span><span class="p">)</span> <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSURL</span> <span class="o">*</span><span class="n">avatarURL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="p">@</span><span class="n">strongify</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">avatarButton</span> <span class="nl">sd_setImageWithURL</span><span class="p">:</span><span class="n">avatarURL</span> <span class="nl">forState</span><span class="p">:</span><span class="n">UIControlStateNormal</span> <span class="nl">placeholderImage</span><span class="p">:[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">@&quot;default-avatar&quot;</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">RAC</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">viewModel</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>  <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">usernameTextField</span><span class="p">.</span><span class="n">rac_textSignal</span><span class="p">;</span>
</span><span class='line'>    <span class="n">RAC</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">viewModel</span><span class="p">,</span> <span class="n">password</span><span class="p">)</span>  <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">passwordTextField</span><span class="p">.</span><span class="n">rac_textSignal</span><span class="p">;</span>
</span><span class='line'>    <span class="n">RAC</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">loginButton</span><span class="p">,</span> <span class="n">enabled</span><span class="p">)</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">viewModel</span><span class="p">.</span><span class="n">validLoginSignal</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[[</span><span class="nb">self</span><span class="p">.</span><span class="n">loginButton</span>
</span><span class='line'>        <span class="nl">rac_signalForControlEvents</span><span class="p">:</span><span class="n">UIControlEventTouchUpInside</span><span class="p">]</span>
</span><span class='line'>        <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">@</span><span class="n">strongify</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>            <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">viewModel</span><span class="p">.</span><span class="n">loginCommand</span> <span class="nl">execute</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[[</span><span class="nb">self</span><span class="p">.</span><span class="n">browserLoginButton</span>
</span><span class='line'>        <span class="nl">rac_signalForControlEvents</span><span class="p">:</span><span class="n">UIControlEventTouchUpInside</span><span class="p">]</span>
</span><span class='line'>        <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">@</span><span class="n">strongify</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>            <span class="bp">NSString</span> <span class="o">*</span><span class="n">message</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;“%@” wants to open “Safari”&quot;</span><span class="p">,</span> <span class="n">MRC_APP_NAME</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">UIAlertController</span> <span class="o">*</span><span class="n">alertController</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIAlertController</span> <span class="nl">alertControllerWithTitle</span><span class="p">:</span><span class="nb">nil</span>
</span><span class='line'>                                                                                     <span class="nl">message</span><span class="p">:</span><span class="n">message</span>
</span><span class='line'>                                                                              <span class="nl">preferredStyle</span><span class="p">:</span><span class="n">UIAlertControllerStyleAlert</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="p">[</span><span class="n">alertController</span> <span class="nl">addAction</span><span class="p">:[</span><span class="n">UIAlertAction</span> <span class="nl">actionWithTitle</span><span class="p">:</span><span class="s">@&quot;Cancel&quot;</span> <span class="nl">style</span><span class="p">:</span><span class="n">UIAlertActionStyleCancel</span> <span class="nl">handler</span><span class="p">:</span><span class="nb">NULL</span><span class="p">]];</span>
</span><span class='line'>            <span class="p">[</span><span class="n">alertController</span> <span class="nl">addAction</span><span class="p">:[</span><span class="n">UIAlertAction</span> <span class="nl">actionWithTitle</span><span class="p">:</span><span class="s">@&quot;Open&quot;</span> <span class="nl">style</span><span class="p">:</span><span class="n">UIAlertActionStyleDefault</span> <span class="nl">handler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">UIAlertAction</span> <span class="o">*</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="p">@</span><span class="n">strongify</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
</span><span class='line'>                <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">viewModel</span><span class="p">.</span><span class="n">browserLoginCommand</span> <span class="nl">execute</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}]];</span>
</span><span class='line'>
</span><span class='line'>            <span class="p">[</span><span class="nb">self</span> <span class="nl">presentViewController</span><span class="p">:</span><span class="n">alertController</span> <span class="nl">animated</span><span class="p">:</span><span class="nb">YES</span> <span class="nl">completion</span><span class="p">:</span><span class="nb">NULL</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>观察 <code>viewModel</code> 中 <code>avatarURL</code> 属性的变化，然后设置 <code>avatarButton</code> 中的图片；</li>
<li>将 <code>viewModel</code> 中的 <code>username</code> 和 <code>password</code> 属性分别与 <code>usernameTextField</code> 和 <code>passwordTextField</code> 输入框中的内容进行绑定；</li>
<li>将 <code>loginButton</code> 的 <code>enabled</code> 属性与 <code>viewModel</code> 的 <code>validLoginSignal</code> 属性进行绑定；</li>
<li>在 <code>loginButton</code> 和 <code>browserLoginButton</code> 按钮被点击时分别执行 <code>loginCommand</code> 和 <code>browserLoginCommand</code> 命令。</li>
</ul>


<p>综上所述，我们将 <code>MRCLoginViewController</code> 中的展示逻辑抽取到 <code>MRCLoginViewModel</code> 中后，使得 <code>MRCLoginViewController</code> 中的代码更加简洁和清晰。实践 <code>MVVM</code> 的关键点在于，我们要能够分析清楚 <code>viewModel</code> 需要暴露给 <code>view</code> 的数据和命令，这些数据和命令能够代表 <code>view</code> 当前的状态。</p>

<h2>总结</h2>

<p>首先，我们从理论出发介绍了 <code>MVC</code> 和 <code>MVVM</code> 各自的概念以及从 <code>MVC</code> 到 <code>MVVM</code> 的演进过程；接着，介绍了 <code>RAC</code> 在 <code>MVVM</code> 中的两个使用场景；最后，我们从实践的角度，重点介绍了一个使用 <code>MVVM</code> 和 <code>RAC</code> 开发的开源项目 <code>MVVMReactiveCocoa</code> 。总的来说，我认为 <code>iOS</code> 中的 <code>MVVM</code> 可以分为以下三种不同的实践程度，它们分别对应不同的适用场景：</p>

<ul>
<li><code>MVVM + KVO</code> ，适用于现有的 <code>MVC</code> 项目，想转换成 <code>MVVM</code> 但是不打算引入 <code>RAC</code> 作为 <code>binder</code> 的团队；</li>
<li><code>MVVM + RAC</code> ，适用于现有的 <code>MVC</code> 项目，想转换成 <code>MVVM</code> 并且打算引入 <code>RAC</code> 作为 <code>binder</code> 的团队；</li>
<li><code>MVVM + RAC + ViewModel-Based Navigation</code> ，适用于全新的项目，想实践 <code>MVVM</code> 并且打算引入 <code>RAC</code> 作为 <code>binder</code> ，然后也想实践 <code>ViewModel-Based Navigation</code> 的团队。</li>
</ul>


<p>写在最后，希望这篇文章能够打消你对 <code>MVVM</code> 模式的顾虑，赶快行动起来吧。</p>

<h2>参考链接</h2>

<p><a href="https://www.objc.io/issues/13-architecture/mvvm/">https://www.objc.io/issues/13-architecture/mvvm/</a>
<br>
<a href="https://msdn.microsoft.com/en-us/library/hh848246.aspx">https://msdn.microsoft.com/en-us/library/hh848246.aspx</a>
<br>
<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel">https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel</a>
<br>
<a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.p6n56kyc4">https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.p6n56kyc4</a>
<br>
<a href="http://cocoasamurai.blogspot.ru/2013/03/basic-mvvm-with-reactivecocoa.html">http://cocoasamurai.blogspot.ru/2013/03/basic-mvvm-with-reactivecocoa.html</a>
<br>
<a href="http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction/">http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction/</a></p>

<p><img src="http://blog.leichunfeng.com/images/wechat_pay.jpg" width="260" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa v2.5 源码解析之架构总览]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/"/>
    <updated>2015-12-25T20:44:27+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan</id>
    <content type="html"><![CDATA[<p><code>ReactiveCocoa</code> 是一个 <code>iOS</code> 中的函数式响应式编程框架，它受 <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">Functional Reactive Programming</a> 的启发，是 <a href="https://github.com/jspahrsummers">Justin Spahr-Summers</a> 和 <a href="https://github.com/joshaber">Josh Abernathy</a> 在开发 <a href="https://desktop.github.com/">GitHub for Mac</a> 过程中的一个副产品，它提供了一系列用来组合和转换值流的 <code>API</code> 。</p>

<p><a href="https://github.com/mattt">Mattt Thompson</a> 大神是这样评价 <code>ReactiveCocoa</code> 的：</p>

<blockquote><p>Breaking from a tradition of covering Apple APIs exclusively, this edition of NSHipster will look at an open source project that exemplifies this brave new era for Objective-C.</p></blockquote>

<p>他认为 <code>ReactiveCocoa</code> 打破了苹果 <code>API</code> 排他性的束缚，勇敢地开创了 <code>Objective-C</code> 的新纪元，具有划时代的意义。不得不说，这对于一个第三方框架来说，已经是非常高的评价了。</p>

<p>关于 <code>ReactiveCocoa</code> 的版本演进历程，简单介绍如下：</p>

<ul>
<li><code>&lt;= v2.5</code> ：<code>Objective-C</code> ；</li>
<li><code>v3.x</code> ：<code>Swift 1.2</code> ；</li>
<li><code>v4.x</code> ：<code>Swift 2.x</code> 。</li>
</ul>


<p><strong>注</strong>：本文所介绍的均为 <code>ReactiveCocoa v2.5</code> 版本中的内容，这是 <code>Objective-C</code> 最新的稳定版本。另外，本文的目录结构如下：</p>

<ul>
<li>简介</li>
<li>信号源

<ul>
<li>RACStream</li>
<li>RACSignal</li>
<li>RACSubject</li>
<li>RACSequence</li>
</ul>
</li>
<li>订阅者

<ul>
<li>RACSubscriber</li>
<li>RACMulticastConnection</li>
</ul>
</li>
<li>调度器

<ul>
<li>RACScheduler</li>
</ul>
</li>
<li>清洁工

<ul>
<li>RACDisposable</li>
</ul>
</li>
<li>总结</li>
<li>参考链接</li>
</ul>


<h2>简介</h2>

<p><code>ReactiveCocoa</code> 是一个非常复杂的框架，在正式开始介绍它的核心组件前，我们先来看看它的类图，以便从宏观上了解它的层次结构：</p>

<p><img src="http://blog.leichunfeng.com/images/ReactiveCocoa%20v2.5.png" alt="ReactiveCocoa v2.5" /></p>

<p>从上面的类图中，我们可以看出，<code>ReactiveCocoa</code> 主要由以下四大核心组件构成：</p>

<ul>
<li>信号源：<code>RACStream</code> 及其子类；</li>
<li>订阅者：<code>RACSubscriber</code> 的实现类及其子类；</li>
<li>调度器：<code>RACScheduler</code> 及其子类；</li>
<li>清洁工：<code>RACDisposable</code> 及其子类。</li>
</ul>


<p>其中，信号源又是最核心的部分，其他组件都是围绕它运作的。</p>

<p>对于一个应用来说，绝大部分的时间都是在等待某些事件的发生或响应某些状态的变化，比如用户的触摸事件、应用进入后台、网络请求成功刷新界面等等，而维护这些状态的变化，常常会使代码变得非常复杂，难以扩展。而 <code>ReactiveCocoa</code> 给出了一种非常好的解决方案，它使用信号来代表这些异步事件，提供了一种统一的方式来处理所有异步的行为，包括代理方法、<code>block</code> 回调、<code>target-action</code> 机制、通知、<code>KVO</code> 等：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 代理方法</span>
</span><span class='line'><span class="p">[[</span><span class="nb">self</span>
</span><span class='line'>    <span class="nl">rac_signalForSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">webViewDidStartLoad</span><span class="p">:)</span>
</span><span class='line'>    <span class="nl">fromProtocol</span><span class="p">:@</span><span class="n">protocol</span><span class="p">(</span><span class="bp">UIWebViewDelegate</span><span class="p">)]</span>
</span><span class='line'>    <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 实现 webViewDidStartLoad: 代理方法</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// target-action</span>
</span><span class='line'><span class="p">[[</span><span class="nb">self</span><span class="p">.</span><span class="n">avatarButton</span>
</span><span class='line'>    <span class="nl">rac_signalForControlEvents</span><span class="p">:</span><span class="n">UIControlEventTouchUpInside</span><span class="p">]</span>
</span><span class='line'>    <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">UIButton</span> <span class="o">*</span><span class="n">avatarButton</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// avatarButton 被点击了</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 通知</span>
</span><span class='line'><span class="p">[[[</span><span class="bp">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span>
</span><span class='line'>    <span class="nl">rac_addObserverForName</span><span class="p">:</span><span class="n">kReachabilityChangedNotification</span> <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span><span class="p">]</span>
</span><span class='line'>    <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSNotification</span> <span class="o">*</span><span class="n">notification</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 收到 kReachabilityChangedNotification 通知</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// KVO</span>
</span><span class='line'><span class="p">[</span><span class="n">RACObserve</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span> <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">username</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 用户名发生了变化</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>然而，这些还只是 <code>ReactiveCocoa</code> 的冰山一角，它真正强大的地方在于我们可以对这些不同的信号进行任意地组合和链式操作，从最原始的输入 <code>input</code> 开始直至得到最终的输出 <code>output</code> 为止：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[[[</span><span class="n">RACSignal</span>
</span><span class='line'>    <span class="nl">combineLatest</span><span class="p">:</span><span class="l">@[</span> <span class="n">RACObserve</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">username</span><span class="p">),</span> <span class="n">RACObserve</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">password</span><span class="p">)</span> <span class="l">]</span>
</span><span class='line'>    <span class="nl">reduce</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">username</span><span class="p">,</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">password</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="l">@(</span><span class="n">username</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">password</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="l">)</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}]</span>
</span><span class='line'>    <span class="n">distinctUntilChanged</span><span class="p">]</span>
</span><span class='line'>    <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">valid</span><span class="p">.</span><span class="n">boolValue</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 用户名和密码合法，登录按钮可用</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 用户名或密码不合法，登录按钮不可用</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，对于 <code>ReactiveCocoa</code> 来说，我们可以毫不夸张地说，阻碍它发挥的瓶颈就只剩下你的想象力了。</p>

<h2>信号源</h2>

<p>在 <code>ReactiveCocoa</code> 中，信号源代表的是随着时间而改变的值流，这是对 <code>ReactiveCocoa</code> 最精准的概括，订阅者可以通过订阅信号源来获取这些值：</p>

<blockquote><p>Streams of values over time.</p></blockquote>

<p>你可以把它想象成水龙头中的水，当你打开水龙头时，水源源不断地流出来；你也可以把它想象成电，当你插上插头时，电静静地充到你的手机上；你还可以把它想象成运送玻璃珠的管道，当你打开阀门时，珠子一个接一个地到达。这里的水、电、玻璃珠就是我们所需要的值，而打开水龙头、插上插头、打开阀门就是订阅它们的过程。</p>

<h3>RACStream</h3>

<p><code>RACStream</code> 是 <code>ReactiveCocoa</code> 中最核心的类，代表的是任意的值流，它是整个 <code>ReactiveCocoa</code> 得以建立的基石，下面是它的继承结构图：</p>

<p><img src="http://blog.leichunfeng.com/images/RACStream.png" alt="RACStream" /></p>

<p>事实上，<code>RACStream</code> 是一个抽象类，通常情况下，我们并不会去实例化它，而是直接使用它的两个子类 <code>RACSignal</code> 和 <code>RACSequence</code> 。那么，问题来了，为什么 <code>RACStream</code> 会被设计成一个抽象类？或者说它的抽象过程是以什么作为依据的呢？</p>

<p>是的，没错，看过我上一篇文章 <a href="http://blog.leichunfeng.com/blog/2015/11/08/functor-applicative-and-monad/">《Functor、Applicative 和 Monad》</a> 的同学，应该已经知道了，<code>RACStream</code> 就是以 <code>Monad</code> 的概念为依据进行设计的，它代表的就是一个 <code>Monad</code> ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">/// An abstract class representing any stream of values.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// This class represents a monad, upon which many stream-based operations can</span>
</span><span class='line'><span class="c1">/// be built.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// When subclassing RACStream, only the methods in the main @interface body need</span>
</span><span class='line'><span class="c1">/// to be overridden.</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">RACStream</span> : <span class="bp">NSObject</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// Lifts `value` into the stream monad.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// Returns a stream containing only the given value.</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">return:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">value</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// Lazily binds a block to the values in the receiver.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// This should only be used if you need to terminate the bind early, or close</span>
</span><span class='line'><span class="c1">/// over some state. -flattenMap: is more appropriate for all other cases.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// block - A block returning a RACStreamBindBlock. This block will be invoked</span>
</span><span class='line'><span class="c1">///         each time the bound stream is re-evaluated. This block must not be</span>
</span><span class='line'><span class="c1">///         nil or return nil.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// Returns a new stream which represents the combined result of all lazy</span>
</span><span class='line'><span class="c1">/// applications of `block`.</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">bind:</span><span class="p">(</span><span class="n">RACStreamBindBlock</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>有了 <code>Monad</code> 作为基石后，许多基于流的操作就可以被建立起来了，比如 <code>map</code> 、<code>filter</code> 、<code>zip</code> 等。</p>

<h3>RACSignal</h3>

<p><code>RACSignal</code> 代表的是未来将会被传送的值，它是一种 <code>push-driven</code> 的流。<code>RACSignal</code> 可以向订阅者发送三种不同类型的事件：</p>

<ul>
<li><code>next</code> ：<code>RACSignal</code> 通过 <code>next</code> 事件向订阅者传送新的值，并且这个值可以为 <code>nil</code> ；</li>
<li><code>error</code> ：<code>RACSignal</code> 通过 <code>error</code> 事件向订阅者表明信号在正常结束前发生了错误；</li>
<li><code>completed</code> ：<code>RACSignal</code> 通过 <code>completed</code> 事件向订阅者表明信号已经正常结束，不会再有后续的值传送给订阅者。</li>
</ul>


<p><strong>注意</strong>，<code>ReactiveCocoa</code> 中的值流只包含正常的值，即通过 <code>next</code> 事件传送的值，并不包括 <code>error</code> 和 <code>completed</code> 事件，它们需要被特殊处理。通常情况下，一个信号的生命周期是由任意个 <code>next</code> 事件和一个 <code>error</code> 事件或一个 <code>completed</code> 事件组成的。</p>

<p>从前面的类图中，我们可以看出，<code>RACSignal</code> 并非只有一个类，事实上，它的一系列功能是通过类簇来实现的。除去我们将在下节介绍的 <code>RACSubject</code> 及其子类外，<code>RACSignal</code> 还有五个用来实现不同功能的私有子类：</p>

<ul>
<li><code>RACEmptySignal</code> ：空信号，用来实现 <code>RACSignal</code> 的 <code>+empty</code> 方法；</li>
<li><code>RACReturnSignal</code> ：一元信号，用来实现 <code>RACSignal</code> 的 <code>+return:</code> 方法；</li>
<li><code>RACDynamicSignal</code> ：动态信号，使用一个 <code>block</code> 来实现订阅行为，我们在使用 <code>RACSignal</code> 的 <code>+createSignal:</code> 方法时创建的就是该类的实例；</li>
<li><code>RACErrorSignal</code> ：错误信号，用来实现 <code>RACSignal</code> 的 <code>+error:</code> 方法；</li>
<li><code>RACChannelTerminal</code> ：通道终端，代表 <code>RACChannel</code> 的一个终端，用来实现双向绑定。</li>
</ul>


<p>对于 <code>RACSignal</code> 类簇来说，最核心的方法莫过于 <code>-subscribe:</code> 了，这个方法封装了订阅者对信号源的一次订阅过程，它是订阅者与信号源产生联系的唯一入口。因此，对于 <code>RACSignal</code> 的所有子类来说，这个方法的实现逻辑就代表了该子类的具体订阅行为，是区分不同子类的关键所在。同时，这也是为什么 <code>RACSignal</code> 中的 <code>-subscribe:</code> 方法是一个抽象方法，并且必须要让子类实现的原因：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">RACDisposable</span> <span class="o">*</span><span class="p">)</span><span class="nf">subscribe:</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">RACSubscriber</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">subscriber</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">NSCAssert</span><span class="p">(</span><span class="nb">NO</span><span class="p">,</span> <span class="s">@&quot;This method must be overridden by subclasses&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>RACSubject</h3>

<p><code>RACSubject</code> 代表的是可以手动控制的信号，我们可以把它看作是 <code>RACSignal</code> 的可变版本，就好比 <code>NSMutableArray</code> 是 <code>NSArray</code> 的可变版本一样。<code>RACSubject</code> 继承自 <code>RACSignal</code> ，所以它可以作为信号源被订阅者订阅，同时，它又实现了 <code>RACSubscriber</code> 协议，所以它也可以作为订阅者订阅其他信号源，这个就是 <code>RACSubject</code> 为什么可以手动控制的原因：</p>

<p><img src="http://blog.leichunfeng.com/images/RACSubject.png" width="650" /></p>

<p>根据官方的 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/Documentation/DesignGuidelines.md#avoid-using-subjects-when-possible">Design Guidelines</a> 中的说法，我们应该尽可能少地使用它。因为它太过灵活，我们可以在任何时候任何地方操作它，所以一旦过度使用，就会使代码变得非常复杂，难以理解。</p>

<p>根据我的实际使用经验，在 <code>MVVM</code> 中使用 <code>RACSubject</code> 可以非常方便地实现统一的错误处理逻辑。比如，我们可以在 <code>viewModel</code> 的基类中声明一个 <code>RACSubject</code> 类型的属性 <code>errors</code> ，然后在 <code>viewController</code> 的基类中编写统一的错误处理逻辑：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">viewModel</span><span class="p">.</span><span class="n">errors</span> <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 错误处理逻辑</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>此时，假设在某个界面的 <code>viewModel</code> 中有三个用来请求远程数据的命令，分别是 <code>requestReadmeMarkdownCommand</code> 、<code>requestBlobCommand</code> 和 <code>requestReadmeHTMLCommand</code> ，那么这个界面的错误处理逻辑就可以这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[[</span><span class="n">RACSignal</span>
</span><span class='line'>    <span class="nl">merge</span><span class="p">:</span><span class="l">@[</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">requestReadmeMarkdownCommand</span><span class="p">.</span><span class="n">errors</span><span class="p">,</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">requestBlobCommand</span><span class="p">.</span><span class="n">errors</span><span class="p">,</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">requestReadmeHTMLCommand</span><span class="p">.</span><span class="n">errors</span>
</span><span class='line'>    <span class="l">]</span><span class="p">]</span>
</span><span class='line'>    <span class="nl">subscribe</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">errors</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外，<code>RACSubject</code> 也有三个用来实现不同功能的子类：</p>

<ul>
<li><code>RACGroupedSignal</code> ：分组信号，用来实现 <code>RACSignal</code> 的分组功能；</li>
<li><code>RACBehaviorSubject</code> ：重演最后值的信号，当被订阅时，会向订阅者发送它最后接收到的值；</li>
<li><code>RACReplaySubject</code> ：重演信号，保存发送过的值，当被订阅时，会向订阅者重新发送这些值。</li>
</ul>


<p><code>RACSubject</code> 的功能非常强大，但是太过灵活，也正是因为如此，我们只有在迫不得已的情况下才会使用它。</p>

<h3>RACSequence</h3>

<p><code>RACSequence</code> 代表的是一个不可变的值的序列，与 <code>RACSignal</code> 不同，它是 <code>pull-driven</code> 类型的流。从严格意义上讲，<code>RACSequence</code> 并不能算作是信号源，因为它并不能像 <code>RACSignal</code> 那样，可以被订阅者订阅，但是它与 <code>RACSignal</code> 之间可以非常方便地进行转换。</p>

<p>从理论上说，一个 <code>RACSequence</code> 由两部分组成：</p>

<ul>
<li><code>head</code> ：指的是序列中的第一个对象，如果序列为空，则为 <code>nil</code> ；</li>
<li><code>tail</code> ：指的是序列中除第一个对象外的其它所有对象，同样的，如果序列为空，则为 <code>nil</code> 。</li>
</ul>


<p>事实上，一个序列的 <code>tail</code> 仍然是一个序列，如果我们将序列看作是一条毛毛虫，那么 <code>head</code> 和 <code>tail</code> 可表示如下：</p>

<p><img src="http://blog.leichunfeng.com/images/listmonster.png" alt="listmonster" /></p>

<p>同样的，一个序列的 <code>tail</code> 也可以看作是由 <code>head</code> 和 <code>tail</code> 组成，而这个新的 <code>tail</code> 又可以继续看作是由 <code>head</code> 和 <code>tail</code> 组成，这个过程可以一直进行下去。而这个就是 <code>RACSequence</code> 得以建立的理论基础，所以一个 <code>RACSequence</code> 子类的最小实现就是 <code>head</code> 和 <code>tail</code> ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">/// Represents an immutable sequence of values. Unless otherwise specified, the</span>
</span><span class='line'><span class="c1">/// sequences&#39; values are evaluated lazily on demand. Like Cocoa collections,</span>
</span><span class='line'><span class="c1">/// sequences cannot contain nil.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// Most inherited RACStream methods that accept a block will execute the block</span>
</span><span class='line'><span class="c1">/// _at most_ once for each value that is evaluated in the returned sequence.</span>
</span><span class='line'><span class="c1">/// Side effects are subject to the behavior described in</span>
</span><span class='line'><span class="c1">/// +sequenceWithHeadBlock:tailBlock:.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// Implemented as a class cluster. A minimal implementation for a subclass</span>
</span><span class='line'><span class="c1">/// consists simply of -head and -tail.</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">RACSequence</span> : <span class="nc">RACStream</span> <span class="o">&lt;</span><span class="bp">NSCoding</span><span class="p">,</span> <span class="bp">NSCopying</span><span class="p">,</span> <span class="bp">NSFastEnumeration</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// The first object in the sequence, or nil if the sequence is empty.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// Subclasses must provide an implementation of this method.</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="kt">id</span> <span class="n">head</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// All but the first object in the sequence, or nil if the sequence is empty.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// Subclasses must provide an implementation of this method.</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">,</span> <span class="k">readonly</span><span class="p">)</span> <span class="n">RACSequence</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>总的来说，<code>RACSequence</code> 存在的最大意义就是为了简化 <code>Objective-C</code> 中的集合操作：</p>

<blockquote><p><strong>Simplifying Collection Transformations</strong>: Higher-order functions like map, filter, fold/reduce are sorely missing from Foundation.</p></blockquote>

<p>比如下面的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">str</span> <span class="k">in</span> <span class="n">strings</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">newString</span> <span class="o">=</span> <span class="p">[</span><span class="n">str</span> <span class="nl">stringByAppendingString</span><span class="p">:</span><span class="s">@&quot;foobar&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">results</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">newString</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以用 <code>RACSequence</code> 来优雅地实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">RACSequence</span> <span class="o">*</span><span class="n">results</span> <span class="o">=</span> <span class="p">[[</span><span class="n">strings</span><span class="p">.</span><span class="n">rac_sequence</span>
</span><span class='line'>    <span class="nl">filter</span><span class="p">:</span><span class="o">^</span> <span class="kt">BOOL</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}]</span>
</span><span class='line'>    <span class="nl">map</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">[</span><span class="n">str</span> <span class="nl">stringByAppendingString</span><span class="p">:</span><span class="s">@&quot;foobar&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，我们可以非常方便地使用 <code>RACSequence</code> 来实现集合的链式操作，直到得到你想要的最终结果为止。除此之外，使用 <code>RACSequence</code> 的另外一个主要好处是，<code>RACSequence</code> 中包含的值在默认情况下是懒计算的，即只有在真正用到的时候才会被计算，并且只会计算一次。也就是说，如果我们只用到了一个 <code>RACSequence</code> 中的部分值的时候，它就在不知不觉中提高了我们应用的性能。</p>

<p>同样的，<code>RACSequence</code> 的一系列功能也是通过类簇来实现的，它共有九个用来实现不同功能的私有子类：</p>

<ul>
<li><code>RACUnarySequence</code> ：一元序列，用来实现 <code>RACSequence</code> 的 <code>+return:</code> 方法；</li>
<li><code>RACIndexSetSequence</code> ：用来遍历索引集；</li>
<li><code>RACEmptySequence</code> ：空序列，用来实现 <code>RACSequence</code> 的 <code>+empty</code> 方法；</li>
<li><code>RACDynamicSequence</code> ：动态序列，使用 <code>blocks</code> 来动态地实现一个序列；</li>
<li><code>RACSignalSequence</code> ：用来遍历信号中的值；</li>
<li><code>RACArraySequence</code> ：用来遍历数组中的元素；</li>
<li><code>RACEagerSequence</code> ：非懒计算的序列，在初始化时立即计算所有的值；</li>
<li><code>RACStringSequence</code> ：用来遍历字符串中的字符；</li>
<li><code>RACTupleSequence</code> ：用来遍历元组中的元素。</li>
</ul>


<p><code>RACSequence</code> 为类簇提供了统一的对外接口，对于使用它的客户端代码来说，完全不需要知道私有子类的存在，很好地隐藏了实现细节。另外，值得一提的是，<code>RACSequence</code> 实现了快速枚举的协议 <code>NSFastEnumeration</code> ，在这个协议中只声明了一个看上去非常抽筋的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSUInteger</span><span class="p">)</span><span class="nf">countByEnumeratingWithState:</span><span class="p">(</span><span class="n">NSFastEnumerationState</span> <span class="o">*</span><span class="p">)</span><span class="nv">state</span> <span class="nf">objects:</span><span class="p">(</span><span class="kt">id</span> <span class="n">__unsafe_unretained</span> <span class="p">[])</span><span class="nv">buffer</span> <span class="nf">count:</span><span class="p">(</span><span class="bp">NSUInteger</span><span class="p">)</span><span class="nv">len</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>有兴趣的同学，可以看看 <code>RACSequence</code> 中的相关实现，我们将会在后续的文章中进行介绍。因此，我们也可以直接使用 <code>for in</code> 来遍历一个 <code>RACSequence</code> 。</p>

<h2>订阅者</h2>

<p>现在，我们已经知道信号源是什么了，为了获取信号源中的值，我们需要对信号源进行订阅。在 <code>ReactiveCocoa</code> 中，订阅者是一个抽象的概念，所有实现了 <code>RACSubscriber</code> 协议的类都可以作为信号源的订阅者。</p>

<h3>RACSubscriber</h3>

<p>在 <code>RACSubscriber</code> 协议中，声明了四个必须实现的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">/// Represents any object which can directly receive values from a RACSignal.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// You generally shouldn&#39;t need to implement this protocol. +[RACSignal</span>
</span><span class='line'><span class="c1">/// createSignal:], RACSignal&#39;s subscription methods, or RACSubject should work</span>
</span><span class='line'><span class="c1">/// for most uses.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// Implementors of this protocol may receive messages and values from multiple</span>
</span><span class='line'><span class="c1">/// threads simultaneously, and so should be thread-safe. Subscribers will also</span>
</span><span class='line'><span class="c1">/// be weakly referenced so implementations must allow that.</span>
</span><span class='line'><span class="k">@protocol</span> <span class="nc">RACSubscriber</span> <span class="o">&lt;</span><span class="bp">NSObject</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@required</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// Sends the next value to subscribers.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// value - The value to send. This can be `nil`.</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">sendNext</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">value</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// Sends the error to subscribers.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// error - The error to send. This can be `nil`.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// This terminates the subscription, and invalidates the subscriber (such that</span>
</span><span class='line'><span class="c1">/// it cannot subscribe to anything else in the future).</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sendError:</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">*</span><span class="p">)</span><span class="nv">error</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// Sends completed to subscribers.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// This terminates the subscription, and invalidates the subscriber (such that</span>
</span><span class='line'><span class="c1">/// it cannot subscribe to anything else in the future).</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sendCompleted</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// Sends the subscriber a disposable that represents one of its subscriptions.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// A subscriber may receive multiple disposables if it gets subscribed to</span>
</span><span class='line'><span class="c1">/// multiple signals; however, any error or completed events must terminate _all_</span>
</span><span class='line'><span class="c1">/// subscriptions.</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">didSubscribeWithDisposable:</span><span class="p">(</span><span class="n">RACCompoundDisposable</span> <span class="o">*</span><span class="p">)</span><span class="nv">disposable</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中 <code>-sendNext:</code> 、<code>-sendError:</code> 和 <code>-sendCompleted</code> 分别用来从 <code>RACSignal</code> 接收 <code>next</code> 、<code>error</code> 和 <code>completed</code> 事件，而 <code>-didSubscribeWithDisposable:</code> 则用来接收代表某次订阅的 <code>disposable</code> 对象。</p>

<p>订阅者对信号源的一次订阅过程可以抽象为：通过 <code>RACSignal</code> 的 <code>-subscribe:</code> 方法传入一个订阅者，并最终返回一个 <code>RACDisposable</code> 对象的过程：</p>

<p><img src="http://blog.leichunfeng.com/images/subscribe.png" width="480" /></p>

<p><strong>注意</strong>：在 <code>ReactiveCocoa</code> 中并没有专门的类 <code>RACSubscription</code> 来代表一次订阅，而间接地使用 <code>RACDisposable</code> 来充当这一角色。因此，一个 <code>RACDisposable</code> 对象就代表着一次订阅，并且我们可以用它来取消这次订阅，详细内容将会在下面的章节中进行介绍。</p>

<p>除了 <code>RACSignal</code> 的子类外，还有两个实现了 <code>RACSubscriber</code> 协议的类，如下图所示：</p>

<p><img src="http://blog.leichunfeng.com/images/RACSubscriber.png" width="450" /></p>

<p>其中，<code>RACSubscriber</code> 类的名字与 <code>RACSubscriber</code> 协议的名字相同，这跟 <code>Objective-C</code> 中的 <code>NSObject</code> 类的名字与 <code>NSObject</code> 协议的名字相同是一样一样的，除了名字相同外，然并卵。通常来说，<code>RACSubscriber</code> 类充当的角色就是信号源的真正订阅者，它老老实实地实现了 <code>RACSubscriber</code> 协议。</p>

<p>既然 <code>RACSubscriber</code> 类就是真正的订阅者，那么 <code>RACPassthroughSubscriber</code> 类又是干嘛用的呢？原来，在 <code>ReactiveCocoa</code> 中，一个订阅者是可以订阅多个信号源的，也就是说它会拥有多个 <code>RACDisposable</code> 对象，并且它可以随时取消其中任何一个订阅。为了实现这个功能，<code>ReactiveCocoa</code> 就引入了 <code>RACPassthroughSubscriber</code> 类，它是 <code>RACSubscriber</code> 类的一个装饰器，封装了一个真正的订阅者 <code>RACSubscriber</code> 对象，它负责转发所有事件给这个真正的订阅者，而当此次订阅被取消时，它就会停止转发：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sendNext:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">value</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">disposable</span><span class="p">.</span><span class="n">disposed</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>  <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">innerSubscriber</span> <span class="nl">sendNext</span><span class="p">:</span><span class="n">value</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sendError:</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">*</span><span class="p">)</span><span class="nv">error</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">disposable</span><span class="p">.</span><span class="n">disposed</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>  <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">innerSubscriber</span> <span class="nl">sendError</span><span class="p">:</span><span class="n">error</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sendCompleted</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">disposable</span><span class="p">.</span><span class="n">disposed</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>  <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">innerSubscriber</span> <span class="n">sendCompleted</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>事实上，在 <code>ReactiveCocoa</code> 中，我们倾向于隐藏订阅者，因为外界根本不需要知道订阅者的存在，这是内部的实现细节。这样做的主要目的是进一步简化信号源的订阅逻辑，客户端代码只需要关心它所需要的值就可以了，根本不需要关心内部的订阅过程。</p>

<h3>RACMulticastConnection</h3>

<p>通常来说，我们在订阅一个信号源的过程中可能会产生副作用或者消耗比较大的资源，比如修改全局变量、发送网络请求等。这个时候，我们往往需要让多个订阅者之间共享一次订阅，就好比我们读高中时，多个好朋友一起订阅一份英语周报，然后只要出一份钱，是一个道理。这就是 <code>ReactiveCocoa</code> 中引入 <code>RACMulticastConnection</code> 类的原因。</p>

<p><code>RACMulticastConnection</code> 通过一个标志 <code>_hasConnected</code> 来保证只对 <code>sourceSignal</code> 订阅一次，然后对外暴露一个 <code>RACSubject</code> 类型的 <code>signal</code> 供外部订阅者订阅。这样一来，不管外部订阅者对 <code>signal</code> 订阅多少次，我们对 <code>sourceSignal</code> 的订阅至多只会有一次：</p>

<p><img src="http://blog.leichunfeng.com/images/RACMulticastConnection.png" alt="RACMulticastConnection" /></p>

<p><strong>注</strong>：了解 <code>RACMulticastConnection</code> 的实现原理，对于我们后面理解 <code>-replay</code> 、<code>replayLast</code> 和 <code>replayLazily</code> 等方法非常有帮助。</p>

<h2>调度器</h2>

<p>有了信号源和订阅者，我们还需要由调度器来统一调度订阅者订阅信号源的过程中所涉及到的任务，这样才能保证所有的任务都能够合理有序地执行。</p>

<h3>RACScheduler</h3>

<p><code>RACScheduler</code> 在 <code>ReactiveCocoa</code> 中就是扮演着调度器的角色，本质上，它就是用 <code>GCD</code> 的串行队列来实现的，并且支持取消操作。是的，在 <code>ReactiveCocoa</code> 中，并没有使用到 <code>NSOperationQueue</code> 和 <code>NSRunloop</code> 等技术，<code>RACScheduler</code> 也只是对 <code>GCD</code> 的简单封装而已。</p>

<p>同样的，<code>RACScheduler</code> 的一系列功能也是通过类簇来实现的，除了用来测试的子类外，总共还有四个私有子类：</p>

<p><img src="http://blog.leichunfeng.com/images/RACScheduler.png" width="650" /></p>

<p>咋看之下，<code>RACScheduler</code> 的儿子貌似还不少，但是真正出力干活的却真心不多，主要就是 <code>RACTargetQueueScheduler</code> 子类：</p>

<ul>
<li><code>RACImmediateScheduler</code> ：立即执行调度的任务，这是唯一一个支持同步执行的调度器；</li>
<li><code>RACQueueScheduler</code> ：一个抽象的队列调度器，在一个 <code>GCD</code> 串行列队中异步调度所有任务；</li>
<li><code>RACTargetQueueScheduler</code> ：继承自 <code>RACQueueScheduler</code> ，在一个以一个任意的 <code>GCD</code> 队列为 <code>target</code> 的串行队列中异步调度所有任务；</li>
<li><code>RACSubscriptionScheduler</code> ：一个只用来调度订阅的调度器。</li>
</ul>


<p>值得一提的是，在 <code>RACScheduler</code> 中有一个非常特殊的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">RACDisposable</span> <span class="o">*</span><span class="p">)</span><span class="nf">scheduleRecursiveBlock:</span><span class="p">(</span><span class="n">RACSchedulerRecursiveBlock</span><span class="p">)</span><span class="nv">recursiveBlock</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个方法的作用非常有意思，它可以将递归调用转换成迭代调用，这样做的目的是为了解决深层次的递归调用可能会带来的堆栈溢出问题。</p>

<h2>清洁工</h2>

<p>正如我们前面所说的，在订阅者订阅信号源的过程中，可能会产生副作用或者消耗一定的资源，所以当我们在取消订阅或者完成订阅时，我们就需要做一些资源回收和垃圾清理的工作。</p>

<h3>RACDisposable</h3>

<p><code>RACDisposable</code> 在 <code>ReactiveCocoa</code> 中就充当着清洁工的角色，它封装了取消和清理一次订阅所必需的工作。它有一个核心的方法 <code>-dispose</code> ，调用这个方法就会执行相应的清理工作，这有点类似于 <code>NSObject</code> 的 <code>-dealloc</code> 方法。<code>RACDisposable</code> 总共有四个子类，它的继承结构图如下：</p>

<p><img src="http://blog.leichunfeng.com/images/RACDisposable.png" width="450" /></p>

<ul>
<li><code>RACSerialDisposable</code> ：作为 <code>disposable</code> 的容器使用，可以包含一个 <code>disposable</code> 对象，并且允许将这个 <code>disposable</code> 对象通过原子操作交换出来；</li>
<li><code>RACKVOTrampoline</code> ：代表一次 <code>KVO</code> 观察，并且可以用来停止观察；</li>
<li><code>RACCompoundDisposable</code> ：跟 <code>RACSerialDisposable</code> 一样，<code>RACCompoundDisposable</code> 也是作为 <code>disposable</code> 的容器使用。不同的是，它可以包含多个 <code>disposable</code> 对象，并且支持手动添加和移除 <code>disposable</code> 对象，有点类似于可变数组 <code>NSMutableArray</code> 。而当一个 <code>RACCompoundDisposable</code> 对象被 <code>disposed</code> 时，它会调用其所包含的所有 <code>disposable</code> 对象的 <code>-dispose</code> 方法，有点类似于 <code>autoreleasepool</code> 的作用;</li>
<li><code>RACScopedDisposable</code> ：当它被 <code>dealloc</code> 的时候调用本身的 <code>-dispose</code> 方法。</li>
</ul>


<p>咋看之下，<code>RACDisposable</code> 的逻辑似乎有些复杂，不过换汤不换药，不管它们怎么换着花样玩，最终都只是为了能够在合适的时机调用 <code>disposable</code> 对象的 <code>-dispose</code> 方法，执行清理工作而已。</p>

<h2>总结</h2>

<p>至此，我们介绍完了 <code>ReactiveCocoa</code> 的四大核心组件，对它的架构有了宏观上的认识。它建立于 <code>Monad</code> 的概念之上，然后围绕其搭建了一系列完整的配套组件，它们共同支撑了 <code>ReactiveCocoa</code> 的强大功能。尽管，<code>ReactiveCocoa</code> 是一个重型的函数式响应式框架，但是它并不会对我们现有的代码构成侵略性，我们完全可以在一个单独的类中使用它，哪怕只是简单的一行代码，也是没有问题的。所以，如果你对 <code>ReactiveCocoa</code> 感兴趣的话，不妨就从现在开始尝试吧，Let&rsquo;s go ！</p>

<p><strong>PS</strong>：<a href="https://github.com/leichunfeng/MVVMReactiveCocoa">MVVMReactiveCocoa</a> 是我用 <code>MVVM</code> + <code>RAC</code> 编写的一个开源应用，如果你有兴趣的话不妨 <code>clone</code> 下来看看 <code>ReactiveCocoa</code> 的具体实践吧。</p>

<h2>参考链接</h2>

<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/tree/v2.5">https://github.com/ReactiveCocoa/ReactiveCocoa/tree/v2.5</a>
<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/Documentation/FrameworkOverview.md">https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/Documentation/FrameworkOverview.md</a>
<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/Documentation/DesignGuidelines.md#avoid-using-subjects-when-possible">https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/Documentation/DesignGuidelines.md#avoid-using-subjects-when-possible</a>
<a href="http://nshipster.com/reactivecocoa/">http://nshipster.com/reactivecocoa/</a>
<a href="http://nathanli.cn/2015/08/27/reactivecocoa2-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/">http://nathanli.cn/2015/08/27/reactivecocoa2-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</a>
<a href="http://blog.devtang.com/blog/2014/02/11/reactivecocoa-introduction/">http://blog.devtang.com/blog/2014/02/11/reactivecocoa-introduction/</a>
<a href="http://m.oschina.net/blog/294178">http://m.oschina.net/blog/294178</a></p>

<p><img src="http://blog.leichunfeng.com/images/wechat_pay.jpg" width="260" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Functor、Applicative 和 Monad]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/11/08/functor-applicative-and-monad/"/>
    <updated>2015-11-08T10:53:16+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/11/08/functor-applicative-and-monad</id>
    <content type="html"><![CDATA[<p><code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 是函数式编程语言中三个非常重要的概念，尤其是 <code>Monad</code> ，难倒了不知道多少英雄好汉。事实上，它们的概念是非常简单的，但是却很少有文章能够将它们描述清楚，往往还适得其反，越描越黑。与其它文章不同的是，本文将从结论出发，层层深入，一步步为你揭开它们的神秘面纱。</p>

<p><strong>说明</strong>：本文中的主要代码为 <a href="https://www.haskell.org">Haskell</a> 语言，它是一门纯函数式的编程语言。其中，具体的语法细节，我们不需要太过关心，因为这并不影响你对本文的理解。</p>

<h2>结论</h2>

<p>关于 <code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 的概念，其实各用一句话就可以概括：</p>

<ol>
<li>一个 <code>Functor</code> 就是一种实现了 <code>Functor typeclass</code> 的数据类型；</li>
<li>一个 <code>Applicative</code> 就是一种实现了 <code>Applicative typeclass</code> 的数据类型；</li>
<li>一个 <code>Monad</code> 就是一种实现了 <code>Monad typeclass</code> 的数据类型。</li>
</ol>


<p>当然，你可能会问那什么是 <a href="http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101">typeclass</a> 呢？我想当你在看到<strong>实现</strong>二字的时候，就应该已经猜到了：</p>

<blockquote><p>A typeclass is a sort of interface that defines some behavior. If a type is a part of a typeclass, that means that it supports and implements the behavior the typeclass describes. A lot of people coming from OOP get confused by typeclasses because they think they are like classes in object oriented languages. Well, they&rsquo;re not. You can think of them kind of as Java interfaces, only better.</p></blockquote>

<p>是的，<code>typeclass</code> 就类似于 <code>Java</code> 中的接口，或者 <code>Objective-C</code> 中的协议。在 <code>typeclass</code> 中定义了一些函数，实现一个 <code>typeclass</code> 就是要实现这些函数，而所有实现了这个 <code>typeclass</code> 的数据类型都会拥有这些共同的行为。</p>

<p>那 <code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 三者之间有什么联系吗，为什么它们老是结队出现呢？其实，<code>Applicative</code> 是增强型的 <code>Functor</code> ，一种数据类型要成为 <code>Applicative</code> 的前提条件是它必须是 <code>Functor</code> ；同样的，<code>Monad</code> 是增强型的 <code>Applicative</code> ，一种数据类型要成为 <code>Monad</code> 的前提条件是它必须是 <code>Applicative</code> 。<strong>注</strong>：这个联系，在我们看到 <code>Applicative typeclass</code> 和 <code>Monad typeclass</code> 的定义时，自然就会明了。</p>

<h2>Maybe</h2>

<p>在正式开始介绍 <code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 的定义前，我想先介绍一种非常有意思的数据类型，<a href="https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.1.0/Data-Maybe.html">Maybe</a> 类型（可类比 <code>Swift</code> 中的 <code>Optional</code>）：</p>

<blockquote><p>The Maybe type encapsulates an optional value. A value of type Maybe a either contains a value of type a (represented as Just a), or it is empty (represented as Nothing). Using Maybe is a good way to deal with errors or exceptional cases without resorting to drastic measures such as error.</p></blockquote>

<p><code>Maybe</code> 类型封装了一个可选值。一个 <code>Maybe a</code> 类型的值要么包含一个 <code>a</code> 类型的值（用 <code>Just a</code> 表示）；要么为空（用 <code>Nothing</code> 表示）。我们可以把 <code>Maybe</code> 看作一个盒子，这个盒子里面可能装着一个 <code>a</code> 类型的值，即 <code>Just a</code> ；也可能是一个空盒子，即 <code>Nothing</code> 。或者，你也可以把它理解成泛型，比如 <code>Objective-C</code> 中的 <code>NSArray&lt;ObjectType&gt;</code> 。不过，最正确的理解应该是把 <code>Maybe</code> 看作一个上下文，这个上下文表示某次计算可能成功也可能失败，成功时用 <code>Just a</code> 表示，<code>a</code> 为计算结果；失败时用 <code>Nothing</code> 表示，这就是 <code>Maybe</code> 类型存在的意义：</p>

<p><img src="http://blog.leichunfeng.com/images/maybe.png" alt="maybe" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">data</span> <span class="n">Maybe</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Nothing</span> <span class="o">|</span> <span class="n">Just</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面，我们来直观地感受一下 <code>Maybe</code> 类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">Nothing</span>
</span><span class='line'><span class="n">Nothing</span>
</span><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">Just</span> <span class="mi">2</span>
</span><span class='line'><span class="n">Just</span> <span class="mi">2</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以用盒子模型来理解一下，<code>Nothing</code> 就是一个空盒子；而 <code>Just 2</code> 则是一个装着 <code>2</code> 这个值的盒子：</p>

<p><img src="http://blog.leichunfeng.com/images/just2.png" alt="just2" /></p>

<p><strong>提前剧透</strong>：<code>Maybe</code> 类型实现了 <code>Functor typeclass</code>、<code>Applicative typeclass</code> 和 <code>Monad typeclass</code> ，所以它同时是 <code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> ，具体实现细节将在下面的章节进行介绍。</p>

<h2>Functor</h2>

<p>在正式开始介绍 <code>Functor</code> 前，我们先思考一个这样的问题，假如我们有一个值 <code>2</code> ：</p>

<p><img src="http://blog.leichunfeng.com/images/normal2.png" alt="normal2" /></p>

<p>我们如何将函数 <code>(+3)</code> 应用到这个值上呢？我想上过小学的朋友应该都知道，这就是一个简单的加法运算：</p>

<p><img src="http://blog.leichunfeng.com/images/value_apply.png" alt="value_apply" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="mi">2</span>
</span><span class='line'><span class="mi">5</span>
</span></code></pre></td></tr></table></div></figure>


<p>分分钟搞定。那么问题来了，如果这个值 <code>2</code> 是在一个上下文中呢？比如 <code>Maybe</code> ，此时，这个值 <code>2</code> 就变成了 <code>Just 2</code> ：</p>

<p><img src="http://blog.leichunfeng.com/images/just2.png" alt="just2" /></p>

<p>这个时候，我们就不能直接将函数 <code>(+3)</code> 应用到 <code>Just 2</code> 了。那么，我们如何将一个函数应用到一个在上下文中的值呢？</p>

<p><img src="http://blog.leichunfeng.com/images/fmap.png" alt="fmap" /></p>

<p>是的，我想你应该已经猜到了，<code>Functor</code> 就是干这事的，欲知后事如何，请看下节分解。</p>

<h3>Functor typeclass</h3>

<p>首先，我们来看一下 <code>Functor typeclass</code> 的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Functor</span> <span class="n">f</span> <span class="n">where</span>
</span><span class='line'>    <span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 <code>Functor typeclass</code> 中定义了一个函数 <code>fmap</code> ，它将一个函数 <code>(a -&gt; b)</code> 应用到一个在上下文中的值 <code>f a</code> ，并返回另一个在相同上下文中的值 <code>f b</code> ，这里的 <code>f</code> 是一个类型占位符，表示任意类型的 <code>Functor</code> 。</p>

<p><strong>注</strong>：<code>fmap</code> 函数可类比 <code>Swift</code> 中的 <code>map</code> 方法。</p>

<h3>Maybe Functor</h3>

<p>我们知道 <code>Maybe</code> 类型就是一个 <code>Functor</code> ，它实现了 <code>Functor typeclass</code> 。我们将类型占位符 <code>f</code> 用具体类型 <code>Maybe</code> 代入可得：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Functor</span> <span class="n">Maybe</span> <span class="n">where</span>
</span><span class='line'>    <span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，对于 <code>Maybe</code> 类型来说，它要实现的函数 <code>fmap</code> 的功能就是将一个函数 <code>(a -&gt; b)</code> 应用到一个在 <code>Maybe</code> 上下文中的值 <code>Maybe a</code> ，并返回另一个在 <code>Maybe</code> 上下文中的值 <code>Maybe b</code> 。接下来，我们一起来看一下 <code>Maybe</code> 类型实现 <code>Functor typeclass</code> 的具体细节：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">instance</span> <span class="n">Functor</span> <span class="n">Maybe</span> <span class="n">where</span>
</span><span class='line'>    <span class="n">fmap</span> <span class="n">func</span> <span class="p">(</span><span class="n">Just</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">Just</span> <span class="p">(</span><span class="n">func</span> <span class="n">x</span><span class="p">)</span>
</span><span class='line'>    <span class="n">fmap</span> <span class="n">func</span> <span class="n">Nothing</span>  <span class="o">=</span> <span class="n">Nothing</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里针对 <code>Maybe</code> 上下文的两种情况分别进行了处理：如果盒子中有值，即 <code>Just x</code> ，那么就将 <code>x</code> 从盒子中取出，然后将函数 <code>func</code> 应用到 <code>x</code> ，最后将结果放入一个相同类型的新盒子中；如果盒子为空，那么直接返回一个新的空盒子。</p>

<p>看到这里，我想你应该已经知道如何将一个函数应用到一个在上下文中的值了。比如前面提到的将函数 <code>(+3)</code> 应用到 <code>Just 2</code> ：</p>

<p><img src="http://blog.leichunfeng.com/images/fmap_just.png" alt="fmap_just" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="n">Just</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="n">Just</span> <span class="mi">5</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外，值得一提的是，当我们将函数 <code>(+3)</code> 应用到一个空盒子，即 <code>Nothing</code> 时，我们将会得到一个新的空盒子：</p>

<p><img src="http://blog.leichunfeng.com/images/fmap_nothing.png" alt="fmap_nothing" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="n">Nothing</span>
</span><span class='line'><span class="n">Nothing</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Applicative</h2>

<p>现在，我们已经知道如何将函数 <code>(+3)</code> 应用到 <code>Just 2</code> 了。那么问题又来了，如果函数 <code>(+3)</code> 也在上下文中呢，比如 <code>Maybe</code> ，此时，函数 <code>(+3)</code> 就变成了 <code>Just (+3)</code> ：</p>

<p><img src="http://blog.leichunfeng.com/images/justadd3.png" alt="justadd3" /></p>

<p>那么，我们如何将一个在上下文中的函数应用到一个在上下文中的值呢？</p>

<p><img src="http://blog.leichunfeng.com/images/apply_justadd3_just2.png" alt="apply_justadd3_just2" /></p>

<p>这就是 <code>Applicative</code> 要干的事，详情请看下节内容。</p>

<h3>Applicative typeclass</h3>

<p>同样的，我们先来看一下 <code>Applicative typeclass</code> 的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">Applicative</span> <span class="n">f</span> <span class="n">where</span>
</span><span class='line'>    <span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
</span><span class='line'>    <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们注意到，与 <code>Functor typeclass</code> 的定义不同的是，在 <code>Applicative typeclass</code> 的定义中多了一个类约束 <code>Functor f</code> ，表示的意思是数据类型 <code>f</code> 要实现 <code>Applicative typeclass</code> 的前提条件是它必须要实现 <code>Functor typeclass</code> ，也就是说它必须是一个 <code>Functor</code> 。</p>

<p>在 <code>Applicative typeclass</code> 中定义了两个函数：</p>

<ul>
<li><code>pure</code> ：将一个值 <code>a</code> 放入上下文中；</li>
<li><code>(&lt;*&gt;)</code> ：将一个在上下文中的函数 <code>f (a -&gt; b)</code> 应用到一个在上下文中的值 <code>f a</code> ，并返回另一个在上下文中的值 <code>f b</code> 。</li>
</ul>


<p><strong>注</strong>：<code>&lt;*&gt;</code> 函数的发音我也不知道，如果有同学知道的话还请告之，谢谢。</p>

<h3>Maybe Applicative</h3>

<p>同样的，我们将类型占位符 <code>f</code> 用具体类型 <code>Maybe</code> 代入，可得：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Functor</span> <span class="n">Maybe</span> <span class="o">=&gt;</span> <span class="n">Applicative</span> <span class="n">Maybe</span> <span class="n">where</span>
</span><span class='line'>    <span class="n">pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">a</span>
</span><span class='line'>    <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">Maybe</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，对于 <code>Maybe</code> 类型来说，它要实现的 <code>pure</code> 函数的功能就是将一个值 <code>a</code> 放入 <code>Maybe</code> 上下文中。而 <code>(&lt;*&gt;)</code> 函数的功能则是将一个在 <code>Maybe</code> 上下文中的函数 <code>Maybe (a -&gt; b)</code> 应用到一个在 <code>Maybe</code> 上下文中的值 <code>Maybe a</code> ，并返回另一个在 <code>Maybe</code> 上下文中的值 <code>Maybe b</code> 。接下来，我们一起来看一下 <code>Maybe</code> 类型实现 <code>Applicative typeclass</code> 的具体细节：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">instance</span> <span class="n">Applicative</span> <span class="n">Maybe</span> <span class="n">where</span>
</span><span class='line'>    <span class="n">pure</span> <span class="o">=</span> <span class="n">Just</span>
</span><span class='line'>    <span class="n">Nothing</span> <span class="o">&lt;*&gt;</span> <span class="n">_</span> <span class="o">=</span> <span class="n">Nothing</span>
</span><span class='line'>    <span class="p">(</span><span class="n">Just</span> <span class="n">func</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">something</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">func</span> <span class="n">something</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>pure</code> 函数的实现非常简单，直接等于 <code>Just</code> 即可。而对于 <code>(&lt;*&gt;)</code> 函数的实现，我们同样需要针对 <code>Maybe</code> 上下文的两种情况分别进行处理：当装函数的盒子为空时，直接返回一个新的空盒子；当装函数的盒子不为空时，即 <code>Just func</code> ，则取出 <code>func</code> ，使用 <code>fmap</code> 函数直接将 <code>func</code> 应用到那个在上下文中的值，这个正是我们前面说的 <code>Functor</code> 的功能。</p>

<p>好了，我们接下来看一下将 <code>Just (+3)</code> 应用到 <code>Just 2</code> 的具体过程：</p>

<p><img src="http://blog.leichunfeng.com/images/applicative_just.png" alt="applicative_just" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">Just</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">Just</span> <span class="mi">2</span>
</span><span class='line'><span class="n">Just</span> <span class="mi">5</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样的，当我们将一个空盒子，即 <code>Nothing</code> 应用到 <code>Just 2</code> 的时候，我们将得到一个新的空盒子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">Nothing</span> <span class="o">&lt;*&gt;</span> <span class="n">Just</span> <span class="mi">2</span>
</span><span class='line'><span class="n">Nothing</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Monad</h2>

<p>截至目前，我们已经知道了 <code>Functor</code> 的作用就是应用一个函数到一个上下文中的值：</p>

<p><img src="http://blog.leichunfeng.com/images/fmap.png" alt="fmap" /></p>

<p>而 <code>Applicative</code> 的作用则是应用一个上下文中的函数到一个上下文中的值：</p>

<p><img src="http://blog.leichunfeng.com/images/apply_justadd3_just2.png" alt="apply_justadd3_just2" /></p>

<p>那么 <code>Monad</code> 又会是什么呢？其实，<code>Monad</code> 的作用跟 <code>Functor</code> 类似，也是应用一个函数到一个上下文中的值。不同之处在于，<code>Functor</code> 应用的是一个接收一个普通值并且返回一个普通值的函数，而 <code>Monad</code> 应用的是一个接收一个普通值但是返回一个在上下文中的值的函数：</p>

<p><img src="http://blog.leichunfeng.com/images/bind.png" alt="bind" /></p>

<h3>Monad typeclass</h3>

<p>同样的，我们先来看一下 <code>Monad typeclass</code> 的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Applicative</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">Monad</span> <span class="n">m</span> <span class="n">where</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</span><span class='line'>    <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="err">\</span><span class="n">_</span> <span class="o">-&gt;</span> <span class="n">y</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">fail</span> <span class="o">::</span> <span class="n">String</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</span><span class='line'>    <span class="n">fail</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">error</span> <span class="n">msg</span>
</span></code></pre></td></tr></table></div></figure>


<p>哇，这什么鬼，完全看不懂啊，太复杂了。兄台莫急，且听我细说。在 <code>Monad typeclass</code> 中定义了四个函数，分别是 <code>return</code>、<code>(&gt;&gt;=)</code>、<code>(&gt;&gt;)</code> 和 <code>fail</code> ，且后两个函数 <code>(&gt;&gt;)</code> 和 <code>fail</code> 给出了默认实现，而在绝大多数情况下，我们都不需要去重写它们。因此，去掉这两个函数后，<code>Monad typeclass</code> 的定义可简化为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Applicative</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">Monad</span> <span class="n">m</span> <span class="n">where</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</span><span class='line'>    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>怎么样？现在看上去就好多了吧。跟 <code>Applicative typeclass</code> 的定义一样，在 <code>Monad typeclass</code> 的定义中也有一个类约束 <code>Applicative m</code> ，表示的意思是一种数据类型 <code>m</code> 要成为 <code>Monad</code> 的前提条件是它必须是 <code>Applicative</code> 。另外，其实 <code>return</code> 函数的功能与 <code>Applicative</code> 中的 <code>pure</code> 函数的功能是一样的，只不过换了一个名字而已，它们的作用都是将一个值 <code>a</code> 放入上下文中。而 <code>(&gt;&gt;=)</code> 函数的功能则是应用一个（接收一个普通值 <code>a</code> 但是返回一个在上下文中的值 <code>m b</code> 的）函数 <code>(a -&gt; m b)</code> 到一个上下文中的值 <code>m a</code> ，并返回另一个在相同上下文中的值 <code>m b</code> 。</p>

<p><strong>注</strong>：<code>&gt;&gt;=</code> 函数的发音为 <code>bind</code> ，学习 <code>ReactiveCocoa</code> 的同学要注意啦。另外，<code>&gt;&gt;=</code> 函数可类比 <code>Swift</code> 中的 <code>flatMap</code> 方法。</p>

<h3>Maybe Monad</h3>

<p>同样的，我们将类型占位符 <code>m</code> 用具体类型 <code>Maybe</code> 代入，可得：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Applicative</span> <span class="n">Maybe</span> <span class="o">=&gt;</span> <span class="n">Monad</span> <span class="n">Maybe</span> <span class="n">where</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">a</span>
</span><span class='line'>    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="n">Maybe</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Maybe</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>相信你用盒子模型已经能够轻松地理解上面两个函数了，因此不再赘述。接下来，我们一起来看一下 <code>Maybe</code> 类型实现 <code>Monad typeclass</code> 的具体细节：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">instance</span> <span class="n">Monad</span> <span class="n">Maybe</span> <span class="n">where</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Just</span> <span class="n">x</span>
</span><span class='line'>    <span class="n">Nothing</span> <span class="o">&gt;&gt;=</span> <span class="n">func</span> <span class="o">=</span> <span class="n">Nothing</span>
</span><span class='line'>    <span class="n">Just</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">func</span>  <span class="o">=</span> <span class="n">func</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>正如前面所说，<code>return</code> 函数的实现跟 <code>pure</code> 函数一样，直接等于 <code>Just</code> 函数即可，功能就是将一个值 <code>x</code> 放入 <code>Maybe</code> 盒子中，变成 <code>Just x</code> 。同样的，对于 <code>(&gt;&gt;=)</code> 函数的实现，我们需要针对 <code>Maybe</code> 上下文的两种情况分别进行处理，当盒子为空时，直接返回一个新的空盒子；当盒子不为空时，即 <code>Just x</code> ，则取出 <code>x</code> ，直接将 <code>func</code> 函数应用到 <code>x</code> ，而我们知道 <code>func x</code> 的结果就是一个在上下文中的值。</p>

<p>下面，我们一起来看一个具体的例子。我们先定义一个 <code>half</code> 函数，这个函数接收一个数字 <code>x</code> 作为参数，如果 <code>x</code> 是偶数，则将 <code>x</code> 除以 <code>2</code> ，并将结果放入 <code>Maybe</code> 盒子中；如果 <code>x</code> 不是偶数，则返回一个空盒子：</p>

<p><img src="http://blog.leichunfeng.com/images/half.png" alt="half" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">half</span> <span class="n">x</span> <span class="o">=</span> <span class="k">if</span> <span class="n">even</span> <span class="n">x</span>
</span><span class='line'>    <span class="n">then</span> <span class="n">Just</span> <span class="p">(</span><span class="n">x</span> <span class="err">`</span><span class="n">div</span><span class="err">`</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span> <span class="n">Nothing</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来，我们使用 <code>(&gt;&gt;=)</code> 函数将 <code>half</code> 函数应用到 <code>Just 20</code> ，假设得到结果 <code>y</code> ；然后继续使用 <code>(&gt;&gt;=)</code> 函数将 <code>half</code> 函数应用到上一步的结果 <code>y</code> ，以此类推，看看会得到什么样的结果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">Just</span> <span class="mi">20</span> <span class="o">&gt;&gt;=</span> <span class="n">half</span>
</span><span class='line'><span class="n">Just</span> <span class="mi">10</span>
</span><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">Just</span> <span class="mi">10</span> <span class="o">&gt;&gt;=</span> <span class="n">half</span>
</span><span class='line'><span class="n">Just</span> <span class="mi">5</span>
</span><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">Just</span> <span class="mi">5</span> <span class="o">&gt;&gt;=</span> <span class="n">half</span>
</span><span class='line'><span class="n">Nothing</span>
</span></code></pre></td></tr></table></div></figure>


<p>看到上面的运算过程，不知道你有没有看出点什么端倪呢？上一步的输出作为下一步的输入，并且只要你愿意的话，这个过程可以无限地进行下去。我想你可能已经想到了，是的，就是链式操作。所有的操作链接起来就像是一条生产线，每一步的操作都是对输入进行加工，然后产生输出，整个操作过程可以看作是对最初的原材料 <code>Just 20</code> 进行加工并最终生产出成品 <code>Nothing</code> 的过程：</p>

<p><img src="http://blog.leichunfeng.com/images/monad_chain.png" alt="monad_chain" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">Just</span> <span class="mi">20</span> <span class="o">&gt;&gt;=</span> <span class="n">half</span> <span class="o">&gt;&gt;=</span> <span class="n">half</span> <span class="o">&gt;&gt;=</span> <span class="n">half</span>
</span><span class='line'><span class="n">Nothing</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注</strong>：链式操作只是 <code>Monad</code> 为我们带来的主要好处之一；另一个本文并未涉及到的主要好处是，<code>Monad</code> 可以为我们自动处理上下文，而我们只需要关心真正的值就可以了。</p>

<h3>ReactiveCocoa</h3>

<p>现在，我们已经知道 <code>Monad</code> 是什么了，它就是一种实现了 <code>Monad typeclass</code> 的数据类型。那么它有什么具体的应用呢？你总不能让我们都来做理论研究吧。既然如此，那我们就只好祭出 <code>Objective-C</code> 中的神器，<code>ReactiveCocoa</code> ，它就是根据 <code>Monad</code> 的概念搭建起来的。下面是 <code>RACStream</code> 的继承结构图：</p>

<p><img src="http://blog.leichunfeng.com/images/RACStream.png" alt="RACStream" /></p>

<p><code>RACStream</code> 是 <code>ReactiveCocoa</code> 中最核心的类，它就是一个 <code>Monad</code> ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">/// An abstract class representing any stream of values.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// This class represents a monad, upon which many stream-based operations can</span>
</span><span class='line'><span class="c1">/// be built.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// When subclassing RACStream, only the methods in the main @interface body need</span>
</span><span class='line'><span class="c1">/// to be overridden.</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">RACStream</span> : <span class="bp">NSObject</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// Lifts `value` into the stream monad.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// Returns a stream containing only the given value.</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">return:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">value</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// Lazily binds a block to the values in the receiver.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// This should only be used if you need to terminate the bind early, or close</span>
</span><span class='line'><span class="c1">/// over some state. -flattenMap: is more appropriate for all other cases.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// block - A block returning a RACStreamBindBlock. This block will be invoked</span>
</span><span class='line'><span class="c1">///         each time the bound stream is re-evaluated. This block must not be</span>
</span><span class='line'><span class="c1">///         nil or return nil.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// Returns a new stream which represents the combined result of all lazy</span>
</span><span class='line'><span class="c1">/// applications of `block`.</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">bind:</span><span class="p">(</span><span class="n">RACStreamBindBlock</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以看到，在 <code>RACStream</code> 中定义了两个看上去非常眼熟的方法：</p>

<ol>
<li><code>+ (instancetype)return:(id)value;</code> ；</li>
<li><code>- (instancetype)bind:(RACStreamBindBlock (^)(void))block;</code> 。</li>
</ol>


<p>其中，<code>return:</code> 方法的功能就是将一个值 <code>value</code> 放入 <code>RACStream</code> 上下文中；而 <code>bind:</code> 方法的功能则是将一个 <code>RACStreamBindBlock</code> 类型的 <code>block</code> 应用到一个在 <code>RACStream</code> 上下文中的值（<code>receiver</code>），并返回另一个在 <code>RACStream</code> 上下文中的值。<strong>注</strong>，<code>RACStreamBindBlock</code> 类型的 <code>block</code> 就是一个接收一个普通值 <code>value</code> 但是返回一个在 <code>RACStream</code> 上下文中的值的“函数”：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">/// A block which accepts a value from a RACStream and returns a new instance</span>
</span><span class='line'><span class="c1">/// of the same stream class.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// Setting `stop` to `YES` will cause the bind to terminate after the returned</span>
</span><span class='line'><span class="c1">/// value. Returning `nil` will result in immediate termination.</span>
</span><span class='line'><span class="k">typedef</span> <span class="n">RACStream</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">RACStreamBindBlock</span><span class="p">)(</span><span class="kt">id</span> <span class="n">value</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来，为了加深理解，我们一起来对比一下 <code>Monad typeclass</code> 的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Applicative</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">Monad</span> <span class="n">m</span> <span class="n">where</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</span><span class='line'>    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样的，我们将类型占位符 <code>m</code> 用 <code>RACStream</code> 代入，可得：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">class</span> <span class="n">Applicative</span> <span class="n">RACStream</span> <span class="o">=&gt;</span> <span class="n">Monad</span> <span class="n">RACStream</span> <span class="n">where</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">RACStream</span> <span class="n">a</span>
</span><span class='line'>    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="n">RACStream</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">RACStream</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RACStream</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中，<code>return :: a -&gt; RACStream a</code> 就对应 <code>+ (instancetype)return:(id)value;</code> ，而 <code>(&gt;&gt;=) :: RACStream a -&gt; (a -&gt; RACStream b) -&gt; RACStream b</code> 则对应 <code>- (instancetype)bind:(RACStreamBindBlock (^)(void))block;</code> 。<strong>注</strong>：我们前面已经提到过了，<code>&gt;&gt;=</code> 函数的发音就是 <code>bind</code> 。因此，<code>ReactiveCocoa</code> 便有了下面的玩法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">RACSignal</span> <span class="o">*</span><span class="n">signal2</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">signal1</span>
</span><span class='line'>    <span class="nl">bind</span><span class="p">:</span><span class="n">block1</span><span class="p">]</span>
</span><span class='line'>    <span class="nl">bind</span><span class="p">:</span><span class="n">block2</span><span class="p">]</span>
</span><span class='line'>    <span class="nl">bind</span><span class="p">:</span><span class="n">block3</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Monad</code> 就像是 <code>ReactiveCocoa</code> 中的太极，太极生两仪，两仪生四象，四象生八卦。至此，我们已经知道了 <code>ReactiveCocoa</code> 中最核心的原理，而更多关于 <code>ReactiveCocoa</code> 的内容我们将在后续的源码解析中再进行介绍，敬请期待。</p>

<h2>总结</h2>

<p><code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 是什么：</p>

<ol>
<li>一个 <code>Functor</code> 就是一种实现了 <code>Functor typeclass</code> 的数据类型；</li>
<li>一个 <code>Applicative</code> 就是一种实现了 <code>Applicative typeclass</code> 的数据类型；</li>
<li>一个 <code>Monad</code> 就是一种实现了 <code>Monad typeclass</code> 的数据类型。</li>
</ol>


<p><code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 三者之间的联系：</p>

<ol>
<li><code>Applicative</code> 是增强型的 <code>Functor</code> ，一种数据类型要成为 <code>Applicative</code> 的前提条件是它必须是 <code>Functor</code> ；</li>
<li><code>Monad</code> 是增强型的 <code>Applicative</code> ，一种数据类型要成为 <code>Monad</code> 的前提条件是它必须是 <code>Applicative</code> 。</li>
</ol>


<p><code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 三者之间的区别：</p>

<p><img src="http://blog.leichunfeng.com/images/recap.png" alt="recap" /></p>

<ol>
<li><code>Functor</code> ：使用 <code>fmap</code> 应用一个函数到一个上下文中的值；</li>
<li><code>Applicative</code> ：使用 <code>&lt;*&gt;</code> 应用一个上下文中的函数到一个上下文中的值；</li>
<li><code>Monad</code> ：使用 <code>&gt;&gt;=</code> 应用一个接收一个普通值但是返回一个在上下文中的值的函数到一个上下文中的值。</li>
</ol>


<p>此外，我们还介绍了一种非常有意思的数据类型 <code>Maybe</code> ，它实现了 <code>Functor typeclass</code>、<code>Applicative typeclass</code> 和 <code>Monad typeclass</code> ，所以它同时是 <code>Functor</code>、<code>Applicative</code> 和 <code>Monad</code> 。</p>

<p>以上就是本文的全部内容，希望可以对你有所帮助，Good luck !</p>

<h2>参考链接</h2>

<p><a href="http://learnyouahaskell.com/chapters">http://learnyouahaskell.com/chapters</a>
<br>
<a href="https://downloads.haskell.org/~ghc/latest/docs/html/libraries">https://downloads.haskell.org/~ghc/latest/docs/html/libraries</a>
<br>
<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">http://adit.io/posts/2013-04-17-functors,<em>applicatives,</em>and_monads_in_pictures.html</a></p>

<p><img src="http://blog.leichunfeng.com/images/wechat_pay.jpg" width="260" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 并发编程之 Operation Queues]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/07/29/ios-concurrency-programming-operation-queues/"/>
    <updated>2015-07-29T22:06:33+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/07/29/ios-concurrency-programming-operation-queues</id>
    <content type="html"><![CDATA[<p>现如今移动设备也早已经进入了多核心 <code>CPU</code> 时代，并且随着时间的推移，<code>CPU</code> 的核心数只会增加不会减少。而作为软件开发者，我们需要做的就是尽可能地提高应用的并发性，来充分利用这些多核心 <code>CPU</code> 的性能。在 iOS 开发中，我们主要可以通过 Operation Queues、Dispatch Queues 和 Dispatch Sources 来提高应用的并发性。本文将主要介绍 Operation Queues 的相关知识，另外两个属于 Grand Central Dispatch（以下正文简称 <code>GCD</code> ）的范畴，将会在后续的文章中进行介绍。</p>

<p>由于本文涉及的内容较多，所以建议读者先提前了解一下本文的目录结构，以便对本文有一个宏观的认识：</p>

<ul>
<li>基本概念

<ul>
<li>术语</li>
<li>串行 vs. 并发</li>
<li>同步 vs. 异步</li>
<li>队列 vs. 线程</li>
</ul>
</li>
<li>iOS 的并发编程模型</li>
<li>Operation Queues vs. Grand Central Dispatch (GCD)</li>
<li>关于 Operation 对象

<ul>
<li>并发 vs. 非并发 Operation</li>
<li>创建 NSInvocationOperation 对象</li>
<li>创建 NSBlockOperation 对象</li>
</ul>
</li>
<li>自定义 Operation 对象

<ul>
<li>执行主任务</li>
<li>响应取消事件</li>
<li>配置并发执行的 Operation</li>
<li>维护 KVO 通知</li>
</ul>
</li>
<li>定制 Operation 对象的执行行为

<ul>
<li>配置依赖关系</li>
<li>修改 Operation 在队列中的优先级</li>
<li>修改 Operation 执行任务线程的优先级</li>
<li>设置 Completion Block</li>
</ul>
</li>
<li>执行 Operation 对象

<ul>
<li>添加 Operation 到 Operation Queue 中</li>
<li>手动执行 Operation</li>
<li>取消 Operation</li>
<li>等待 Operation 执行完成</li>
<li>暂停和恢复 Operation Queue</li>
</ul>
</li>
<li>总结</li>
</ul>


<h2>基本概念</h2>

<p>在正式开始介绍 Operation Queues 的相关知识前，我想先介绍几个在 iOS 并发编程中非常容易混淆的基本概念，以帮助读者更好地理解本文。<strong>注</strong>，本文中的 Operation Queues 指的是 NSOperation 和 NSOperationQueue 的统称。</p>

<h3>术语</h3>

<p>首先，我们先来了解一下在 iOS 并发编程中非常重要的三个术语，这是我们理解 iOS 并发编程的基础：</p>

<ul>
<li>进程（process），指的是一个正在运行中的可执行文件。每一个进程都拥有独立的虚拟内存空间和系统资源，包括端口权限等，且至少包含一个主线程和任意数量的辅助线程。另外，当一个进程的主线程退出时，这个进程就结束了；</li>
<li>线程（thread），指的是一个独立的代码执行路径，也就是说线程是代码执行路径的最小分支。在 iOS 中，线程的底层实现是基于 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html">POSIX threads API</a> 的，也就是我们常说的 pthreads ；</li>
<li>任务（task），指的是我们需要执行的工作，是一个抽象的概念，用通俗的话说，就是一段代码。</li>
</ul>


<h3>串行 vs. 并发</h3>

<p>从本质上来说，串行和并发的主要区别在于允许同时执行的任务数量。串行，指的是一次只能执行一个任务，必须等一个任务执行完成后才能执行下一个任务；并发，则指的是允许多个任务同时执行。</p>

<h3>同步 vs. 异步</h3>

<p>同样的，同步和异步操作的主要区别在于是否等待操作执行完成，亦即是否阻塞当前线程。同步操作会等待操作执行完成后再继续执行接下来的代码，而异步操作则恰好相反，它会在调用后立即返回，不会等待操作的执行结果。</p>

<h3>队列 vs. 线程</h3>

<p>有一些对 iOS 并发编程模型不太了解的同学可能会对队列和线程产生混淆，不清楚它们之间的区别与联系，因此，我觉得非常有必要在这里简单地介绍一下。在 iOS 中，有两种不同类型的队列，分别是串行队列和并发队列。正如我们上面所说的，串行队列一次只能执行一个任务，而并发队列则可以允许多个任务同时执行。iOS 系统就是使用这些队列来进行任务调度的，它会根据调度任务的需要和系统当前的负载情况动态地创建和销毁线程，而不需要我们手动地管理。</p>

<h2>iOS 的并发编程模型</h2>

<p>在其他许多语言中，为了提高应用的并发性，我们往往需要自行创建一个或多个额外的线程，并且手动地管理这些线程的生命周期，这本身就已经是一项非常具有挑战性的任务了。此外，对于一个应用来说，最优的线程个数会随着系统当前的负载和低层硬件的情况发生动态变化。因此，一个单独的应用想要实现一套正确的多线程解决方案就变成了一件几乎不可能完成的事情。而更糟糕的是，线程的同步机制大幅度地增加了应用的复杂性，并且还存在着不一定能够提高应用性能的风险。</p>

<p>然而，值得庆幸的是，在 iOS 中，苹果采用了一种比传统的基于线程的系统更加异步的方式来执行并发任务。与直接创建线程的方式不同，我们只需定义好要调度的任务，然后让系统帮我们去执行这些任务就可以了。我们可以完全不需要关心线程的创建与销毁、以及多线程之间的同步等问题，苹果已经在系统层面帮我们处理好了，并且比我们手动地管理这些线程要高效得多。</p>

<p>因此，我们应该要听从苹果的劝告，珍爱生命，远离线程。不过话又说回来，尽管队列是执行并发任务的首先方式，但是毕竟它们也不是什么万能的灵丹妙药。所以，在以下三种场景下，我们还是应该直接使用线程的：</p>

<ul>
<li>用线程以外的其他任何方式都不能实现我们的特定任务；</li>
<li>必须实时执行一个任务。因为虽然队列会尽可能快地执行我们提交的任务，但是并不能保证实时性；</li>
<li>你需要对在后台执行的任务有更多的可预测行为。</li>
</ul>


<h2>Operation Queues vs. Grand Central Dispatch (GCD)</h2>

<p>简单来说，<code>GCD</code> 是苹果基于 <code>C</code> 语言开发的，一个用于多核编程的解决方案，主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。而 Operation Queues 则是一个建立在 <code>GCD</code> 的基础之上的，面向对象的解决方案。它使用起来比 <code>GCD</code> 更加灵活，功能也更加强大。下面简单地介绍了 Operation Queues 和 <code>GCD</code> 各自的使用场景：</p>

<ul>
<li>Operation Queues ：相对 <code>GCD</code> 来说，使用 Operation Queues 会增加一点点额外的开销，但是我们却换来了非常强大的灵活性和功能，我们可以给 operation 之间添加依赖关系、取消一个正在执行的 operation 、暂停和恢复 operation queue 等；</li>
<li><code>GCD</code> ：则是一种更轻量级的，以 <code>FIFO</code> 的顺序执行并发任务的方式，使用 <code>GCD</code> 时我们并不关心任务的调度情况，而让系统帮我们自动处理。但是 <code>GCD</code> 的短板也是非常明显的，比如我们想要给任务之间添加依赖关系、取消或者暂停一个正在执行的任务时就会变得非常棘手。</li>
</ul>


<h2>关于 Operation 对象</h2>

<p>在 iOS 开发中，我们可以使用 NSOperation 类来封装需要执行的任务，而一个 operation 对象（以下正文简称 operation ）指的就是 NSOperation 类的一个具体实例。NSOperation 本身是一个抽象类，不能直接实例化，因此，如果我们想要使用它来执行具体任务的话，就必须创建自己的子类或者使用系统预定义的两个子类，NSInvocationOperation 和 NSBlockOperation 。</p>

<p><strong>NSInvocationOperation</strong> ：我们可以通过一个 <code>object</code> 和 <code>selector</code> 非常方便地创建一个 NSInvocationOperation ，这是一种非常动态和灵活的方式。假设我们已经有了一个现成的方法，这个方法中的代码正好就是我们需要执行的任务，那么我们就可以在不修改任何现有代码的情况下，通过方法所在的对象和这个现有方法直接创建一个 NSInvocationOperation 。</p>

<p><strong>NSBlockOperation</strong> ：我们可以使用 NSBlockOperation 来并发执行一个或多个 block ，只有当一个 NSBlockOperation 所关联的所有 block 都执行完毕时，这个 NSBlockOperation 才算执行完成，有点类似于 <code>dispatch_group</code> 的概念。</p>

<p>另外，所有的 operation 都支持以下特性：</p>

<ul>
<li>支持在 operation 之间建立依赖关系，只有当一个 operation 所依赖的所有 operation 都执行完成时，这个 operation 才能开始执行；</li>
<li>支持一个可选的 completion block ，这个 block 将会在 operation 的主任务执行完成时被调用；</li>
<li>支持通过 <code>KVO</code> 来观察 operation 执行状态的变化；</li>
<li>支持设置执行的优先级，从而影响 operation 之间的相对执行顺序；</li>
<li>支持取消操作，可以允许我们停止正在执行的 operation 。</li>
</ul>


<h3>并发 vs. 非并发 Operation</h3>

<p>通常来说，我们都是通过将 operation 添加到一个 operation queue 的方式来执行 operation 的，然而这并不是必须的。我们也可以直接通过调用 <code>start</code> 方法来执行一个 operation ，但是这种方式并不能保证 operation 是异步执行的。NSOperation 类的 <code>isConcurrent</code> 方法的返回值标识了一个 operation 相对于调用它的 <code>start</code> 方法的线程来说是否是异步执行的。在默认情况下，isConcurrent 方法的返回值是 <code>NO</code> ，也就是说会阻塞调用它的 <code>start</code> 方法的线程。</p>

<p>如果我们想要自定义一个并发执行的 operation ，那么我们就必须要编写一些额外的代码来让这个 operation 异步执行。比如，为这个 operation 创建新的线程、调用系统的异步方法或者其他任何方式来确保 <code>start</code> 方法在开始执行任务后立即返回。</p>

<p>在绝大多数情况下，我们都不需要去实现一个并发的 operation 。如果我们一直是通过将 operation 添加到 operation queue 的方式来执行 operation 的话，我们就完全没有必要去实现一个并发的 operation 。因为，当我们将一个非并发的 operation 添加到 operation queue 后，operation queue 会自动为这个 operation 创建一个线程。因此，只有当我们需要手动地执行一个 operation ，又想让它异步执行时，我们才有必要去实现一个并发的 operation 。</p>

<h3>创建 NSInvocationOperation 对象</h3>

<p>正如上面提到的，NSInvocationOperation 是 NSOperation 类的一个子类，当一个 NSInvocationOperation 开始执行时，它会调用我们指定的 <code>object</code> 的 <code>selector</code> 方法。通过使用 NSInvocationOperation 类，我们可以避免为每一个任务都创建一个自定义的子类，特别是当我们在修改一个已经存在的应用，并且这个应用中已经有了我们需要执行的任务所对应的 <code>object</code> 和 <code>selector</code> 时非常有用。</p>

<p>下面的示例代码展示了如何通过 <code>object</code> 和 <code>selector</code> 创建一个 NSInvocationOperation 对象。<strong>说明</strong>，本文中的所有示例代码都可以在这里 <a href="https://github.com/leichunfeng/OperationQueues">OperationQueues</a> 找到，每一个类都有与之对应的测试类，充当 <code>client</code> 的角色，建议你在看完一个小节的代码时，运行一下相应的测试用例，观察打印的结果，以加深理解。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">OQCreateInvocationOperation</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSInvocationOperation</span> <span class="o">*</span><span class="p">)</span><span class="nf">invocationOperationWithData:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">data</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[[</span><span class="bp">NSInvocationOperation</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">myTaskMethod1</span><span class="p">:)</span> <span class="nl">object</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">myTaskMethod1:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">data</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing %@ with data: %@, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">),</span> <span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外，我们在前面也提到了，NSInvocationOperation 类的使用可以非常的动态和灵活，其中比较显著的一点就是我们可以根据上下文动态地调用 <code>object</code> 的不同 <code>selector</code> 。比如说，我们可以根据用户的输入动态地执行不同的 <code>selector</code> ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSInvocationOperation</span> <span class="o">*</span><span class="p">)</span><span class="nf">invocationOperationWithData:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">data</span> <span class="nf">userInput:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">userInput</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">NSInvocationOperation</span> <span class="o">*</span><span class="n">invocationOperation</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">invocationOperationWithData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">userInput</span><span class="p">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">invocationOperation</span><span class="p">.</span><span class="n">invocation</span><span class="p">.</span><span class="n">selector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">myTaskMethod2</span><span class="p">:);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">invocationOperation</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">myTaskMethod2:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">data</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing %@ with data: %@, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">),</span> <span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>创建 NSBlockOperation 对象</h3>

<p>NSBlockOperation 是 NSOperation 类的另外一个系统预定义的子类，我们可以用它来封装一个或多个 <code>block</code> 。我们知道 <code>GCD</code> 主要就是用来进行 <code>block</code> 调度的，那为什么我们还需要 NSBlockOperation 类呢？一般来说，有以下两个场景我们会优先使用 NSBlockOperation 类：</p>

<ul>
<li>当我们在应用中已经使用了 Operation Queues 且不想创建 Dispatch Queues 时，NSBlockOperation 类可以为我们的应用提供一个面向对象的封装；</li>
<li>我们需要用到 Dispatch Queues 不具备的功能时，比如需要设置 operation 之间的依赖关系、使用 <code>KVO</code> 观察 operation 的状态变化等。</li>
</ul>


<p>下面的示例代码展示了创建一个 NSBlockOperation 对象的基本方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">OQCreateBlockOperation</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="p">)</span><span class="nf">blockOperation</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">blockOperation</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing block1, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing block1&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">blockOperation</span> <span class="nl">addExecutionBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing block2, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing block2&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">blockOperation</span> <span class="nl">addExecutionBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing block3, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing block3&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">blockOperation</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h2>自定义 Operation 对象</h2>

<p>当系统预定义的两个子类 NSInvocationOperation 和 NSBlockOperation 不能很好的满足我们的需求时，我们可以自定义自己的 NSOperation 子类，添加我们想要的功能。目前，我们可以自定义非并发和并发两种不同类型的 NSOperation 子类，而自定义一个前者要比后者简单得多。</p>

<p>对于一个非并发的 operation ，我们需要做的就只是执行 <code>main</code> 方法中的任务以及能够正常响应取消事件就可以了，其它的复杂工作比如依赖配置、KVO 通知等 NSOperation 类都已经帮我们处理好了。而对于一个并发的 operation ，我们还需要重写 NSOperation 类中的一些现有方法。接下来，我们将会介绍如何自定义这两种不同类型的 NSOperation 子类。</p>

<h3>执行主任务</h3>

<p>从最低限度上来说，每一个 operation 都应该至少实现以下两个方法：</p>

<ul>
<li>一个自定义的初始化方法；</li>
<li><code>main</code> 方法。</li>
</ul>


<p>我们需要用一个自定义的初始化方法来将创建的 operation 置于一个已知的状态，并且重写 <code>main</code> 方法来执行我们的任务。当然，我们也可以实现一些其他的额外方法，比如实现 <code>NSCoding</code> 协议来允许我们归档和解档 operation 等。下面的示例代码展示了如何自定义一个简单的 operation ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">OQNonConcurrentOperation</span> <span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="kt">id</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">OQNonConcurrentOperation</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithData:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">data</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">///  不支持取消操作</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">main</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@try</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing %@ with data: %@, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">),</span> <span class="nb">self</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">@catch</span><span class="p">(</span><span class="bp">NSException</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Exception: %@&quot;</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>响应取消事件</h3>

<p>当一个 operation 开始执行后，它会一直执行它的任务直到完成或被取消为止。我们可以在任意时间点取消一个 operation ，甚至是在它还未开始执行之前。为了让我们自定义的 operation 能够支持取消事件，我们需要在代码中定期地检查 <code>isCancelled</code> 方法的返回值，一旦检查到这个方法返回 <code>YES</code> ，我们就需要立即停止执行接下来的任务。根据苹果官方的说法，<code>isCancelled</code> 方法本身是足够轻量的，所以就算是频繁地调用它也不会给系统带来太大的负担。</p>

<blockquote><p>The isCancelled method itself is very lightweight and can be called frequently without any significant performance penalty.</p></blockquote>

<p>通常来说，当我们自定义一个 operation 类时，我们需要考虑在以下几个关键点检查 <code>isCancelled</code> 方法的返回值：</p>

<ul>
<li>在真正开始执行任务之前；</li>
<li>至少在每次循环中检查一次，而如果一次循环的时间本身就比较长的话，则需要检查得更加频繁；</li>
<li>在任何相对来说比较容易中止 operation 的地方。</li>
</ul>


<p>看到这里，我想你应该可以意识到一点，那就是尽管 operation 是支持取消操作的，但却并不是立即取消的，而是在你调用了 operation 的 <code>cancel</code> 方法之后的下一个 <code>isCancelled</code> 的检查点取消的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">///  支持取消操作</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">main</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@try</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">isCancelled</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing %@ with data: %@, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">),</span> <span class="nb">self</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="bp">NSUInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">isCancelled</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Loop %@&quot;</span><span class="p">,</span> <span class="l">@(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="l">)</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">@catch</span><span class="p">(</span><span class="bp">NSException</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Exception: %@&quot;</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>配置并发执行的 Operation</h3>

<p>在默认情况下，operation 是同步执行的，也就是说在调用它的 <code>start</code> 方法的线程中执行它们的任务。而在 operation 和 operation queue 结合使用时，operation queue 可以为非并发的 operation 提供线程，因此，大部分的 operation 仍然可以异步执行。但是，如果你想要手动地执行一个 operation ，又想这个 operation 能够异步执行的话，你需要做一些额外的配置来让你的 operation 支持并发执行。下面列举了一些你可能需要重写的方法：</p>

<ul>
<li><code>start</code> ：必须的，所有并发执行的 operation 都必须要重写这个方法，替换掉 NSOperation 类中的默认实现。<code>start</code> 方法是一个 operation 的起点，我们可以在这里配置任务执行的线程或者一些其它的执行环境。另外，需要特别注意的是，在我们重写的 <code>start</code> 方法中一定不要调用父类的实现；</li>
<li><code>main</code> ：可选的，通常这个方法就是专门用来实现与该 operation 相关联的任务的。尽管我们可以直接在 <code>start</code> 方法中执行我们的任务，但是用 <code>main</code> 方法来实现我们的任务可以使设置代码和任务代码得到分离，从而使 operation 的结构更清晰；</li>
<li><code>isExecuting</code> 和 <code>isFinished</code> ：必须的，并发执行的 operation 需要负责配置它们的执行环境，并且向外界客户报告执行环境的状态。因此，一个并发执行的 operation 必须要维护一些状态信息，用来记录它的任务是否正在执行，是否已经完成执行等。此外，当这两个方法所代表的值发生变化时，我们需要生成相应的 <code>KVO</code> 通知，以便外界能够观察到这些状态的变化；</li>
<li><code>isConcurrent</code> ：必须的，这个方法的返回值用来标识一个 operation 是否是并发的 operation ，我们需要重写这个方法并返回 <code>YES</code> 。</li>
</ul>


<p>下面我们将分三部分内容来介绍一下定义一个并发执行的 operation 所需的基本代码，主体部分的代码如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">OQConcurrentOperation</span>
</span><span class='line'>
</span><span class='line'><span class="k">@synthesize</span> <span class="n">executing</span> <span class="o">=</span> <span class="n">_executing</span><span class="p">;</span>
</span><span class='line'><span class="k">@synthesize</span> <span class="n">finished</span>  <span class="o">=</span> <span class="n">_finished</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">_executing</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>        <span class="n">_finished</span>  <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isConcurrent</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isExecuting</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_executing</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isFinished</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_finished</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这一部分的代码看上去比较简单，但是却需要我们用心地去理解它。首先，我们用 <code>@synthesize</code> 关键字手动合成了两个实例变量 <code>_executing</code> 和 <code>_finished</code> ，然后分别在重写的 <code>isExecuting</code> 和 <code>isFinished</code> 方法中返回了这两个实例变量。另外，我们通过查看 NSOperation 类的头文件可以发现，<code>executing</code> 和 <code>finished</code> 属性都被声明成了只读的 <code>readonly</code> 。所以我们在 NSOperation 子类中就没有办法直接通过 <code>setter</code> 方法来自动触发 <code>KVO</code> 通知，这也是为什么我们需要在接下来的代码中手动触发 <code>KVO</code> 通知的原因。</p>

<p>接下来是 <code>start</code> 方法的代码，在这个方法中，我们最需要关注的部分就是为 <code>main</code> 方法分离了一个新的线程，这是 operation 能够并发执行的关键所在。此外，在真正开始执行任务前，我们通过检查 <code>isCancelled</code> 方法的返回值来判断 operation 是否已经被 <code>cancel</code> ，如果是就直接返回了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">start</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">isCancelled</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">willChangeValueForKey</span><span class="p">:</span><span class="s">@&quot;isFinished&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="n">_finished</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">didChangeValueForKey</span><span class="p">:</span><span class="s">@&quot;isFinished&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">willChangeValueForKey</span><span class="p">:</span><span class="s">@&quot;isExecuting&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">detachNewThreadSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">main</span><span class="p">)</span> <span class="nl">toTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">withObject</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>    <span class="n">_executing</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">didChangeValueForKey</span><span class="p">:</span><span class="s">@&quot;isExecuting&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，是真正执行任务的 <code>main</code> 方法，值得注意的是在任务执行完毕后，我们需要手动触动 <code>isExecuting</code> 和 <code>isFinished</code> 的 <code>KVO</code> 通知。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">main</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@try</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing %@, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">),</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">willChangeValueForKey</span><span class="p">:</span><span class="s">@&quot;isExecuting&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="n">_executing</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">didChangeValueForKey</span><span class="p">:</span><span class="s">@&quot;isExecuting&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">willChangeValueForKey</span><span class="p">:</span><span class="s">@&quot;isFinished&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="n">_finished</span>  <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">didChangeValueForKey</span><span class="p">:</span><span class="s">@&quot;isFinished&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">@catch</span> <span class="p">(</span><span class="bp">NSException</span> <span class="o">*</span><span class="n">exception</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Exception: %@&quot;</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意</strong>，有一个非常重要的点需要引起我们的注意，那就是即使一个 operation 是被 <code>cancel</code> 掉了，我们仍然需要手动触发 <code>isFinished</code> 的 <code>KVO</code> 通知。因为当一个 operation 依赖其他 operation 时，它会观察所有其他 operation 的 <code>isFinished</code> 的值的变化，只有当它依赖的所有 operation 的 <code>isFinished</code> 的值为 <code>YES</code> 时，这个 operation 才能够开始执行。因此，如果一个我们自定义的 operation 被取消了但却没有手动触发 <code>isFinished</code> 的 <code>KVO</code> 通知的话，那么所有依赖它的 operation 都不会执行。</p>

<h3>维护 KVO 通知</h3>

<p>NSOperation 类的以下 <code>key paths</code> 支持 <code>KVO</code> 通知，我们可以通过观察这些 <code>key paths</code> 非常方便地监听到一个 operation 内部状态的变化：</p>

<ul>
<li>isCancelled</li>
<li>isConcurrent</li>
<li>isExecuting</li>
<li>isFinished</li>
<li>isReady</li>
<li>dependencies</li>
<li>queuePriority</li>
<li>completionBlock</li>
</ul>


<p>与重写 <code>main</code> 方法不同的是，如果我们重写了 <code>start</code> 方法或者对 NSOperation 类做了大量定制的话，我们需要保证自定义的 operation 在这些 <code>key paths</code> 上仍然支持 <code>KVO</code> 通知。比如，当我们重写了 <code>start</code> 方法时，我们需要特别关注的是 <code>isExecuting</code> 和 <code>isFinished</code> 这两个 <code>key paths</code> ，因为这两个 <code>key paths</code> 最可能受重写 <code>start</code> 方法的影响。</p>

<h2>定制 Operation 对象的执行行为</h2>

<p>我们可以在创建一个 operation 后，添加到 operation queue 前，对 operation 的一些执行行为进行定制。下面介绍的所有定制均适用于所有的 operation ，与是否是自定义的 NSOperation 子类或系统预定义的 NSOperation 子类无关。</p>

<h3>配置依赖关系</h3>

<p>通过配置依赖关系，我们可以让不同的 operation 串行执行，正如我们前面提到的，一个 operation 只有在它依赖的所有 operation 都执行完成后才能开始执行。配置 operation 的依赖关系主要涉及到 NSOperation 类中的以下两个方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addDependency:</span><span class="p">(</span><span class="bp">NSOperation</span> <span class="o">*</span><span class="p">)</span><span class="nv">op</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeDependency:</span><span class="p">(</span><span class="bp">NSOperation</span> <span class="o">*</span><span class="p">)</span><span class="nv">op</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>顾名思义，第一个方法用于添加依赖，第二个方法则用于移除依赖。需要特别注意的是，用 <code>addDependency:</code> 方法添加的依赖关系是单向的，比如 <code>[A addDependency:B];</code> ，表示 A 依赖 B，B 并不依赖 A 。</p>

<p>另外，这里的依赖关系并不局限于相同 operation queue 中的 operation 之间。其实，从上面两个配置依赖关系的方法是存在于 NSOperation 类中的，我们也可以看出来，operation 的依赖关系是它自己管理的，与它被添加到哪个 operation queue 无关。因此，我们完全可以给一些 operation 配置好依赖关系，然后将它们添加到不同的 operation queue 中。但是，有一点是需要我们特别注意的，就是不要在 operation 之间添加循环依赖，因为这样会导致这些 operation 都不会被执行。</p>

<p><strong>注意</strong>，我们应该在手动执行一个 operation 或将它添加到 operation queue 前配置好依赖关系，因为在之后添加的依赖关系可能会失效。</p>

<h3>修改 Operation 在队列中的优先级</h3>

<p>对于被添加到 operation queue 中的 operation 来说，决定它们执行顺序的第一要素是它们的 <code>isReady</code> 状态，其次是它们在队列中的优先级。operation 的 <code>isReady</code> 状态取决于它的依赖关系，而在队列中的优先级则是 operation 本身的属性。默认情况下，所有新创建的 operation 的队列优先级都是 <code>normal</code> 的，但是我们可以根据需要通过 <code>setQueuePriority:</code> 方法来提高或降低 operation 的队列优先级。</p>

<p>需要注意的是，队列优先级只应用于相同 operation queue 中的 operation 之间，不同 operation queue 中的 operation 不受此影响。另外，我们也需要清楚 operation 的队列优先级和依赖关系之间的区别。operation 的队列优先级只决定当前所有 <code>isReady</code> 状态为 <code>YES</code> 的 operation 的执行顺序。比如，在一个 operation queue 中，有一个高优先级和一个低优先级的 operation ，并且它们的 <code>isReady</code> 状态都为 <code>YES</code> ，那么高优先级的 operation 将会优先执行。而如果这个高优先级的 operation 的 <code>isReady</code> 状态为 <code>NO</code> ，而低优先级的 operation 的 <code>isReady</code> 状态为 <code>YES</code> 的话，那么这个低优先级的 operation 反而会优先执行。</p>

<h3>修改 Operation 执行任务线程的优先级</h3>

<p>从 iOS 4.0 开始，我们可以修改 operation 的执行任务线程的优先级。虽然 iOS 系统中的线程策略是由 <code>kernel</code> 内核管理的，但是一般来说，高优先级的线程相对于低优先级的线程来说能够得到更多的运行机会。我们可以给 operation 的线程优先级指定一个从 <code>0.0</code> 到 <code>1.0</code> 的浮点数值，<code>0.0</code> 表示最低的优先级，<code>1.0</code> 表示最高的优先级，默认值为 <code>0.5</code> 。</p>

<p><strong>注意</strong>，我们只能够在执行一个 operation 或将其添加到 operation queue 前，通过 operation 的 <code>setThreadPriority:</code> 方法来修改它的线程优先级。当 operation 开始执行时，NSOperation 类中默认的 <code>start</code> 方法会使用我们指定的值来修改当前线程的优先级。另外，我们指定的这个线程优先级只会影响 <code>main</code> 方法执行时所在线程的优先级。所有其它的代码，包括 operation 的 completion block 所在的线程会一直以默认的线程优先级执行。因此，当我们自定义一个并发的 operation 类时，我们也需要在 <code>start</code> 方法中根据指定的值自行修改线程的优先级。</p>

<h3>设置 Completion Block</h3>

<p>从 iOS 4.0 开始，一个 operation 可以在它的主任务执行完成时回调一个 completion block 。我们可以用 completion block 来执行一些主任务之外的工作，比如，我们可以用它来通知一些客户 operation 已经执行完毕，而并发的 operation 也可以用这个 block 来生成最终的 <code>KVO</code> 通知。如果需要设置一个 operation 的 completion block ，直接调用 NSOperation 类的 <code>setCompletionBlock:</code> 方法即可。</p>

<p><strong>注意</strong>，当一个 operation 被取消时，它的 completion block 仍然会执行，所以我们需要在真正执行代码前检查一下 <code>isCancelled</code> 方法的返回值。另外，我们也没有办法保证 completion block 被回调时一定是在主线程，理论上它应该是与触发 <code>isFinished</code> 的 <code>KVO</code> 通知所在的线程一致的，所以如果有必要的话我们可以在 completion block 中使用 <code>GCD</code> 来保证从主线程更新 <code>UI</code> 。</p>

<h2>执行 Operation 对象</h2>

<p>最终，我们需要执行 operation 来调度与其关联的任务。目前，主要有两种方式来执行一个 operation ：</p>

<ul>
<li>将 operation 添加到一个 operation queue 中，让 operation queue 来帮我们自动执行；</li>
<li>直接调用 <code>start</code> 方法手动执行 operation 。</li>
</ul>


<h3>添加 Operation 到 Operation Queue 中</h3>

<p>就目前来说，将 operation 添加到 operation queue 中是最简单的执行 operation 的方式。另外，这里的 operation queue 指的就是 NSOperationQueue 类的一个具体实例。就技术上而言，我们可以在应用中创建任意数量的 operation queue ，但是 operation queue 的数量越多并不意味着我们就能同时执行越多的 operation 。因为同时并发的 operation 数量是由系统决定的，系统会根据当前可用的核心数以及负载情况动态地调整最大的并发 operation 数量。创建一个 operation queue 非常简单，跟创建其他普通对象没有任何区别：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">operationQueue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>创建好 operation queue 后，我们可以使用下面三个方法添加 operation 到 operation queue 中：</p>

<ul>
<li><code>addOperation:</code> ，添加一个 operation 到 operation queue 中；</li>
<li><code>addOperations:waitUntilFinished:</code> ，添加一组 operation 到 operation queue 中；</li>
<li><code>addOperationWithBlock:</code> ，直接添加一个 block 到 operation queue 中，而不用创建一个 NSBlockOperation 对象。</li>
</ul>


<p>在大多数情况下，一个 operation 被添加到 operation queue 后不久就会执行，但是也有很多原因会使 operation queue 延迟执行入队的 operation 。比如，我们前面提到了的，如果一个 operation 所依赖的其他 operation 还没有执行完成时，这个 operation 就不能开始执行；再比如说 operation queue 被暂停执行或者已经达到了它最大可并发的 operation 数。下面的示例代码展示了这三种方法的基本用法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">OQUseOperationQueue</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">executeOperationUsingOperationQueue</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">operationQueue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSInvocationOperation</span> <span class="o">*</span><span class="n">invocationOperation</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSInvocationOperation</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">taskMethod</span><span class="p">)</span> <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">operationQueue</span> <span class="nl">addOperation</span><span class="p">:</span><span class="n">invocationOperation</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">blockOperation1</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing blockOperation1, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing blockOperation1&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">blockOperation2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing blockOperation2, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing blockOperation2&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">operationQueue</span> <span class="nl">addOperations</span><span class="p">:</span><span class="l">@[</span> <span class="n">blockOperation1</span><span class="p">,</span> <span class="n">blockOperation2</span> <span class="l">]</span> <span class="nl">waitUntilFinished</span><span class="p">:</span><span class="nb">NO</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">operationQueue</span> <span class="nl">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing block, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing block&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">operationQueue</span> <span class="n">waitUntilAllOperationsAreFinished</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">taskMethod</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Start executing %@, mainThread: %@, currentThread: %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">),</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">mainThread</span><span class="p">],</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Finish executing %@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意</strong>，在将一个 operation 添加到 operation queue 后就不要再修改这个 operation 了。因为 operation 被添加到 operation queue 后随时可能会执行，这个是由系统决定的，所以再修改它的依赖关系或者所包含的数据就很有可能会造成未知的影响。</p>

<p>尽管 NSOperationQueue 类是被设计成用来并发执行 operation 的，但是我们也可以强制一个 operation queue 一次只执行一个 operation 。我们可以通过 <code>setMaxConcurrentoperationCount:</code> 方法来设置一个 operation queue 最大可并发的 operation 数，因此将这个值设置成 1 就可以实现让 operation queue 一次只执行一个 operation 的目的。但是需要注意的是，虽然这样可以让 operation queue 一次只执行一个 operation ，但是 operation 的执行顺序还是一样会受其他因素影响的，比如 operation 的 <code>isReady</code> 状态、operation 的队列优先级等。因此，一个串行的 operation queue 与一个串行的 dispatch queue 还是有本质区别的，因为 dispatch queue 的执行顺序一直是 <code>FIFO</code> 的。如果 operation 的执行顺序对我们来说非常重要，那么我们就应该在将 operation 添加到 operation queue 之前就建立好它的依赖关系。</p>

<h3>手动执行 Operation</h3>

<p>尽管使用 operation queue 是执行一个 operation 最方便的方式，但是我们也可以不用 operation queue 而选择手动地执行一个 operation 。从原理上来说，手动执行一个 operation 也是非常简单的，只需要调用它的 <code>start</code> 方法就可以了。但是从严格意义上来说，在调用 <code>start</code> 方法真正开始执行一个 operation 前，我们应该要做一些防范性的判断，比如检查 operation 的 <code>isReady</code> 状态是否为 <code>YES</code> ，这个取决于它所依赖的 operation 是否已经执行完成；又比如检查 operation 的 <code>isCancelled</code> 状态是否为 <code>YES</code> ，如果是，那么我们就根本不需要再花费不必要的开销去启动它。</p>

<p>另外，我们应该一直通过 <code>start</code> 方法去手动执行一个 operation ，而不是 <code>main</code> 或其他的什么方法。因为默认的 <code>start</code> 方法会在真正开始执行任务前为我们做一些安全性的检查，比如检查 operation 是否已取消等。另外，正如我们前面说的，在默认的 <code>start</code> 方法中会生成一些必要的 <code>KVO</code> 通知，比如 <code>isExcuting</code> 和 <code>isFinished</code> ，而这些 <code>KVO</code> 通知正是 operation 能够正确处理好依赖关系的关键所在。</p>

<p>更进一步说，如果我们需要实现的是一个并发的 operation ，我们也应该在启动 operation 前检查一下它的 <code>isConcurrent</code> 状态。如果它的 <code>isConcurrent</code> 状态为 <code>NO</code> ，那么我们就需要考虑一下是否可以在当前线程同步执行这个 operation ，或者是先为这个 operation 创建一个单独的线程，以供它异步执行。</p>

<p>当然，如果你已经能够确定一个 operation 的可执行状态，那么你大可不必做这些略显啰嗦的防范性检查，直接调用 <code>start</code> 方法执行这个 operation 即可。下面的示例代码展示了手动执行一个 operation 的基本流程：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">OQManualExecuteOperation</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">manualPerformOperation:</span><span class="p">(</span><span class="bp">NSOperation</span> <span class="o">*</span><span class="p">)</span><span class="nv">operation</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">ranIt</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">operation</span><span class="p">.</span><span class="n">isCancelled</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">ranIt</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">operation</span><span class="p">.</span><span class="n">isReady</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">operation</span><span class="p">.</span><span class="n">isConcurrent</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">[</span><span class="n">operation</span> <span class="n">start</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">detachNewThreadSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="nl">toTarget</span><span class="p">:</span><span class="n">operation</span> <span class="nl">withObject</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">ranIt</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">ranIt</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>取消 Operation</h3>

<p>从原则上来说，一旦一个 operation 被添加到 operation queue 后，这个 operation 的所有权就属于这个 operation queue 了，并且不能够被移除。唯一从 operation queue 中出队一个 operation 的方式就是调用它的 <code>cancel</code> 方法取消这个 operation ，或者直接调用 operation queue 的 <code>cancelAllOperations</code> 方法取消这个 operation queue 中所有的 operation 。另外，我们前面也提到了，当一个 operation 被取消后，这个 operation 的 <code>isFinished</code> 状态也会变成 <code>YES</code> ，这样处理的好处就是所有依赖它的 operation 能够接收到这个 <code>KVO</code> 通知，从而能够清除这个依赖关系正常执行。</p>

<h3>等待 Operation 执行完成</h3>

<p>一般来说，为了让我们的应用拥有最佳的性能，我们应该尽可能地异步执行所有的 operation ，从而让我们的应用在执行这些异步 operation 的同时还能够快速地响应用户事件。当然，我们也可以调用 NSOperation 类的 <code>waitUntilFinished</code> 方法来阻塞当前线程，直到这个 operation 执行完成。虽然这种方式可以让我们非常方便地处理 operation 的执行结果，但是却给我们的应用引入了更多的串行，限制了应用的并发性，从而降低了我们应用的响应性。</p>

<p><strong>注意</strong>，我们应该要坚决避免在主线程中去同步等待一个 operation 的执行结果，阻塞的方式只应该用在辅助线程或其他 operation 中。因为阻塞主线程会大大地降低我们应用的响应性，带来非常差的用户体验。</p>

<p>除了等待一个单独的 operation 执行完成外，我们也可以通过调用 NSOperationQueue 的 <code>waitUntilAlloperationsAreFinished</code> 方法来等待 operation queue 中的所有 operation 执行完成。有一点需要特别注意的是，当我们在等待一个 operation queue 中的所有 operation 执行完成时，其他的线程仍然可以向这个 operation queue 中添加 operation ，从而延长我们的等待时间。</p>

<h3>暂停和恢复 Operation Queue</h3>

<p>如果我们想要暂停和恢复执行 operation queue 中的 operation ，可以通过调用 operation queue 的 <code>setSuspended:</code> 方法来实现这个目的。不过需要注意的是，暂停执行 operation queue 并不能使正在执行的 operation 暂停执行，而只是简单地暂停调度新的 operation 。另外，我们并不能单独地暂停执行一个 operation ，除非直接 <code>cancel</code> 掉。</p>

<h2>总结</h2>

<p>看到这里，我想你对 iOS 的并发编程模型已经有了一定的了解。正如文中所说的，我们应该尽可能地直接使用队列而不是线程，让系统去与线程打交道，而我们只需定义好要调度的任务就可以了。一般情况下，我们也完全不需要去自定义一个并发的 operation ，因为在与 operation queue 结合使用时，operation queue 会自动为非并发的 operation 创建一个线程。Operation Queues 是对 <code>GCD</code> 面向对象的封装，它可以高度定制化，对依赖关系、队列优先级和线程优先级等提供了很好的支持，是我们实现复杂任务调度时的不二之选。</p>

<h2>参考链接</h2>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html">https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html</a>
<br>
<a href="http://www.raywenderlich.com/76341/use-nsoperation-nsoperationqueue-swift">http://www.raywenderlich.com/76341/use-nsoperation-nsoperationqueue-swift</a>
<br>
<a href="http://blog.xcodev.com/archives/operation-queue-intro/">http://blog.xcodev.com/archives/operation-queue-intro/</a></p>

<p><strong>版权声明</strong>：我已将本文在微信公众平台的发表权「独家代理」给 iOS 开发（iOSDevTips）微信公众号。扫下方二维码即可关注「iOS 开发」：</p>

<p><img src="http://blog.devtang.com/images/weixin-qr.jpg" alt="iOS 开发二维码" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Associated Objects 的实现原理]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/06/26/objective-c-associated-objects-implementation-principle/"/>
    <updated>2015-06-26T22:35:58+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/06/26/objective-c-associated-objects-implementation-principle</id>
    <content type="html"><![CDATA[<p>我们知道，在 Objective-C 中可以通过 Category 给一个现有的类添加属性，但是却不能添加实例变量，这似乎成为了 Objective-C 的一个明显短板。然而值得庆幸的是，我们可以通过 Associated Objects 来弥补这一不足。本文将结合 <a href="http://opensource.apple.com/tarballs/objc4/">runtime</a> 源码深入探究 Objective-C 中 Associated Objects 的实现原理。</p>

<p>在阅读本文的过程中，读者需要着重关注以下三个问题：</p>

<ol>
<li>关联对象被存储在什么地方，是不是存放在被关联对象本身的内存中？</li>
<li>关联对象的五种关联策略有什么区别，有什么坑？</li>
<li>关联对象的生命周期是怎样的，什么时候被释放，什么时候被移除？</li>
</ol>


<p></p>


<p>这是我写这篇文章的初衷，也是本文的价值所在。</p>

<h2>使用场景</h2>

<p>按照 Mattt Thompson 大神的文章 <a href="http://nshipster.com/associated-objects/">Associated Objects</a> 中的说法，Associated Objects 主要有以下三个使用场景：</p>

<ol>
<li>为现有的类添加私有变量以帮助实现细节；</li>
<li>为现有的类添加公有属性；</li>
<li>为 <code>KVO</code> 创建一个关联的观察者。</li>
</ol>


<p></p>


<p>从本质上看，第 <code>1</code> 、<code>2</code> 个场景其实是一个意思，唯一的区别就在于新添加的这个属性是公有的还是私有的而已。就目前来说，我在实际工作中使用得最多的是第 <code>2</code> 个场景，而第 <code>3</code> 个场景我还没有使用过。</p>

<h2>相关函数</h2>

<p>与 Associated Objects 相关的函数主要有三个，我们可以在 runtime 源码的 runtime.h 文件中找到它们的声明：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">objc_setAssociatedObject</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">id</span> <span class="n">value</span><span class="p">,</span> <span class="n">objc_AssociationPolicy</span> <span class="n">policy</span><span class="p">);</span>
</span><span class='line'><span class="kt">id</span> <span class="nf">objc_getAssociatedObject</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">objc_removeAssociatedObjects</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这三个函数的命名对程序员非常友好，可以让我们一眼就看出函数的作用：</p>

<ul>
<li><code>objc_setAssociatedObject</code> 用于给对象添加关联对象，传入 <code>nil</code> 则可以移除已有的关联对象；</li>
<li><code>objc_getAssociatedObject</code> 用于获取关联对象；</li>
<li><code>objc_removeAssociatedObjects</code> 用于移除一个对象的所有关联对象。</li>
</ul>


<p></p>


<p><strong>注</strong>：<code>objc_removeAssociatedObjects</code> 函数我们一般是用不上的，因为这个函数会移除一个对象的所有关联对象，将该对象恢复成“原始”状态。这样做就很有可能把别人添加的关联对象也一并移除，这并不是我们所希望的。所以一般的做法是通过给 <code>objc_setAssociatedObject</code> 函数传入 <code>nil</code> 来移除某个已有的关联对象。</p>

<h3>key 值</h3>

<p>关于前两个函数中的 <code>key</code> 值是我们需要重点关注的一个点，这个 <code>key</code> 值必须保证是一个对象级别（为什么是对象级别？看完下面的章节你就会明白了）的唯一常量。一般来说，有以下三种推荐的 <code>key</code> 值：</p>

<ol>
<li>声明 <code>static char kAssociatedObjectKey;</code> ，使用 <code>&amp;kAssociatedObjectKey</code> 作为 <code>key</code> 值;</li>
<li>声明 <code>static void *kAssociatedObjectKey = &amp;kAssociatedObjectKey;</code> ，使用 <code>kAssociatedObjectKey</code> 作为 <code>key</code> 值；</li>
<li>用 <code>selector</code> ，使用 <code>getter</code> 方法的名称作为 <code>key</code> 值。</li>
</ol>


<p></p>


<p>我个人最喜欢的（没有之一）是第 <code>3</code> 种方式，因为它省掉了一个变量名，非常优雅地解决了计算科学中的两大世界难题之一（命名）。</p>

<h3>关联策略</h3>

<p>在给一个对象添加关联对象时有五种关联策略可供选择：</p>

<p>
    <table border="1" width="100%">
        <tr>
            <th>关联策略</th>        
            <th>等价属性</th>        
            <th>说明</th>        
        </tr>
        <tr>
            <td>OBJC_ASSOCIATION_ASSIGN</td>        
            <td>@property (assign) or @property (unsafe_unretained)</td>
            <td>弱引用关联对象</td>        
        </tr>
        <tr>
            <td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>        
            <td>@property (strong, nonatomic)</td>        
            <td>强引用关联对象，且为非原子操作</td>        
        </tr>
        <tr>
            <td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>        
            <td>@property (copy, nonatomic)</td>        
            <td>复制关联对象，且为非原子操作</td>        
        </tr>
        <tr>
            <td>OBJC_ASSOCIATION_RETAIN</td>        
            <td>@property (strong, atomic)</td>        
            <td>强引用关联对象，且为原子操作</td>        
        </tr>
        <tr>
            <td>OBJC_ASSOCIATION_COPY</td>        
            <td>@property (copy, atomic)</td>        
            <td>复制关联对象，且为原子操作</td>        
        </tr>
    </table>
</p>


<p>其中，第 <code>2</code> 种与第 <code>4</code> 种、第 <code>3</code> 种与第 <code>5</code> 种关联策略的唯一差别就在于操作是否具有原子性。由于操作的原子性不在本文的讨论范围内，所以下面的实验和讨论就以前三种以例进行展开。</p>

<h2>实现原理</h2>

<p>在探究 Associated Objects 的实现原理前，我们还是先来动手做一个小实验，研究一下关联对象什么时候会被释放。本实验主要涉及 <code>ViewController</code> 类和它的分类 <code>ViewController+AssociatedObjects</code> 。<strong>注</strong>：本实验的完整代码可以在这里 <a href="https://github.com/leichunfeng/AssociatedObjects">AssociatedObjects</a> 找到，其中关键代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">ViewController</span> <span class="nl">(AssociatedObjects)</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">assign</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">associatedObject_assign</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">associatedObject_retain</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">copy</span><span class="p">,</span>   <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">associatedObject_copy</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ViewController</span> <span class="nl">(AssociatedObjects)</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">associatedObject_assign</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAssociatedObject_assign:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">associatedObject_assign</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">associatedObject_assign</span><span class="p">),</span> <span class="n">associatedObject_assign</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_ASSIGN</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">associatedObject_retain</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAssociatedObject_retain:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">associatedObject_retain</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">associatedObject_retain</span><span class="p">),</span> <span class="n">associatedObject_retain</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">associatedObject_copy</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAssociatedObject_copy:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">associatedObject_copy</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">associatedObject_copy</span><span class="p">),</span> <span class="n">associatedObject_copy</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_COPY_NONATOMIC</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 <code>ViewController+AssociatedObjects.h</code> 中声明了三个属性，限定符分别为 <code>assign, nonatomic</code> 、<code>strong, nonatomic</code> 和 <code>copy, nonatomic</code> ，而在 <code>ViewController+AssociatedObjects.m</code> 中相应的分别用 <code>OBJC_ASSOCIATION_ASSIGN</code> 、<code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> 、<code>OBJC_ASSOCIATION_COPY_NONATOMIC</code> 三种关联策略为这三个属性添加“实例变量”。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">__weak</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">string_weak_assign</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="k">__weak</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">string_weak_retain</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="k">__weak</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">string_weak_copy</span>   <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ViewController</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">associatedObject_assign</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;leichunfeng1&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">associatedObject_retain</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;leichunfeng2&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">associatedObject_copy</span>   <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;leichunfeng3&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">string_weak_assign</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">associatedObject_assign</span><span class="p">;</span>
</span><span class='line'>    <span class="n">string_weak_retain</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">associatedObject_retain</span><span class="p">;</span>
</span><span class='line'>    <span class="n">string_weak_copy</span>   <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">associatedObject_copy</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesBegan:</span><span class="p">(</span><span class="bp">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="bp">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
</span><span class='line'><span class="c1">//    NSLog(@&quot;self.associatedObject_assign: %@&quot;, self.associatedObject_assign); // Will Crash</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;self.associatedObject_retain: %@&quot;</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">associatedObject_retain</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;self.associatedObject_copy:   %@&quot;</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">associatedObject_copy</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 <code>ViewController</code> 的 <code>viewDidLoad</code> 方法中，我们对三个属性进行了赋值，并声明了三个全局的 <code>__weak</code> 变量来观察相应对象的释放时机。此外，我们重写了 <code>touchesBegan:withEvent:</code> 方法，在方法中分别打印了这三个属性的当前值。</p>

<p>在继续阅读下面章节前，建议读者先自行思考一下 <code>self.associatedObject_assign</code> 、<code>self.associatedObject_retain</code> 和 <code>self.associatedObject_copy</code> 指向的对象分别会在什么时候被释放，以加深理解。</p>

<h3>实验</h3>

<p>我们先在 <code>viewDidLoad</code> 方法的第 <code>28</code> 行打上断点，然后运行程序，点击导航栏右上角的按钮 <code>Push</code> 到 <code>ViewController</code> 界面，程序将停在断点处。接着，我们使用 <code>lldb</code> 的 <code>watchpoint</code> 命令来设置观察点，观察全局变量 <code>string_weak_assign</code> 、<code>string_weak_retain</code> 和 <code>string_weak_copy</code> 的值的变化。正确设置好观察点后，将会在 <code>console</code> 中看到如下的类似输出：</p>

<p><img src="http://blog.leichunfeng.com/images/AssociatedObjects1.jpg" title="设置观察点" alt="设置观察点" /></p>

<p>点击继续运行按钮，有一个观察点将被命中。我们先查看 <code>console</code> 中的输出，通过将这一步打印的 <code>old value</code> 和上一步的 <code>new value</code> 进行对比，我们可以知道本次命中的观察点是 <code>string_weak_assign</code> ，<code>string_weak_assign</code> 的值变成了 <code>0x0000000000000000</code> ，也就是 <code>nil</code> 。换句话说 <code>self.associatedObject_assign</code> 指向的对象已经被释放了，而通过查看左侧调用栈我们可以知道，这个对象是由于其所在的 <code>autoreleasepool</code> 被 <code>drain</code> 而被释放的，这与我前面的文章<a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/">《Objective-C Autorelease Pool 的实现原理
》</a>中的表述是一致的。<strong>提示</strong>，待会你也可以放开 <code>touchesBegan:withEvent:</code> 中第 <code>31</code> 行的注释，在 <code>ViewController</code> 出现后，点击一下它的 <code>view</code> ，进一步验证一下这个结论。</p>

<p><img src="http://blog.leichunfeng.com/images/AssociatedObjects2.jpg" title="设置观察点" alt="设置观察点" /></p>

<p>接下来，我们点击 <code>ViewController</code> 导航栏左上角的按钮，返回前一个界面，此时，又将有一个观察点被命中。同理，我们可以知道这个观察点是 <code>string_weak_retain</code> 。我们查看左侧的调用栈，将会发现一个非常敏感的函数调用 <code>_object_remove_assocations</code> ，调用这个函数后 <code>ViewController</code> 的所有关联对象被全部移除。最终，<code>self.associatedObject_retain</code> 指向的对象被释放。</p>

<p><img src="http://blog.leichunfeng.com/images/AssociatedObjects3.jpg" title="设置观察点" alt="设置观察点" /></p>

<p>点击继续运行按钮，最后一个观察点 <code>string_weak_copy</code> 被命中。同理，<code>self.associatedObject_copy</code> 指向的对象也由于关联对象的移除被最终释放。</p>

<p><img src="http://blog.leichunfeng.com/images/AssociatedObjects4.jpg" title="设置观察点" alt="设置观察点" /></p>

<h3>结论</h3>

<p>由这个实验，我们可以得出以下结论：</p>

<ol>
<li>关联对象的释放时机与被移除的时机并不总是一致的，比如上面的 <code>self.associatedObject_assign</code> 所指向的对象在 <code>ViewController</code> 出现后就被释放了，但是 <code>self.associatedObject_assign</code> 仍然有值，还是保存的原对象的地址。如果之后再使用 <code>self.associatedObject_assign</code> 就会造成 Crash ，所以我们在使用弱引用的关联对象时要非常小心；</li>
<li>一个对象的所有关联对象是在这个对象被释放时调用的 <code>_object_remove_assocations</code> 函数中被移除的。</li>
</ol>


<p></p>


<p>接下来，我们就一起看看 runtime 中的源码，来验证下我们的实验结论。</p>

<h3>objc_setAssociatedObject</h3>

<p>我们可以在 <code>objc-references.mm</code> 文件中找到 <code>objc_setAssociatedObject</code> 函数最终调用的函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">_object_set_associative_reference</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">id</span> <span class="n">value</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">policy</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// retain the new value (if any) outside the lock.</span>
</span><span class='line'>    <span class="n">ObjcAssociation</span> <span class="n">old_association</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">nil</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">new_value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">?</span> <span class="n">acquireValue</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">policy</span><span class="p">)</span> <span class="o">:</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">AssociationsManager</span> <span class="n">manager</span><span class="p">;</span>
</span><span class='line'>        <span class="n">AssociationsHashMap</span> <span class="o">&amp;</span><span class="n">associations</span><span class="p">(</span><span class="n">manager</span><span class="p">.</span><span class="n">associations</span><span class="p">());</span>
</span><span class='line'>        <span class="kt">disguised_ptr_t</span> <span class="n">disguised_object</span> <span class="o">=</span> <span class="n">DISGUISE</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">new_value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// break any existing association.</span>
</span><span class='line'>            <span class="n">AssociationsHashMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">associations</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">disguised_object</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">associations</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// secondary table exists</span>
</span><span class='line'>                <span class="n">ObjectAssociationMap</span> <span class="o">*</span><span class="n">refs</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'>                <span class="n">ObjectAssociationMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">j</span> <span class="o">=</span> <span class="n">refs</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">refs</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">old_association</span> <span class="o">=</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'>                    <span class="n">j</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">=</span> <span class="n">ObjcAssociation</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">new_value</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                    <span class="p">(</span><span class="o">*</span><span class="n">refs</span><span class="p">)[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ObjcAssociation</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">new_value</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// create the new association (first time).</span>
</span><span class='line'>                <span class="n">ObjectAssociationMap</span> <span class="o">*</span><span class="n">refs</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ObjectAssociationMap</span><span class="p">;</span>
</span><span class='line'>                <span class="n">associations</span><span class="p">[</span><span class="n">disguised_object</span><span class="p">]</span> <span class="o">=</span> <span class="n">refs</span><span class="p">;</span>
</span><span class='line'>                <span class="p">(</span><span class="o">*</span><span class="n">refs</span><span class="p">)[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">ObjcAssociation</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">new_value</span><span class="p">);</span>
</span><span class='line'>                <span class="n">object</span><span class="o">-&gt;</span><span class="n">setHasAssociatedObjects</span><span class="p">();</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// setting the association to nil breaks the association.</span>
</span><span class='line'>            <span class="n">AssociationsHashMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">associations</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">disguised_object</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span>  <span class="n">associations</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">ObjectAssociationMap</span> <span class="o">*</span><span class="n">refs</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'>                <span class="n">ObjectAssociationMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">j</span> <span class="o">=</span> <span class="n">refs</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">refs</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">old_association</span> <span class="o">=</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'>                    <span class="n">refs</span><span class="o">-&gt;</span><span class="n">erase</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// release the old value (outside of the lock).</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">old_association</span><span class="p">.</span><span class="n">hasValue</span><span class="p">())</span> <span class="n">ReleaseValue</span><span class="p">()(</span><span class="n">old_association</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在看这段代码前，我们需要先了解一下几个数据结构以及它们之间的关系：</p>

<ol>
<li><code>AssociationsManager</code> 是顶级的对象，维护了一个从 <code>spinlock_t</code> 锁到 <code>AssociationsHashMap</code> 哈希表的单例键值对映射；</li>
<li><code>AssociationsHashMap</code> 是一个无序的哈希表，维护了从对象地址到 <code>ObjectAssociationMap</code> 的映射；</li>
<li><code>ObjectAssociationMap</code> 是一个 <code>C++</code> 中的 <code>map</code> ，维护了从 <code>key</code> 到 <code>ObjcAssociation</code> 的映射，即关联记录；</li>
<li><code>ObjcAssociation</code> 是一个 <code>C++</code> 的类，表示一个具体的关联结构，主要包括两个实例变量，<code>_policy</code> 表示关联策略，<code>_value</code> 表示关联对象。</li>
</ol>


<p></p>


<p>每一个对象地址对应一个 <code>ObjectAssociationMap</code> 对象，而一个 <code>ObjectAssociationMap</code> 对象保存着这个对象的若干个关联记录。</p>

<p>弄清楚这些数据结构之间的关系后，再回过头来看上面的代码就不难了。我们发现，在苹果的底层代码中一般都会充斥着各种 <code>if else</code> ，可见写好 <code>if else</code> 后我们就距离成为高手不远了。开个玩笑，我们来看下面的流程图，一图胜千言：</p>

<p><img src="http://blog.leichunfeng.com/images/objc_setAssociatedObject.png" title="objc_setAssociatedObject" alt="objc_setAssociatedObject" /></p>

<h3>objc_getAssociatedObject</h3>

<p>同样的，我们也可以在 <code>objc-references.mm</code> 文件中找到 <code>objc_getAssociatedObject</code> 函数最终调用的函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="nf">_object_get_associative_reference</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">uintptr_t</span> <span class="n">policy</span> <span class="o">=</span> <span class="n">OBJC_ASSOCIATION_ASSIGN</span><span class="p">;</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">AssociationsManager</span> <span class="n">manager</span><span class="p">;</span>
</span><span class='line'>        <span class="n">AssociationsHashMap</span> <span class="o">&amp;</span><span class="n">associations</span><span class="p">(</span><span class="n">manager</span><span class="p">.</span><span class="n">associations</span><span class="p">());</span>
</span><span class='line'>        <span class="kt">disguised_ptr_t</span> <span class="n">disguised_object</span> <span class="o">=</span> <span class="n">DISGUISE</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
</span><span class='line'>        <span class="n">AssociationsHashMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">associations</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">disguised_object</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">associations</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">ObjectAssociationMap</span> <span class="o">*</span><span class="n">refs</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'>            <span class="n">ObjectAssociationMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">j</span> <span class="o">=</span> <span class="n">refs</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="n">refs</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">ObjcAssociation</span> <span class="o">&amp;</span><span class="n">entry</span> <span class="o">=</span> <span class="n">j</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'>                <span class="n">value</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
</span><span class='line'>                <span class="n">policy</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">policy</span><span class="p">();</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">policy</span> <span class="o">&amp;</span> <span class="n">OBJC_ASSOCIATION_GETTER_RETAIN</span><span class="p">)</span> <span class="p">((</span><span class="kt">id</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">value</span><span class="p">,</span> <span class="n">SEL_retain</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">policy</span> <span class="o">&amp;</span> <span class="n">OBJC_ASSOCIATION_GETTER_AUTORELEASE</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">((</span><span class="kt">id</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">value</span><span class="p">,</span> <span class="n">SEL_autorelease</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>看懂了 <code>objc_setAssociatedObject</code> 函数后，<code>objc_getAssociatedObject</code> 函数对我们来说就是小菜一碟了。这个函数先根据对象地址在 <code>AssociationsHashMap</code> 中查找其对应的 <code>ObjectAssociationMap</code> 对象，如果能找到则进一步根据 <code>key</code> 在 <code>ObjectAssociationMap</code> 对象中查找这个 <code>key</code> 所对应的关联结构 <code>ObjcAssociation</code> ，如果能找到则返回 <code>ObjcAssociation</code> 对象的 <code>value</code> 值，否则返回 <code>nil</code> 。</p>

<h3>objc_removeAssociatedObjects</h3>

<p>同理，我们也可以在 <code>objc-references.mm</code> 文件中找到 <code>objc_removeAssociatedObjects</code> 函数最终调用的函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">_object_remove_assocations</span><span class="p">(</span><span class="kt">id</span> <span class="n">object</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">vector</span><span class="o">&lt;</span> <span class="n">ObjcAssociation</span><span class="p">,</span><span class="n">ObjcAllocator</span><span class="o">&lt;</span><span class="n">ObjcAssociation</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">elements</span><span class="p">;</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">AssociationsManager</span> <span class="n">manager</span><span class="p">;</span>
</span><span class='line'>        <span class="n">AssociationsHashMap</span> <span class="o">&amp;</span><span class="n">associations</span><span class="p">(</span><span class="n">manager</span><span class="p">.</span><span class="n">associations</span><span class="p">());</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">associations</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">disguised_ptr_t</span> <span class="n">disguised_object</span> <span class="o">=</span> <span class="n">DISGUISE</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
</span><span class='line'>        <span class="n">AssociationsHashMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">associations</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">disguised_object</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">associations</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// copy all of the associations that need to be removed.</span>
</span><span class='line'>            <span class="n">ObjectAssociationMap</span> <span class="o">*</span><span class="n">refs</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'>            <span class="k">for</span> <span class="p">(</span><span class="n">ObjectAssociationMap</span><span class="o">::</span><span class="n">iterator</span> <span class="n">j</span> <span class="o">=</span> <span class="n">refs</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span> <span class="o">=</span> <span class="n">refs</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">elements</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">j</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="c1">// remove the secondary table.</span>
</span><span class='line'>            <span class="n">delete</span> <span class="n">refs</span><span class="p">;</span>
</span><span class='line'>            <span class="n">associations</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// the calls to releaseValue() happen outside of the lock.</span>
</span><span class='line'>    <span class="n">for_each</span><span class="p">(</span><span class="n">elements</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">elements</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ReleaseValue</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数负责移除一个对象的所有关联对象，具体实现也是先根据对象的地址获取其对应的 <code>ObjectAssociationMap</code> 对象，然后将所有的关联结构保存到一个 <code>vector</code> 中，最终释放 <code>vector</code> 中保存的所有关联对象。根据前面的实验观察到的情况，在一个对象被释放时，也正是调用的这个函数来移除其所有的关联对象。</p>

<h3>给类对象添加关联对象</h3>

<p>看完源代码后，我们知道对象地址与 <code>AssociationsHashMap</code> 哈希表是一一对应的。那么我们可能就会思考这样一个问题，是否可以给类对象添加关联对象呢？答案是肯定的。我们完全可以用同样的方式给类对象添加关联对象，只不过我们一般情况下不会这样做，因为更多时候我们可以通过 <code>static</code> 变量来实现类级别的变量。我在分类 <code>ViewController+AssociatedObjects</code> 中给 <code>ViewController</code> 类对象添加了一个关联对象 <code>associatedObject</code> ，读者可以亲自在 <code>viewDidLoad</code> 方法中调用一下以下两个方法验证一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">associatedObject</span><span class="p">;</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAssociatedObject:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">associatedObject</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>读到这里，相信你对开篇的那三个问题已经有了一定的认识，下面我们再梳理一下：</p>

<ol>
<li>关联对象与被关联对象本身的存储并没有直接的关系，它是存储在单独的哈希表中的；</li>
<li>关联对象的五种关联策略与属性的限定符非常类似，在绝大多数情况下，我们都会使用 <code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> 的关联策略，这可以保证我们持有关联对象；</li>
<li>关联对象的释放时机与移除时机并不总是一致，比如实验中用关联策略 <code>OBJC_ASSOCIATION_ASSIGN</code> 进行关联的对象，很早就已经被释放了，但是并没有被移除，而再使用这个关联对象时就会造成 Crash 。</li>
</ol>


<p></p>


<p>在弄懂 Associated Objects 的实现原理后，可以帮助我们更好地使用它，在出现问题时也能尽快地定位问题，最后希望本文能够对你有所帮助。</p>

<h2>参考链接</h2>

<p><a href="http://nshipster.com/associated-objects/">http://nshipster.com/associated-objects/</a>
<br>
<a href="http://kingscocoa.com/tutorials/associated-objects/">http://kingscocoa.com/tutorials/associated-objects/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Method Swizzling 的最佳实践]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/06/14/objective-c-method-swizzling-best-practice/"/>
    <updated>2015-06-14T12:03:32+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/06/14/objective-c-method-swizzling-best-practice</id>
    <content type="html"><![CDATA[<p>Objective-C 中的 Method Swizzling 是一项<strong>异常</strong>强大的技术，它可以允许我们动态地替换方法的实现，实现 <code>Hook</code> 功能，是一种比子类化更加灵活的“重写”方法的方式。</p>

<h2>Method Swizzling 的原理</h2>

<p>Method Swizzling 是一把双刃剑，使用得当可以让我们非常轻松地实现复杂的功能，而如果一旦误用，它也很可能会给我们的程序带来毁灭性的伤害。但是我们大可不必惊慌，在了解了它的实现原理后，我们就可以“信手拈来”了。</p>

<p>我们先来了解下 Objective-C 中方法 <code>Method</code> 的数据结构：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="kt">method_t</span> <span class="o">*</span><span class="n">Method</span><span class="p">;</span>
</span><span class='line'><span class="k">struct</span> <span class="kt">method_t</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">SEL</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">types</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">IMP</span> <span class="n">imp</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">struct</span> <span class="nl">SortBySELAddress</span> <span class="p">:</span>
</span><span class='line'>        <span class="n">public</span> <span class="n">std</span><span class="o">::</span><span class="n">binary_function</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">method_t</span><span class="o">&amp;</span><span class="p">,</span>
</span><span class='line'>                                    <span class="k">const</span> <span class="kt">method_t</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">bool</span> <span class="n">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="kt">method_t</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span>
</span><span class='line'>                         <span class="k">const</span> <span class="kt">method_t</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span> <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">name</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">name</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>本质上，它就是 <code>struct method_t</code> 类型的指针，所以我们重点看下结构体 <code>method_t</code> 的定义。在结构体 <code>method_t</code> 中定义了三个成员变量和一个成员函数：</p>

<ol>
<li><code>name</code> 表示的是方法的名称，用于唯一标识某个方法，比如 <code>@selector(viewWillAppear:)</code> ；</li>
<li><code>types</code> 表示的是方法的返回值和参数类型（详细信息可以查阅苹果官方文档中的 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encodings</a> ）；</li>
<li><code>imp</code> 是一个函数指针，指向方法的实现；</li>
<li><code>SortBySELAddress</code> 顾名思义，是一个根据 <code>name</code> 的地址对方法进行排序的函数。</li>
</ol>


<p>由此，我们也可以发现 Objective-C 中的方法名是不包括参数类型的，也就是说下面两个方法在 runtime 看来就是同一个方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillAppear:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">string</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>而下面两个方法却是可以共存的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span><span class="p">;</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为实例方法和类方法是分别保存在类对象和元类对象中的，更多详情可以查看我前面的文章<a href="http://blog.leichunfeng.com/blog/2015/04/25/objective-c-object-model/">《Objective-C 对象模型》</a>。</p>

<p>原则上，方法的名称 <code>name</code> 和方法的实现 <code>imp</code> 是一一对应的，而 Method Swizzling 的原理就是动态地改变它们的对应关系，以达到替换方法实现的目的。</p>

<h2>Method Swizzling 有什么用</h2>

<p>说了这么多，到底 Method Swizzling 有什么用呢？表猴急哈，我们接下来看个例子就明白了。用过<a href="http://www.umeng.com/">友盟</a>统计的同学应该知道，要实现<a href="http://dev.umeng.com/analytics/ios-doc/integration#3">页面的统计</a>功能，我们需要在每个页面的 <code>view controller</code> 中添加如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="nl">viewWillAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">MobClick</span> <span class="nl">beginLogPageView</span><span class="p">:</span><span class="s">@&quot;PageOne&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillDisappear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="nl">viewWillDisappear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">MobClick</span> <span class="nl">endLogPageView</span><span class="p">:</span><span class="s">@&quot;PageOne&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>要达到这个目的，我们有两种比较常规的实现方式：</p>

<ol>
<li>直接修改每个页面的 <code>view controller</code> 代码，简单粗暴；</li>
<li>子类化 <code>view controller</code> ，并让我们的 <code>view controller</code> 都继承这些子类。</li>
</ol>


<p>第 1 种方式的缺点是不言而喻的，这样做不仅会产生大量重复的代码，而且还很容易遗漏某些页面，非常难维护；第 2 种方式稍微好一点，但是也同样需要我们子类化 <code>UIViewController</code> 、<code>UITableViewController</code> 和 <code>UITabBarController</code> 等不同类型的 <code>view controller</code> 。</p>

<p>也许你跟我一样陷入了思考，难道就没有一种简单优雅的解决方案吗？答案是肯定的，Method Swizzling 就是解决此类问题的最佳方式。</p>

<h2>Method Swizzling 的最佳实践</h2>

<p>下面我们就以替换 <code>viewWillAppear</code> 方法为例谈谈 Method Swizzling 的最佳实践，话不多说，直接上代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="bp">UIViewController</span> <span class="nl">(MRCUMAnalytics)</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="bp">UIViewController</span> <span class="nl">(MRCUMAnalytics)</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">load</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class='line'>    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="kt">Class</span> <span class="k">class</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="k">class</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">SEL</span> <span class="n">originalSelector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">viewWillAppear</span><span class="p">:);</span>
</span><span class='line'>        <span class="kt">SEL</span> <span class="n">swizzledSelector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">mrc_viewWillAppear</span><span class="p">:);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">Method</span> <span class="n">originalMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="k">class</span><span class="p">,</span> <span class="n">originalSelector</span><span class="p">);</span>
</span><span class='line'>        <span class="n">Method</span> <span class="n">swizzledMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="k">class</span><span class="p">,</span> <span class="n">swizzledSelector</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">BOOL</span> <span class="n">success</span> <span class="o">=</span> <span class="n">class_addMethod</span><span class="p">(</span><span class="k">class</span><span class="p">,</span> <span class="n">originalSelector</span><span class="p">,</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">swizzledMethod</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">swizzledMethod</span><span class="p">));</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">class_replaceMethod</span><span class="p">(</span><span class="k">class</span><span class="p">,</span> <span class="n">swizzledSelector</span><span class="p">,</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">));</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">,</span> <span class="n">swizzledMethod</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - Method Swizzling</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">mrc_viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">mrc_viewWillAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">MobClick</span> <span class="nl">beginLogPageView</span><span class="p">:</span><span class="n">NSStringFromClass</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">])];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>解析</strong>：在上面的代码中有三个关键点需要引起我们的注意：</p>

<ol>
<li>为什么是在 <code>+load</code> 方法中实现 Method Swizzling 的逻辑，而不是其他的什么方法，比如 <code>+initialize</code> 等；</li>
<li>为什么 Method Swizzling 的逻辑需要用 dispatch_once 来进行调度；</li>
<li>为什么需要调用 <code>class_addMethod</code> 方法，并且以它的结果为依据分别处理两种不同的情况。</li>
</ol>


<p>下面我们就一起来分析下这三个为什么到底是为了什么？</p>

<p><strong>第 1 个为什么</strong>：看过我前面文章<a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/">《Objective-C +load vs +initialize》</a> 的同学应该知道，<code>+load</code> 和 <code>+initialize</code> 是 Objective-C runtime 会自动调用的两个类方法。但是它们被调用的时机却是有差别的，<code>+load</code> 方法是在类被加载的时候调用的，而 <code>+initialize</code> 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。也就是说 <code>+initialize</code> 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 <code>+initialize</code> 方法是永远不会被调用的。此外 <code>+load</code> 方法还有一个非常重要的特性，那就是子类、父类和分类中的 <code>+load</code> 方法的实现是被区别对待的。换句话说在 Objective-C runtime 自动调用 <code>+load</code> 方法时，分类中的 <code>+load</code> 方法并不会对主类中的 <code>+load</code> 方法造成覆盖。综上所述，<code>+load</code> 方法是实现 Method Swizzling 逻辑的最佳“场所”。</p>

<p><strong>第 2 个为什么</strong>：我们上面提到，<code>+load</code> 方法在类加载的时候会被 runtime 自动调用一次，但是它并没有限制程序员对 <code>+load</code> 方法的手动调用。什么？你说不会有程序员这么干？那可说不定，我还见过手动调用 <code>viewDidLoad</code> 方法的程序员，就是介么任性。而我们所能够做的就是尽可能地保证程序能够在各种情况下正常运行。</p>

<p><strong>第 3 个为什么</strong>：我们使用 Method Swizzling 的目的通常都是为了给程序增加功能，而不是完全地替换某个功能，所以我们一般都需要在自定义的实现中调用原始的实现。所以这里就会有两种情况需要我们分别进行处理：</p>

<p><strong>第 1 种情况</strong>：主类本身有实现需要替换的方法，也就是 <code>class_addMethod</code> 方法返回 <code>NO</code> 。这种情况的处理比较简单，直接交换两个方法的实现就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">/// 先调用原始实现，由于主类本身有实现该方法，所以这里实际调用的是主类的实现</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">mrc_viewWillAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">/// 我们增加的功能</span>
</span><span class='line'>    <span class="p">[</span><span class="n">MobClick</span> <span class="nl">beginLogPageView</span><span class="p">:</span><span class="n">NSStringFromClass</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">])];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">mrc_viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">/// 主类的实现</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>第 2 种情况</strong>：主类本身没有实现需要替换的方法，而是继承了父类的实现，即 <code>class_addMethod</code> 方法返回 <code>YES</code> 。这时使用 <code>class_getInstanceMethod</code> 函数获取到的 <code>originalSelector</code> 指向的就是父类的方法，我们再通过执行 <code>class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</code> 将父类的实现替换到我们自定义的 <code>mrc_viewWillAppear</code> 方法中。这样就达到了在 <code>mrc_viewWillAppear</code> 方法的实现中调用父类实现的目的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">/// 先调用原始实现，由于主类本身并没有实现该方法，所以这里实际调用的是父类的实现</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">mrc_viewWillAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">/// 我们增加的功能</span>
</span><span class='line'>    <span class="p">[</span><span class="n">MobClick</span> <span class="nl">beginLogPageView</span><span class="p">:</span><span class="n">NSStringFromClass</span><span class="p">([</span><span class="nb">self</span> <span class="k">class</span><span class="p">])];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">mrc_viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">/// 父类的实现</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>看到这里，相信你对 Method Swizzling 已经有了一定的了解，那么接下来就请你自己亲自试一试吧，you should give it a try yourself 。</p>

<h2>总结</h2>

<p>Method Swizzling 是一种黑魔法，我们在使用它时需要加倍小心，而遵循本文的最佳实践可以让你事半功倍。</p>

<h2>参考链接</h2>

<p><a href="http://nshipster.com/method-swizzling/">http://nshipster.com/method-swizzling/</a>
<br>
<a href="https://www.mikeash.com/pyblog/friday-qa-2010-01-29-method-replacement-for-fun-and-profit.html">https://www.mikeash.com/pyblog/friday-qa-2010-01-29-method-replacement-for-fun-and-profit.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Autorelease Pool 的实现原理]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/"/>
    <updated>2015-05-31T10:46:34+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle</id>
    <content type="html"><![CDATA[<p>内存管理一直是学习 Objective-C 的重点和难点之一，尽管现在已经是 ARC 时代了，但是了解 Objective-C 的内存管理机制仍然是十分必要的。其中，弄清楚 autorelease 的原理更是重中之重，只有理解了 autorelease 的原理，我们才算是真正了解了 Objective-C 的内存管理机制。<strong>注</strong>：本文使用的 <a href="http://opensource.apple.com/tarballs/objc4/">runtime</a> 源码是当前的最新版本 <code>objc4-646.tar.gz</code> 。</p>

<h2>autoreleased 对象什么时候释放</h2>

<p>autorelease 本质上就是延迟调用 release ，那 autoreleased 对象究竟会在什么时候释放呢？为了弄清楚这个问题，我们先来做一个小实验。这个小实验分 3 种场景进行，请你先自行思考在每种场景下的 console 输出，以加深理解。<strong>注</strong>：本实验的源码可以在这里 <a href="https://github.com/leichunfeng/AutoreleasePool">AutoreleasePool</a> 找到。</p>

<p><strong>特别说明</strong>：在苹果一些新的硬件设备上，本实验的结果已经不再成立，详细情况如下：</p>

<ul>
<li>iPad 2</li>
<li><del>iPad Air</del></li>
<li><del>iPad Air 2</del></li>
<li><del>iPad Pro</del></li>
<li>iPad Retina</li>
<li>iPhone 4s</li>
<li>iPhone 5</li>
<li><del>iPhone 5s</del></li>
<li><del>iPhone 6</del></li>
<li><del>iPhone 6 Plus</del></li>
<li><del>iPhone 6s</del></li>
<li><del>iPhone 6s Plus</del></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">__weak</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">string_weak_</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 场景 1</span>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;leichunfeng&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">string_weak_</span> <span class="o">=</span> <span class="n">string</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 场景 2</span>
</span><span class='line'><span class="c1">//    @autoreleasepool {</span>
</span><span class='line'><span class="c1">//        NSString *string = [NSString stringWithFormat:@&quot;leichunfeng&quot;];</span>
</span><span class='line'><span class="c1">//        string_weak_ = string;</span>
</span><span class='line'><span class="c1">//    }</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 场景 3</span>
</span><span class='line'><span class="c1">//    NSString *string = nil;</span>
</span><span class='line'><span class="c1">//    @autoreleasepool {</span>
</span><span class='line'><span class="c1">//        string = [NSString stringWithFormat:@&quot;leichunfeng&quot;];</span>
</span><span class='line'><span class="c1">//        string_weak_ = string;</span>
</span><span class='line'><span class="c1">//    }</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;string: %@&quot;</span><span class="p">,</span> <span class="n">string_weak_</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="nl">viewWillAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;string: %@&quot;</span><span class="p">,</span> <span class="n">string_weak_</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidAppear:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="nl">viewDidAppear</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;string: %@&quot;</span><span class="p">,</span> <span class="n">string_weak_</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>思考得怎么样了？相信在你心中已经有答案了。那么让我们一起来看看 console 输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 场景 1</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">32</span><span class="o">:</span><span class="mf">20.837</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33876</span><span class="o">:</span><span class="mi">1448343</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="n">leichunfeng</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">32</span><span class="o">:</span><span class="mf">20.838</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33876</span><span class="o">:</span><span class="mi">1448343</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="n">leichunfeng</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">32</span><span class="o">:</span><span class="mf">20.845</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33876</span><span class="o">:</span><span class="mi">1448343</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="p">(</span><span class="n">null</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 场景 2</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">32</span><span class="o">:</span><span class="mf">50.548</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33915</span><span class="o">:</span><span class="mi">1448912</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="p">(</span><span class="n">null</span><span class="p">)</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">32</span><span class="o">:</span><span class="mf">50.549</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33915</span><span class="o">:</span><span class="mi">1448912</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="p">(</span><span class="n">null</span><span class="p">)</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">32</span><span class="o">:</span><span class="mf">50.555</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33915</span><span class="o">:</span><span class="mi">1448912</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="p">(</span><span class="n">null</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 场景 3</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">33</span><span class="o">:</span><span class="mf">07.075</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33984</span><span class="o">:</span><span class="mi">1449418</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="n">leichunfeng</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">33</span><span class="o">:</span><span class="mf">07.075</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33984</span><span class="o">:</span><span class="mi">1449418</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="p">(</span><span class="n">null</span><span class="p">)</span>
</span><span class='line'><span class="mi">2015</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">30</span> <span class="mi">10</span><span class="o">:</span><span class="mi">33</span><span class="o">:</span><span class="mf">07.094</span> <span class="n">AutoreleasePool</span><span class="p">[</span><span class="mi">33984</span><span class="o">:</span><span class="mi">1449418</span><span class="p">]</span> <span class="nl">string</span><span class="p">:</span> <span class="p">(</span><span class="n">null</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>跟你预想的结果有出入吗？Any way ，我们一起来分析下为什么会得到这样的结果。</p>

<p><strong>分析</strong>：3 种场景下，我们都通过 <code>[NSString stringWithFormat:@"leichunfeng"]</code> 创建了一个 autoreleased 对象，这是我们实验的前提。并且，为了能够在 <code>viewWillAppear</code> 和 <code>viewDidAppear</code> 中继续访问这个对象，我们使用了一个全局的 <code>__weak</code> 变量 <code>string_weak_</code> 来指向它。因为 <code>__weak</code> 变量有一个特性就是它不会影响所指向对象的生命周期，这里我们正是利用了这个特性。</p>

<p><strong>场景 1</strong>：当使用 <code>[NSString stringWithFormat:@"leichunfeng"]</code> 创建一个对象时，这个对象的引用计数为 1 ，并且这个对象被系统自动添加到了当前的 autoreleasepool 中。当使用局部变量 <code>string</code> 指向这个对象时，这个对象的引用计数 +1 ，变成了 2 。因为在 ARC 下 <code>NSString *string</code> 本质上就是 <code>__strong NSString *string</code> 。所以在 <code>viewDidLoad</code> 方法返回前，这个对象是一直存在的，且引用计数为 2 。而当 <code>viewDidLoad</code> 方法返回时，局部变量 <code>string</code> 被回收，指向了 <code>nil</code> 。因此，其所指向对象的引用计数 -1 ，变成了 1 。</p>

<p>而在 <code>viewWillAppear</code> 方法中，我们仍然可以打印出这个对象的值，说明这个对象并没有被释放。咦，这不科学吧？我读书少，你表骗我。不是一直都说当函数返回的时候，函数内部产生的对象就会被释放的吗？如果你这样想的话，那我只能说：骚年你太年经了。开个玩笑，我们继续。前面我们提到了，这个对象是一个 autoreleased 对象，autoreleased 对象是被添加到了当前最近的 autoreleasepool 中的，只有当这个 autoreleasepool 自身 drain 的时候，autoreleasepool 中的 autoreleased 对象才会被 release 。</p>

<p>另外，我们注意到当在 <code>viewDidAppear</code> 中再打印这个对象的时候，对象的值变成了 <code>nil</code> ，说明此时对象已经被释放了。因此，我们可以大胆地猜测一下，这个对象一定是在 <code>viewWillAppear</code> 和 <code>viewDidAppear</code> 方法之间的某个时候被释放了，并且是由于它所在的 autoreleasepool 被 drain 的时候释放的。</p>

<p>你说什么就是什么咯？有本事你就证明给我看你妈是你妈。额，这个我真证明不了，不过上面的猜测我还是可以证明的，不信，你看！</p>

<p>在开始前，我先简单地说明一下原理，我们可以通过使用 <code>lldb</code> 的 <code>watchpoint</code> 命令来设置观察点，观察全局变量 <code>string_weak_</code> 的值的变化，<code>string_weak_</code> 变量保存的就是我们创建的 autoreleased 对象的地址。在这里，我们再次利用了 <code>__weak</code> 变量的另外一个特性，就是当它所指向的对象被释放时，<code>__weak</code> 变量的值会被置为 <code>nil</code> 。了解了基本原理后，我们开始验证上面的猜测。</p>

<p>我们先在第 35 行打一个断点，当程序运行到这个断点时，我们通过 <code>lldb</code> 命令 <code>watchpoint set v string_weak_</code> 设置观察点，观察 <code>string_weak_</code> 变量的值的变化。如下图所示，我们将在 console 中看到类似的输出，说明我们已经成功地设置了一个观察点：</p>

<p><img src="http://blog.leichunfeng.com/images/watchpoint1.jpg" title="设置观察点" alt="设置观察点" /></p>

<p>设置好观察点后，点击 <code>Continue program execution</code> 按钮，继续运行程序，我们将看到如下图所示的界面：</p>

<p><img src="http://blog.leichunfeng.com/images/watchpoint2.jpg" title="设置观察点" alt="设置观察点" /></p>

<p>我们先看 console 中的输出，注意到 <code>string_weak_</code> 变量的值由 <code>0x00007f9b886567d0</code> 变成了 <code>0x0000000000000000</code> ，也就是 <code>nil</code> 。说明此时它所指向的对象被释放了。另外，我们也可以注意到一个细节，那就是 console 中打印了两次对象的值，说明此时 <code>viewWillAppear</code> 也已经被调用了，而 <code>viewDidAppear</code> 还没有被调用。</p>

<p>接着，我们来看看左侧的线程堆栈。我们看到了一个非常敏感的方法调用 <code>-[NSAutoreleasePool release]</code> ，这个方法最终通过调用 <code>AutoreleasePoolPage::pop(void *)</code> 函数来负责对 autoreleasepool 中的 autoreleased 对象执行 release 操作。结合前面的分析，我们知道在 <code>viewDidLoad</code> 中创建的 autoreleased 对象在方法返回后引用计数为 1 ，所以经过这里的 release 操作后，这个对象的引用计数 -1 ，变成了 0 ，该 autoreleased 对象最终被释放，猜测得证。</p>

<p>另外，值得一提的是，我们在代码中并没有手动添加 autoreleasepool ，那这个 autoreleasepool 究竟是哪里来的呢？看完后面的章节你就明白了。</p>

<p><strong>场景 2</strong>：同理，当通过 <code>[NSString stringWithFormat:@"leichunfeng"]</code> 创建一个对象时，这个对象的引用计数为 1 。而当使用局部变量 <code>string</code> 指向这个对象时，这个对象的引用计数 +1 ，变成了 2 。而出了当前作用域时，局部变量 <code>string</code> 变成了 <code>nil</code> ，所以其所指向对象的引用计数变成 1 。另外，我们知道当出了 <code>@autoreleasepool {}</code> 的作用域时，当前 autoreleasepool 被 drain ，其中的 autoreleased 对象被 release 。所以这个对象的引用计数变成了 0 ，对象最终被释放。</p>

<p><strong>场景 3</strong>：同理，当出了 <code>@autoreleasepool {}</code> 的作用域时，其中的 autoreleased 对象被 release ，对象的引用计数变成 1 。当出了局部变量 <code>string</code> 的作用域，即 <code>viewDidLoad</code> 方法返回时，<code>string</code> 指向了 <code>nil</code> ，其所指向对象的引用计数变成 0 ，对象最终被释放。</p>

<p>理解在这 3 种场景下，autoreleased 对象什么时候释放对我们理解 Objective-C 的内存管理机制非常有帮助。其中，场景 1 出现得最多，就是不需要我们手动添加 <code>@autoreleasepool {}</code> 的情况，直接使用系统维护的 autoreleasepool ；场景 2 就是需要我们手动添加 <code>@autoreleasepool {}</code> 的情况，手动干预 autoreleased 对象的释放时机；场景 3 是为了区别场景 2 而引入的，在这种场景下并不能达到出了 <code>@autoreleasepool {}</code> 的作用域时 autoreleased 对象被释放的目的。</p>

<p><strong>PS</strong>：请读者参考场景 1 的分析过程，使用 <code>lldb</code> 命令 <code>watchpoint</code> 自行验证下在场景 2 和场景 3 下 autoreleased 对象的释放时机，you should give it a try yourself 。</p>

<h2>AutoreleasePoolPage</h2>

<p>细心的读者应该已经有所察觉，我们在上面已经提到了 <code>-[NSAutoreleasePool release]</code> 方法最终是通过调用 <code>AutoreleasePoolPage::pop(void *)</code> 函数来负责对 autoreleasepool 中的 autoreleased 对象执行 release 操作的。</p>

<p>那这里的 AutoreleasePoolPage 是什么东西呢？其实，autoreleasepool 是没有单独的内存结构的，它是通过以 AutoreleasePoolPage 为结点的<strong>双向链表</strong>来实现的。我们打开 runtime 的源码工程，在 <code>NSObject.mm</code> 文件的第 438-932 行可以找到 autoreleasepool 的实现源码。通过阅读源码，我们可以知道：</p>

<ul>
<li>每一个线程的 autoreleasepool 其实就是一个指针的堆栈；</li>
<li>每一个指针代表一个需要 release 的对象或者 POOL_SENTINEL（哨兵对象，代表一个 autoreleasepool 的边界）；</li>
<li>一个 pool token 就是这个 pool 所对应的 POOL_SENTINEL 的内存地址。当这个 pool 被 pop 的时候，所有内存地址在 pool token 之后的对象都会被 release ；</li>
<li>这个堆栈被划分成了一个以 page 为结点的双向链表。pages 会在必要的时候动态地增加或删除；</li>
<li>Thread-local storage（线程局部存储）指向 hot page ，即最新添加的 autoreleased 对象所在的那个 page 。</li>
</ul>


<p>一个空的 AutoreleasePoolPage 的内存结构如下图所示：</p>

<p><img src="http://blog.leichunfeng.com/images/AutoreleasePoolPage.png" title="AutoreleasePoolPage" alt="AutoreleasePoolPage" /></p>

<ol>
<li><code>magic</code> 用来校验 AutoreleasePoolPage 的结构是否完整；</li>
<li><code>next</code> 指向最新添加的 autoreleased 对象的下一个位置，初始化时指向 <code>begin()</code> ；</li>
<li><code>thread</code> 指向当前线程；</li>
<li><code>parent</code> 指向父结点，第一个结点的 parent 值为 <code>nil</code> ；</li>
<li><code>child</code> 指向子结点，最后一个结点的 child 值为 <code>nil</code> ；</li>
<li><code>depth</code> 代表深度，从 0 开始，往后递增 1；</li>
<li><code>hiwat</code> 代表 high water mark 。</li>
</ol>


<p>另外，当 <code>next == begin()</code> 时，表示 AutoreleasePoolPage 为空；当 <code>next == end()</code> 时，表示 AutoreleasePoolPage 已满。</p>

<h3>Autorelease Pool Blocks</h3>

<p>我们使用 <code>clang -rewrite-objc</code> 命令将下面的 Objective-C 代码重写成 C++ 代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>将会得到以下输出结果（只保留了相关代码）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kr">__declspec</span><span class="p">(</span><span class="n">dllimport</span><span class="p">)</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">objc_autoreleasePoolPush</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kr">__declspec</span><span class="p">(</span><span class="n">dllimport</span><span class="p">)</span> <span class="kt">void</span> <span class="n">objc_autoreleasePoolPop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">__AtAutoreleasePool</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">__AtAutoreleasePool</span><span class="p">()</span> <span class="p">{</span><span class="n">atautoreleasepoolobj</span> <span class="o">=</span> <span class="n">objc_autoreleasePoolPush</span><span class="p">();}</span>
</span><span class='line'>  <span class="o">~</span><span class="n">__AtAutoreleasePool</span><span class="p">()</span> <span class="p">{</span><span class="n">objc_autoreleasePoolPop</span><span class="p">(</span><span class="n">atautoreleasepoolobj</span><span class="p">);}</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span> <span class="n">atautoreleasepoolobj</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* @autoreleasepool */</span> <span class="p">{</span> <span class="n">__AtAutoreleasePool</span> <span class="n">__autoreleasepool</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>不得不说，苹果对 <code>@autoreleasepool {}</code> 的实现真的是非常巧妙，真正可以称得上是代码的艺术。苹果通过声明一个 <code>__AtAutoreleasePool</code> 类型的局部变量 <code>__autoreleasepool</code> 来实现 <code>@autoreleasepool {}</code> 。当声明 <code>__autoreleasepool</code> 变量时，构造函数 <code>__AtAutoreleasePool()</code> 被调用，即执行 <code>atautoreleasepoolobj = objc_autoreleasePoolPush();</code> ；当出了当前作用域时，析构函数 <code>~__AtAutoreleasePool()</code> 被调用，即执行 <code>objc_autoreleasePoolPop(atautoreleasepoolobj);</code> 。也就是说 <code>@autoreleasepool {}</code> 的实现代码可以进一步简化如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cm">/* @autoreleasepool */</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">void</span> <span class="o">*</span><span class="n">atautoreleasepoolobj</span> <span class="o">=</span> <span class="n">objc_autoreleasePoolPush</span><span class="p">();</span>
</span><span class='line'>    <span class="c1">// 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 autoreleasepool 中</span>
</span><span class='line'>    <span class="n">objc_autoreleasePoolPop</span><span class="p">(</span><span class="n">atautoreleasepoolobj</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，单个 autoreleasepool 的运行过程可以简单地理解为 <code>objc_autoreleasePoolPush()</code>、<code>[对象 autorelease]</code> 和 <code>objc_autoreleasePoolPop(void *)</code> 三个过程。</p>

<h3>push 操作</h3>

<p>上面提到的 <code>objc_autoreleasePoolPush()</code> 函数本质上就是调用的 AutoreleasePoolPage 的 push 函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="o">*</span>
</span><span class='line'><span class="nf">objc_autoreleasePoolPush</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">UseGC</span><span class="p">)</span> <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">AutoreleasePoolPage</span><span class="o">::</span><span class="n">push</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>因此，我们接下来看看 AutoreleasePoolPage 的 push 函数的作用和执行过程。一个 push 操作其实就是创建一个新的 autoreleasepool ，对应 AutoreleasePoolPage 的具体实现就是往 AutoreleasePoolPage 中的 <code>next</code> 位置插入一个 POOL_SENTINEL ，并且返回插入的 POOL_SENTINEL 的内存地址。这个地址也就是我们前面提到的 pool token ，在执行 pop 操作的时候作为函数的入参。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">push</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">id</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">autoreleaseFast</span><span class="p">(</span><span class="n">POOL_SENTINEL</span><span class="p">);</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">dest</span> <span class="o">==</span> <span class="n">POOL_SENTINEL</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">dest</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>push 函数通过调用 <code>autoreleaseFast</code> 函数来执行具体的插入操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">id</span> <span class="o">*</span><span class="nf">autoreleaseFast</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">AutoreleasePoolPage</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">hotPage</span><span class="p">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">autoreleaseFullPage</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">autoreleaseNoPage</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>autoreleaseFast</code> 函数在执行一个具体的插入操作时，分别对三种情况进行了不同的处理：</p>

<ol>
<li>当前 page 存在且没有满时，直接将对象添加到当前 page 中，即 <code>next</code> 指向的位置；</li>
<li>当前 page 存在且已满时，创建一个新的 page ，并将对象添加到新创建的 page 中；</li>
<li>当前 page 不存在时，即还没有 page 时，创建第一个 page ，并将对象添加到新创建的 page 中。</li>
</ol>


<p>每调用一次 push 操作就会创建一个新的 autoreleasepool ，即往 AutoreleasePoolPage 中插入一个 POOL_SENTINEL ，并且返回插入的 POOL_SENTINEL 的内存地址。</p>

<h3>autorelease 操作</h3>

<p>通过 <code>NSObject.mm</code> 源文件，我们可以找到 <code>-autorelease</code> 方法的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">autorelease</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">((</span><span class="kt">id</span><span class="p">)</span><span class="nb">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rootAutorelease</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过查看 <code>((id)self)-&gt;rootAutorelease()</code> 的方法调用，我们发现最终调用的就是 AutoreleasePoolPage 的 <code>autorelease</code> 函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">__attribute__</span><span class="p">((</span><span class="n">noinline</span><span class="p">,</span><span class="n">used</span><span class="p">))</span>
</span><span class='line'><span class="kt">id</span>
</span><span class='line'><span class="n">objc_object</span><span class="o">::</span><span class="n">rootAutorelease2</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">isTaggedPointer</span><span class="p">());</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">AutoreleasePoolPage</span><span class="o">::</span><span class="n">autorelease</span><span class="p">((</span><span class="kt">id</span><span class="p">)</span><span class="n">this</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>AutoreleasePoolPage 的 <code>autorelease</code> 函数的实现对我们来说就比较容量理解了，它跟 push 操作的实现非常相似。只不过 push 操作插入的是一个 POOL_SENTINEL ，而 autorelease 操作插入的是一个具体的 autoreleased 对象。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">id</span> <span class="nf">autorelease</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">isTaggedPointer</span><span class="p">());</span>
</span><span class='line'>    <span class="kt">id</span> <span class="o">*</span><span class="n">dest</span> <span class="n">__unused</span> <span class="o">=</span> <span class="n">autoreleaseFast</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">dest</span>  <span class="o">||</span>  <span class="o">*</span><span class="n">dest</span> <span class="o">==</span> <span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>pop 操作</h3>

<p>同理，前面提到的 <code>objc_autoreleasePoolPop(void *)</code> 函数本质上也是调用的 AutoreleasePoolPage 的 <code>pop</code> 函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="nf">objc_autoreleasePoolPop</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ctxt</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">UseGC</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// fixme rdar://9167170</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctxt</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">AutoreleasePoolPage</span><span class="o">::</span><span class="n">pop</span><span class="p">(</span><span class="n">ctxt</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>pop 函数的入参就是 push 函数的返回值，也就是 POOL_SENTINEL 的内存地址，即 pool token 。当执行 pop 操作时，内存地址在 pool token 之后的所有 autoreleased 对象都会被 release 。直到 pool token 所在 page 的 <code>next</code> 指向 pool token 为止。</p>

<p>下面是某个线程的 autoreleasepool 堆栈的内存结构图，在这个 autoreleasepool 堆栈中总共有两个 POOL_SENTINEL ，即有两个 autoreleasepool 。该堆栈由三个 AutoreleasePoolPage 结点组成，第一个 AutoreleasePoolPage 结点为 <code>coldPage()</code> ，最后一个 AutoreleasePoolPage 结点为 <code>hotPage()</code> 。其中，前两个结点已经满了，最后一个结点中保存了最新添加的 autoreleased 对象 <code>objr3</code> 的内存地址。</p>

<p><img src="http://blog.leichunfeng.com/images/AutoreleasePoolPage1.png" title="AutoreleasePoolPage1" alt="AutoreleasePoolPage1" /></p>

<p>此时，如果执行 <code>pop(token1)</code> 操作，那么该 autoreleasepool 堆栈的内存结构将会变成如下图所示：</p>

<p><img src="http://blog.leichunfeng.com/images/AutoreleasePoolPage2.png" title="AutoreleasePoolPage2" alt="AutoreleasePoolPage2" /></p>

<h2>NSThread、NSRunLoop 和 NSAutoreleasePool</h2>

<p>根据苹果官方文档中对 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/doc/constant_group/Run_Loop_Modes">NSRunLoop</a> 的描述，我们可以知道每一个线程，包括主线程，都会拥有一个专属的 NSRunLoop 对象，并且会在有需要的时候自动创建。</p>

<blockquote><p>Each NSThread object, including the application’s main thread, has an NSRunLoop object automatically created for it as needed.</p></blockquote>

<p>同样的，根据苹果官方文档中对 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html#//apple_ref/doc/uid/TP40003623">NSAutoreleasePool</a> 的描述，我们可知，在主线程的 NSRunLoop 对象（在系统级别的其他线程中应该也是如此，比如通过 dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) 获取到的线程）的每个 event loop 开始前，系统会自动创建一个 autoreleasepool ，并在 event loop 结束时 drain 。我们上面提到的场景 1 中创建的 autoreleased 对象就是被系统添加到了这个自动创建的 autoreleasepool 中，并在这个 autoreleasepool 被 drain 时得到释放。</p>

<blockquote><p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</p></blockquote>

<p>另外，NSAutoreleasePool 中还提到，每一个线程都会维护自己的 autoreleasepool 堆栈。换句话说 autoreleasepool 是与线程紧密相关的，每一个 autoreleasepool 只对应一个线程。</p>

<blockquote><p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.</p></blockquote>

<p>弄清楚 NSThread、NSRunLoop 和 NSAutoreleasePool 三者之间的关系可以帮助我们从整体上了解 Objective-C 的内存管理机制，清楚系统在背后到底为我们做了些什么，理解整个运行机制等。</p>

<h2>总结</h2>

<p>看到这里，相信你应该对 Objective-C 的内存管理机制有了更进一步的认识。通常情况下，我们是不需要手动添加 autoreleasepool 的，使用线程自动维护的 autoreleasepool 就好了。根据苹果官方文档中对 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI">Using Autorelease Pool Blocks</a> 的描述，我们知道在下面三种情况下是需要我们手动添加 autoreleasepool 的：</p>

<ol>
<li>如果你编写的程序不是基于 UI 框架的，比如说命令行工具；</li>
<li>如果你编写的循环中创建了大量的临时对象；</li>
<li>如果你创建了一个辅助线程。</li>
</ol>


<p>最后，希望本文能对你有所帮助，have fun ！</p>

<h2>参考链接</h2>

<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">http://blog.sunnyxx.com/2014/10/15/behind-autorelease/</a>
<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">http://clang.llvm.org/docs/AutomaticReferenceCounting.html</a>
<a href="http://www.yifeiyang.net/development-of-the-iphone-simply-3/">http://www.yifeiyang.net/development-of-the-iphone-simply-3/</a></p>

<p><strong>版权声明</strong>：我已将本文在微信公众平台的发表权「独家代理」给 iOS 开发（iOSDevTips）微信公众号。扫下方二维码即可关注「iOS 开发」：</p>

<p><img src="http://blog.devtang.com/images/weixin-qr.jpg" alt="iOS 开发二维码" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C Category 的实现原理]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/05/18/objective-c-category-implementation-principle/"/>
    <updated>2015-05-18T00:20:57+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/05/18/objective-c-category-implementation-principle</id>
    <content type="html"><![CDATA[<p>对设计模式有一定了解的朋友应该听说过装饰模式，Objective-C 中的 Category 就是对装饰模式的一种具体实现。它的主要作用是在不改变原有类的前提下，动态地给这个类添加一些方法。在 Objective-C 中的具体体现为：实例（类）方法、属性和协议。是的，在 Objective-C 中可以用 Category 来实现协议。本文将结合 <a href="http://opensource.apple.com/tarballs/objc4/">runtime</a>（我下载的是当前的最新版本 <code>objc4-646.tar.gz</code>) 的源码来探究它实现的原理。</p>

<h2>使用场景</h2>

<p>根据苹果官方文档对 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1">Category</a> 的描述，它的使用场景主要有三个：</p>

<ol>
<li>给现有的类添加方法；</li>
<li>将一个类的实现拆分成多个独立的源文件；</li>
<li>声明私有的方法。</li>
</ol>


<p>其中，第 <code>1</code> 个是最典型的使用场景，应用最广泛。</p>

<p><strong>注</strong>：Category 有一个非常容易误用的场景，那就是用 Category 来覆写父类或主类的方法。虽然目前 Objective-C 是允许这么做的，但是这种使用场景是<strong>非常</strong>不推荐的。<a href="http://stackoverflow.com/questions/5272451/overriding-methods-using-categories-in-objective-c">使用 Category 来覆写方法</a>有很多缺点，比如不能覆写 Category 中的方法、无法调用主类中的原始实现等，且很容易造成无法预估的行为。</p>

<h2>实现原理</h2>

<p>我们知道，无论我们有没有主动引入 Category 的头文件，Category 中的方法都会被添加进主类中。我们可以通过 <code>- performSelector:</code> 等方式对 Category 中的相应方法进行调用，之所以需要在调用的地方引入 Category 的头文件，只是为了“照顾”编译器同学的感受。</p>

<p>下面，我们将结合 runtime 的源码探究下 Category 的实现原理。打开 runtime 源码工程，在文件 <code>objc-runtime-new.mm</code> 中找到以下函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">_read_images</span><span class="p">(</span><span class="n">header_info</span> <span class="o">**</span><span class="n">hList</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hCount</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>        <span class="n">_free_internal</span><span class="p">(</span><span class="n">resolvedFutureClasses</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Discover categories. </span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">EACH_HEADER</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">category_t</span> <span class="o">**</span><span class="n">catlist</span> <span class="o">=</span>
</span><span class='line'>            <span class="n">_getObjc2CategoryList</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="kt">category_t</span> <span class="o">*</span><span class="n">cat</span> <span class="o">=</span> <span class="n">catlist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>            <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">remapClass</span><span class="p">(</span><span class="n">cat</span><span class="o">-&gt;</span><span class="n">cls</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// Category&#39;s target class is missing (probably weak-linked).</span>
</span><span class='line'>                <span class="c1">// Disavow any knowledge of this category.</span>
</span><span class='line'>                <span class="n">catlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">PrintConnecting</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span>
</span><span class='line'>                                 <span class="s">&quot;missing weak-linked target class&quot;</span><span class="p">,</span>
</span><span class='line'>                                 <span class="n">cat</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cat</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// Process this category. </span>
</span><span class='line'>            <span class="c1">// First, register the category with its target class. </span>
</span><span class='line'>            <span class="c1">// Then, rebuild the class&#39;s method lists (etc) if </span>
</span><span class='line'>            <span class="c1">// the class is realized. </span>
</span><span class='line'>            <span class="kt">BOOL</span> <span class="n">classExists</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">cat</span><span class="o">-&gt;</span><span class="n">instanceMethods</span> <span class="o">||</span>  <span class="n">cat</span><span class="o">-&gt;</span><span class="n">protocols</span>
</span><span class='line'>                <span class="o">||</span>  <span class="n">cat</span><span class="o">-&gt;</span><span class="n">instanceProperties</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">addUnattachedCategoryForClass</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">cls</span><span class="p">,</span> <span class="n">hi</span><span class="p">);</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isRealized</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">remethodizeClass</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
</span><span class='line'>                    <span class="n">classExists</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">PrintConnecting</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&quot;CLASS: found category -%s(%s) %s&quot;</span><span class="p">,</span>
</span><span class='line'>                                 <span class="n">cls</span><span class="o">-&gt;</span><span class="n">nameForLogging</span><span class="p">(),</span> <span class="n">cat</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
</span><span class='line'>                                 <span class="n">classExists</span> <span class="o">?</span> <span class="s">&quot;on existing class&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">cat</span><span class="o">-&gt;</span><span class="n">classMethods</span>  <span class="o">||</span>  <span class="n">cat</span><span class="o">-&gt;</span><span class="n">protocols</span>
</span><span class='line'>                <span class="cm">/* ||  cat-&gt;classProperties */</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">addUnattachedCategoryForClass</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">ISA</span><span class="p">(),</span> <span class="n">hi</span><span class="p">);</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">ISA</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isRealized</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">remethodizeClass</span><span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">ISA</span><span class="p">());</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">PrintConnecting</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&quot;CLASS: found category +%s(%s)&quot;</span><span class="p">,</span>
</span><span class='line'>                                 <span class="n">cls</span><span class="o">-&gt;</span><span class="n">nameForLogging</span><span class="p">(),</span> <span class="n">cat</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Category discovery MUST BE LAST to avoid potential races </span>
</span><span class='line'>    <span class="c1">// when other threads call the new category code before </span>
</span><span class='line'>    <span class="c1">// this thread finishes its fixups.</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// +load handled by prepare_load_methods()</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从第 27-58 行的关键代码，我们可以知道在这个函数中对 Category 做了如下处理：</p>

<ol>
<li>将 Category 和它的主类（或元类）注册到哈希表中；</li>
<li>如果主类（或元类）已实现，那么重建它的方法列表。</li>
</ol>


<p>在这里分了两种情况进行处理：Category 中的实例方法和属性被整合到主类中；而类方法则被整合到元类中（关于对象、类和元类的更多细节，可以参考我前面的博文<a href="http://blog.leichunfeng.com/blog/2015/04/25/objective-c-object-model/">《Objective-C 对象模型》</a>）。另外，对协议的处理比较特殊，Category 中的协议被同时整合到了主类和元类中。</p>

<p>我们注意到，不管是哪种情况，最终都是通过调用 <code>static void remethodizeClass(Class cls)</code> 函数来重新整理类的数据的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">remethodizeClass</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>                         <span class="n">cls</span><span class="o">-&gt;</span><span class="n">nameForLogging</span><span class="p">(),</span> <span class="n">isMeta</span> <span class="o">?</span> <span class="s">&quot;(meta)&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Update methods, properties, protocols</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">attachCategoryMethods</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">cats</span><span class="p">,</span> <span class="nb">YES</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">newproperties</span> <span class="o">=</span> <span class="n">buildPropertyList</span><span class="p">(</span><span class="nb">nil</span><span class="p">,</span> <span class="n">cats</span><span class="p">,</span> <span class="n">isMeta</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">newproperties</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">newproperties</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">properties</span><span class="p">;</span>
</span><span class='line'>            <span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">properties</span> <span class="o">=</span> <span class="n">newproperties</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">newprotos</span> <span class="o">=</span> <span class="n">buildProtocolList</span><span class="p">(</span><span class="n">cats</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">protocols</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">protocols</span>  <span class="o">&amp;&amp;</span>  <span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">protocols</span> <span class="o">!=</span> <span class="n">newprotos</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">_free_internal</span><span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">protocols</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">protocols</span> <span class="o">=</span> <span class="n">newprotos</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">_free_internal</span><span class="p">(</span><span class="n">cats</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数的主要作用是将 Category 中的方法、属性和协议整合到类（主类或元类）中，更新类的数据字段 <code>data()</code> 中 <code>method_lists（或 method_list）</code>、<code>properties</code> 和 <code>protocols</code> 的值。进一步，我们通过 <code>attachCategoryMethods</code> 函数的源码可以找到真正处理 Category 方法的 <code>attachMethodLists</code> 函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span>
</span><span class='line'><span class="nf">attachMethodLists</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">method_list_t</span> <span class="o">**</span><span class="n">addedLists</span><span class="p">,</span> <span class="kt">int</span> <span class="n">addedCount</span><span class="p">,</span>
</span><span class='line'>                  <span class="kt">bool</span> <span class="n">baseMethods</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">methodsFromBundle</span><span class="p">,</span>
</span><span class='line'>                  <span class="kt">bool</span> <span class="n">flushCaches</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>        <span class="n">newLists</span><span class="p">[</span><span class="n">newCount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mlist</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Copy old methods to the method list array</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oldCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">newLists</span><span class="p">[</span><span class="n">newCount</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldLists</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">oldLists</span>  <span class="o">&amp;&amp;</span>  <span class="n">oldLists</span> <span class="o">!=</span> <span class="n">oldBuf</span><span class="p">)</span> <span class="n">free</span><span class="p">(</span><span class="n">oldLists</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// nil-terminate</span>
</span><span class='line'>    <span class="n">newLists</span><span class="p">[</span><span class="n">newCount</span><span class="p">]</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">newCount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">assert</span><span class="p">(</span><span class="n">newLists</span> <span class="o">!=</span> <span class="n">newBuf</span><span class="p">);</span>
</span><span class='line'>        <span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">method_lists</span> <span class="o">=</span> <span class="n">newLists</span><span class="p">;</span>
</span><span class='line'>        <span class="n">cls</span><span class="o">-&gt;</span><span class="n">setInfo</span><span class="p">(</span><span class="n">RW_METHOD_ARRAY</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">assert</span><span class="p">(</span><span class="n">newLists</span> <span class="o">==</span> <span class="n">newBuf</span><span class="p">);</span>
</span><span class='line'>        <span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">method_list</span> <span class="o">=</span> <span class="n">newLists</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RW_METHOD_ARRAY</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数的代码量看上去比较多，但是我们并不难理解它的目的。它的主要作用就是将类中的旧有方法和 Category 中新添加的方法整合成一个新的方法列表，并赋值给 <code>method_lists</code> 或 <code>method_list</code> 。通过探究这个处理过程，我们也印证了一个结论，那就是主类中的方法和 Category 中的方法在 runtime 看来并没有区别，它们是被同等对待的，都保存在主类的方法列表中。</p>

<p>不过，类的方法列表字段有一点特殊，它的结构是联合体，<code>method_lists</code> 和 <code>method_list</code> 共用同一块内存地址。当 <code>newCount</code> 的个数大于 1 时，使用 <code>method_lists</code> 来保存 <code>newLists</code> ，并将方法列表的<strong>标志位</strong>置为 <code>RW_METHOD_ARRAY</code> ，此时类的方法列表字段是 <code>method_list_t</code> 类型的指针数组；否则，使用 <code>method_list</code> 来保存 <code>newLists</code> ，并将方法列表的<strong>标志位</strong>置空，此时类的方法列表字段是 <code>method_list_t</code> 类型的指针。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// class&#39;s method list is an array of method lists</span>
</span><span class='line'><span class="cp">#define RW_METHOD_ARRAY       (1&lt;&lt;20)</span>
</span><span class='line'>
</span><span class='line'><span class="k">union</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">method_list_t</span> <span class="o">**</span><span class="n">method_lists</span><span class="p">;</span>  <span class="c1">// RW_METHOD_ARRAY == 1</span>
</span><span class='line'>    <span class="kt">method_list_t</span> <span class="o">*</span><span class="n">method_list</span><span class="p">;</span>    <span class="c1">// RW_METHOD_ARRAY == 0</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>看过我上一篇博文<a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/">《Objective-C +load vs +initialize》</a>的朋友可能已经有所察觉了。我们注意到 runtime 对 Category 中方法的处理过程并没有对 +load 方法进行什么特殊地处理。因此，严格意义上讲 Category 中的 +load 方法跟普通方法一样也会对主类中的 +load 方法造成覆盖，只不过 runtime 在自动调用主类和 Category 中的 +load 方法时是直接使用各自方法的指针进行调用的。所以才会使我们觉得主类和 Category 中的 +load 方法好像互不影响一样。因此，当我们手动给主类发送 +load 消息时，调用的一直会是分类中的 +load 方法，you should give it a try yourself 。</p>

<h2>总结</h2>

<p>Category 是 Objective-C 中非常强大的技术之一，使用得当的话可以给我们的开发带来极大的便利。很多著名的开源库或多或少都会通过给系统类添加 Category 的方式提供强大功能，比如 <a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a> 、<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> 、 <a href="https://github.com/rs/SDWebImage">SDWebImage</a> 等。但是凡事有利必有弊，正因为 Category 非常强大，所以一旦误用就很可能会造成非常严重的后果。比如覆写系统类的方法，这是 iOS 开发新手经常会犯的一个错误，不管在任何情况下，切记一定不要这么做，No zuo no die 。</p>

<h2>参考链接</h2>

<p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1">https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1</a>
<a href="http://stackoverflow.com/questions/5272451/overriding-methods-using-categories-in-objective-c">http://stackoverflow.com/questions/5272451/overriding-methods-using-categories-in-objective-c</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C +load vs +initialize]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/"/>
    <updated>2015-05-02T17:06:15+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize</id>
    <content type="html"><![CDATA[<p>在上一篇博文<a href="http://blog.leichunfeng.com/blog/2015/04/25/objective-c-object-model/">《Objective-C 对象模型》</a>中，我们知道了 Objective-C 中绝大部分的类都继承自 NSObject 类。而在 NSObject 类中有两个非常特殊的类方法 +load 和 +initialize ，用于类的初始化。这两个看似非常简单的类方法在许多方面会让人感到困惑，比如：</p>

<ol>
<li>子类、父类、分类中的相应方法什么时候会被调用？</li>
<li>需不需要在子类的实现中显式地调用父类的实现？</li>
<li>每个方法到底会被调用多少次？</li>
</ol>


<p>下面，我们将结合 <a href="http://opensource.apple.com/tarballs/objc4/">runtime</a>（我下载的是当前的最新版本 <code>objc4-646.tar.gz</code>) 的源码，一起来揭开它们的神秘面纱。</p>

<h2>+load</h2>

<p>+load 方法是当类或分类被添加到 Objective-C runtime 时被调用的，实现这个方法可以让我们在类加载的时候执行一些类相关的行为。子类的 +load 方法会在它的所有父类的 +load 方法之后执行，而分类的 +load 方法会在它的主类的 +load 方法之后执行。但是不同的类之间的 +load 方法的调用顺序是不确定的。</p>

<p>打开 runtime 工程，我们接下来看看与 +load 方法相关的几个关键函数。首先是文件 <code>objc-runtime-new.mm</code> 中的 <code>void prepare_load_methods(header_info *hi)</code> 函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">prepare_load_methods</span><span class="p">(</span><span class="n">header_info</span> <span class="o">*</span><span class="n">hi</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">rwlock_assert_writing</span><span class="p">(</span><span class="o">&amp;</span><span class="n">runtimeLock</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">classref_t</span> <span class="o">*</span><span class="n">classlist</span> <span class="o">=</span>
</span><span class='line'>        <span class="n">_getObjc2NonlazyClassList</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">schedule_class_load</span><span class="p">(</span><span class="n">remapClass</span><span class="p">(</span><span class="n">classlist</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">category_t</span> <span class="o">**</span><span class="n">categorylist</span> <span class="o">=</span> <span class="n">_getObjc2NonlazyCategoryList</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">category_t</span> <span class="o">*</span><span class="n">cat</span> <span class="o">=</span> <span class="n">categorylist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">remapClass</span><span class="p">(</span><span class="n">cat</span><span class="o">-&gt;</span><span class="n">cls</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>  <span class="c1">// category for ignored weak-linked class</span>
</span><span class='line'>        <span class="n">realizeClass</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
</span><span class='line'>        <span class="n">assert</span><span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">ISA</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isRealized</span><span class="p">());</span>
</span><span class='line'>        <span class="n">add_category_to_loadable_list</span><span class="p">(</span><span class="n">cat</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>顾名思义，这个函数的作用就是提前准备好满足 +load 方法调用条件的类和分类，以供接下来的调用。其中，在处理类时，调用了同文件中的另外一个函数 <code>static void schedule_class_load(Class cls)</code> 来执行具体的操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">schedule_class_load</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isRealized</span><span class="p">());</span>  <span class="c1">// _read_images should realize</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">RW_LOADED</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Ensure superclass-first ordering</span>
</span><span class='line'>    <span class="n">schedule_class_load</span><span class="p">(</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">superclass</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">add_class_to_loadable_list</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cls</span><span class="o">-&gt;</span><span class="n">setInfo</span><span class="p">(</span><span class="n">RW_LOADED</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中，函数第 9 行代码对入参的父类进行了递归调用，以确保父类优先的顺序。<code>void prepare_load_methods(header_info *hi)</code> 函数执行完后，当前所有满足 +load 方法调用条件的类和分类就被分别存放在全局变量 <code>loadable_classes</code> 和 <code>loadable_categories</code> 中了。</p>

<p>准备好类和分类后，接下来就是对它们的 +load 方法进行调用了。打开文件 <code>objc-loadmethod.m</code> ，找到其中的 <code>void call_load_methods(void)</code> 函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">call_load_methods</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">BOOL</span> <span class="n">loading</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">more_categories</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">recursive_mutex_assert_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loadMethodLock</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Re-entrant calls do nothing; the outermost call will finish the job.</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">loading</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="n">loading</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="n">objc_autoreleasePoolPush</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 1. Repeatedly call class +loads until there aren&#39;t any more</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span><span class="n">loadable_classes_used</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">call_class_loads</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 2. Call category +loads ONCE</span>
</span><span class='line'>        <span class="n">more_categories</span> <span class="o">=</span> <span class="n">call_category_loads</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 3. Run more +loads if there are classes OR more untried categories</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">loadable_classes_used</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="o">||</span>  <span class="n">more_categories</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">objc_autoreleasePoolPop</span><span class="p">(</span><span class="n">pool</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">loading</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样的，这个函数的作用就是调用上一步准备好的类和分类中的 +load 方法，并且确保类优先于分类的顺序。我们继续查看在这个函数中调用的另外两个关键函数 <code>static void call_class_loads(void)</code> 和 <code>static BOOL call_category_loads(void)</code> 。由于这两个函数的作用大同小异，下面就以篇幅较小的 <code>static void call_class_loads(void)</code> 函数为例进行探讨。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">call_class_loads</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Detach current loadable list.</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">loadable_class</span> <span class="o">*</span><span class="n">classes</span> <span class="o">=</span> <span class="n">loadable_classes</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">used</span> <span class="o">=</span> <span class="n">loadable_classes_used</span><span class="p">;</span>
</span><span class='line'>    <span class="n">loadable_classes</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="n">loadable_classes_allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">loadable_classes_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Call all +loads for the detached list.</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">used</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">classes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cls</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">load_method_t</span> <span class="n">load_method</span> <span class="o">=</span> <span class="p">(</span><span class="kt">load_method_t</span><span class="p">)</span><span class="n">classes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">method</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">PrintLoading</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&quot;LOAD: +[%s load]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">nameForLogging</span><span class="p">());</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="p">(</span><span class="o">*</span><span class="n">load_method</span><span class="p">)(</span><span class="n">cls</span><span class="p">,</span> <span class="n">SEL_load</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Destroy the detached list.</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">classes</span><span class="p">)</span> <span class="n">_free_internal</span><span class="p">(</span><span class="n">classes</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数的作用就是真正负责调用类的 +load 方法了。它从全局变量 <code>loadable_classes</code> 中取出所有可供调用的类，并进行清零操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">loadable_classes</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="n">loadable_classes_allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">loadable_classes_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中 <code>loadable_classes</code> 指向用于保存类信息的内存的首地址，<code>loadable_classes_allocated</code> 标识已分配的内存空间大小，<code>loadable_classes_used</code> 则标识已使用的内存空间大小。</p>

<p>然后，循环调用所有类的 +load 方法。<strong>注意</strong>，这里是（调用分类的 +load 方法也是如此）直接使用函数内存地址的方式 <code>(*load_method)(cls, SEL_load);</code> 对 +load 方法进行调用的，而不是使用发送消息 <code>objc_msgSend</code> 的方式。</p>

<p>这样的调用方式就使得 +load 方法拥有了一个非常有趣的特性，那就是子类、父类和分类中的 +load 方法的实现是被区别对待的。也就是说如果子类没有实现 +load 方法，那么当它被加载时 runtime 是不会去调用父类的 +load 方法的。同理，当一个类和它的分类都实现了 +load 方法时，两个方法都会被调用。因此，我们常常可以利用这个特性做一些“邪恶”的事情，比如说方法混淆（<a href="http://nshipster.com/method-swizzling/">Method Swizzling</a>）。</p>

<h2>+initialize</h2>

<p>+initialize 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。也就是说 +initialize 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize 方法是永远不会被调用的。那这样设计有什么好处呢？好处是显而易见的，那就是节省系统资源，避免浪费。</p>

<p>同样的，我们还是结合 runtime 的源码来加深对 +initialize 方法的理解。打开文件 <code>objc-runtime-new.mm</code> ，找到以下函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">IMP</span> <span class="nf">lookUpImpOrForward</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">sel</span><span class="p">,</span> <span class="kt">id</span> <span class="n">inst</span><span class="p">,</span>
</span><span class='line'>                       <span class="kt">bool</span> <span class="n">initialize</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">cache</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">resolver</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>        <span class="n">rwlock_unlock_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">runtimeLock</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">initialize</span>  <span class="o">&amp;&amp;</span>  <span class="o">!</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isInitialized</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">_class_initialize</span> <span class="p">(</span><span class="n">_class_getNonMetaClass</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">inst</span><span class="p">));</span>
</span><span class='line'>        <span class="c1">// If sel == initialize, _class_initialize will send +initialize and </span>
</span><span class='line'>        <span class="c1">// then the messenger will send +initialize again after this </span>
</span><span class='line'>        <span class="c1">// procedure finishes. Of course, if this is not being called </span>
</span><span class='line'>        <span class="c1">// from the messenger then it won&#39;t happen. 2778172</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// The lock is held to make method-lookup + cache-fill atomic </span>
</span><span class='line'>    <span class="c1">// with respect to method addition. Otherwise, a category could </span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当我们给某个类发送消息时，runtime 会调用这个函数在类中查找相应方法的实现或进行消息转发。从第 8-14 的关键代码我们可以看出，当类没有初始化时 runtime 会调用 <code>void _class_initialize(Class cls)</code> 函数对该类进行初始化。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">_class_initialize</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="kt">Class</span> <span class="n">supercls</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">reallyInitialize</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Make sure super is done initializing BEFORE beginning to initialize cls.</span>
</span><span class='line'>    <span class="c1">// See note about deadlock above.</span>
</span><span class='line'>    <span class="n">supercls</span> <span class="o">=</span> <span class="n">cls</span><span class="o">-&gt;</span><span class="n">superclass</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">supercls</span>  <span class="o">&amp;&amp;</span>  <span class="o">!</span><span class="n">supercls</span><span class="o">-&gt;</span><span class="n">isInitialized</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">_class_initialize</span><span class="p">(</span><span class="n">supercls</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Try to atomically set CLS_INITIALIZING.</span>
</span><span class='line'>    <span class="n">monitor_enter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">classInitLock</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isInitialized</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cls</span><span class="o">-&gt;</span><span class="n">isInitializing</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">cls</span><span class="o">-&gt;</span><span class="n">setInitializing</span><span class="p">();</span>
</span><span class='line'>        <span class="n">reallyInitialize</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">monitor_exit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">classInitLock</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">reallyInitialize</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// We successfully set the CLS_INITIALIZING bit. Initialize the class.</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Record that we&#39;re initializing this class so we can message it.</span>
</span><span class='line'>        <span class="n">_setThisThreadIsInitializingClass</span><span class="p">(</span><span class="n">cls</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Send the +initialize message.</span>
</span><span class='line'>        <span class="c1">// Note that +initialize is sent to the superclass (again) if </span>
</span><span class='line'>        <span class="c1">// this class doesn&#39;t implement +initialize. 2157218</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">PrintInitializing</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&quot;INITIALIZE: calling +[%s initialize]&quot;</span><span class="p">,</span>
</span><span class='line'>                         <span class="n">cls</span><span class="o">-&gt;</span><span class="n">nameForLogging</span><span class="p">());</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">((</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">Class</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))</span><span class="n">objc_msgSend</span><span class="p">)(</span><span class="n">cls</span><span class="p">,</span> <span class="n">SEL_initialize</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">PrintInitializing</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">_objc_inform</span><span class="p">(</span><span class="s">&quot;INITIALIZE: finished +[%s initialize]&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中，第 7-12 行代码对入参的父类进行了递归调用，以确保父类优先于子类初始化。另外，最关键的是第 36 行代码（暴露了 +initialize 方法的本质），runtime 使用了发送消息 <code>objc_msgSend</code> 的方式对 +initialize 方法进行调用。也就是说 +initialize 方法的调用与普通方法的调用是一样的，走的都是发送消息的流程。换言之，如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 +initialize 方法，那么就会对这个类中的实现造成覆盖。</p>

<p>因此，如果一个子类没有实现 +initialize 方法，那么父类的实现是会被执行多次的。有时候，这可能是你想要的；但如果我们想确保自己的 +initialize 方法只执行一次，避免多次执行可能带来的副作用时，我们可以使用下面的代码来实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">initialize</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="nb">self</span> <span class="o">==</span> <span class="p">[</span><span class="n">ClassName</span> <span class="nb">self</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ... do the initialization ...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>通过阅读 runtime 的源码，我们知道了 +load 和 +initialize 方法实现的细节，明白了它们的调用机制和各自的特点。下面我们绘制一张表格，以更加直观的方式来巩固我们对它们的理解：</p>

<p>
    <table border="1" width="100%">
        <tr>
            <th></th>        
            <th>+load</th>        
            <th>+initialize</th>        
        </tr>
        <tr>
            <td>调用时机</td>        
            <td>被添加到 runtime 时</td>        
            <td>收到第一条消息前，可能永远不调用</td>        
        </tr>
        <tr>
            <td>调用顺序</td>        
            <td>父类->子类->分类</td>        
            <td>父类->子类</td>        
        </tr>
        <tr>
            <td>调用次数</td>        
            <td>1次</td>        
            <td>多次</td>        
        </tr>
        <tr>
            <td>是否需要显式调用父类实现</td>        
            <td>否</td>        
            <td>否</td>        
        </tr>
        <tr>
            <td>是否沿用父类的实现</td>        
            <td>否</td>        
            <td>是</td>        
        </tr>
        <tr>
            <td>分类中的实现</td>        
            <td>类和分类都执行</td>        
            <td>覆盖类中的方法，只执行分类的实现</td>        
        </tr>
    </table>
</p>


<h2>参考链接</h2>

<ul>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.html">https://www.mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.html</a></li>
<li><a href="http://blog.iderzheng.com/objective-c-load-vs-initialize/">http://blog.iderzheng.com/objective-c-load-vs-initialize/</a></li>
<li><a href="http://nshipster.com/method-swizzling/">http://nshipster.com/method-swizzling/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C 对象模型]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/04/25/objective-c-object-model/"/>
    <updated>2015-04-25T19:38:02+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/04/25/objective-c-object-model</id>
    <content type="html"><![CDATA[<p>Objective-C 是一门面向对象的程序设计语言，它的对象模型是基于类来建立的。我们可以在苹果开源的 <a href="http://opensource.apple.com/tarballs/objc4/">runtime</a>（我下载的是当前的最新版本 <code>objc4-646.tar.gz</code> ）中发现 Objective-C 对象模型的实现细节。</p>

<h2>对象</h2>

<p>在 Objective-C 中，每一个对象都是某个类的实例，且这个对象的 <code>isa</code>（在 64 位 CPU 下，<code>isa</code> 已经不再是一个简单的指针，在本文中我们暂且把它当作普通指针来理解，后面我会单独写一篇博文来详细介绍 <code>Non-pointer isa</code> ）指针指向它所属的类。</p>

<p>打开刚下载的 runtime 工程，在文件 <code>objc-private.h</code> 的第 127-232 行我们可以找到 Objective-C 中的对象的定义 <code>struct objc_object</code> 。是的，Objective-C 中的对象本质上是结构体对象，其中 <code>isa</code> 是它唯一的私有成员变量。</p>

<p><img src="http://leichunfeng.github.io/images/objc_object.jpg" title="Objective-C 对象的定义" alt="Objective-C 对象的定义"></p>

<p>在同一个文件的第 51-52 行我们可以找到 <code>Class</code> 和 <code>id</code> 类型的定义，它们分别是 <code>struct objc_class</code> 和 <code>struct objc_object</code> 类型的指针。这也是为什么 <code>id</code> 类型可以指向任意对象的原因。其中 <code>struct objc_class</code> 就是 Objective-C 中的类的定义，在下一节将会详细介绍。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">objc_class</span> <span class="o">*</span><span class="kt">Class</span><span class="p">;</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">objc_object</span> <span class="o">*</span><span class="kt">id</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>类</h2>

<p>对象的类不仅描述了对象的数据：对象占用的内存大小、成员变量的类型和布局等，而且也描述了对象的行为：对象能够响应的消息、实现的实例方法等。因此，当我们调用实例方法 <code>[receiver message]</code> 给一个对象发送消息时，这个对象能否响应这个消息就需要通过 <code>isa</code> 找到它所属的类（当然还有 superclass，本文主要内容不是这个，所以不展开）才能知道。</p>

<p>打开文件 <code>objc-runtime-new.h</code> ，在第 687-902 行我们可以找到 Objective-C 中的类的定义 <code>struct objc_class</code> 。同样的，Objective-C 中类也是一个结构体对象，并且继承了 <code>struct objc_object</code> 。</p>

<p><img src="http://leichunfeng.github.io/images/objc_class.jpg" title="Objective-C 类的定义" alt="Objective-C 类的定义"></p>

<p>所以，Objective-C 中的类本质上也是对象，我们称之为类对象。按照我们前面所说的所有的对象都是某个类的实例，那么类对象又是什么类的实例呢？答案就是我们将在下一节介绍的元类。</p>

<p>在 Objective-C 中有一个非常特殊的类 <code>NSObject</code> ，绝大部分的类都继承自它。它是 Objective-C 中的两个根类（rootclass）之一，另外一个是 NSProxy（本文不讨论）。同样的，我们打开文件 <code>NSObject.h</code> ，可以看到 <code>NSObject</code> 类其实就只有一个成员变量 <code>isa</code> ，所有继承自 <code>NSObject</code> 的类也都会有这个成员变量。</p>

<p><img src="http://leichunfeng.github.io/images/nsobject.jpg" title="NSObject 类" alt="NSObject 类"></p>

<h2>元类</h2>

<p>我们上面提到，本质上 Objective-C 中的类也是对象，它也是某个类的实例，这个类我们称之为元类（metaclass）。</p>

<p>因此，我们也可以通过调用类方法，比如 <code>[NSObject new]</code>，给类对象发送消息。同样的，类对象能否响应这个消息也要通过 <code>isa</code> 找到类对象所属的类（元类）才能知道。也就是说，实例方法是保存在类中的，而类方法是保存在元类中的。</p>

<p>那元类也是对象吗？是的话那它又是什么类的实例呢？是的，没错，元类也是对象（元类对象），元类也是某个类的实例，这个类我们称之为根元类（root metaclass）。不过，有一点比较特殊，那就是所有的元类所属的类都是同一个根元类（当然根元类也是元类，所以它所属的类也是根元类，即它本身）。根元类指的就是根类的元类，具体来说就是根类 <code>NSObject</code> 对应的元类。</p>

<p>因此，理论上我们也可以给元类发送消息，但是 Objective-C 倾向于隐藏元类，不想让大家知道元类的存在。元类是为了保持 Objective-C 对象模型在设计上的完整性而引入的，比如用来保存类方法等，它主要是用来给编译器使用的。</p>

<p>说了这么多，大家可能已经有点绕迷糊了，下面我们看一张图，一切自会明了。</p>

<p><img src="http://leichunfeng.github.io/images/object_model.png" title="Objective-C 对象模型" alt="Objective-C 对象模型"></p>

<h2>参考链接</h2>

<ul>
<li><a href="http://www.devtang.com/blog/2013/10/15/objective-c-object-model/">http://www.devtang.com/blog/2013/10/15/objective-c-object-model/</a></li>
<li><a href="http://husbandman.diandian.com/post/2012-08-17/40036035008">http://husbandman.diandian.com/post/2012-08-17/40036035008</a></li>
<li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[结合 Reveal 谈谈 MBProgressHUD 的用法]]></title>
    <link href="http://leichunfeng.github.io/blog/2015/03/16/talking-about-the-usage-of-mbprogresshud-combined-with-reveal/"/>
    <updated>2015-03-16T12:32:51+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2015/03/16/talking-about-the-usage-of-mbprogresshud-combined-with-reveal</id>
    <content type="html"><![CDATA[<p>我的博客已经好几个月没有更新了，想想还真是有些难过。究其原因主要是工作占用了我绝大部分的时间，包含工作日的晚上和大部分周末。剩余的很小部分空余时间，我都用来开发个人 iOS 应用 GitBucket 了。</p>

<p>GitBucket 是一个 GitHub 的 iOS 客户端，使用 <a href="http://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM</a> 模式和 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">RAC</a> 框架进行开发。目前 GitBucket 的项目代码 <a href="https://github.com/leichunfeng/MVVMReactiveCocoa">MVVMReactiveCocoa</a> 已经在 GitHub 上开源了出来。开发这个应用的主要目的是希望提供一个使用 MVVM 模式和 RAC 框架开发的完整应用，能够对学习 MVVM 模式和 RAC 框架的 iOS 开发者有所帮助。昨天，我已经向 App Store 提交了 GitBucket v1.0 版本，相信很快大家就可以下载使用了。</p>

<p>言归正传，接下来我们结合 <a href="http://revealapp.com/">Reveal</a> 来谈谈 <a href="https://github.com/jdg/MBProgressHUD">MBProgressHUD</a> 的用法。这里主要讨论的是什么情况下导航栏上的按钮可用，什么情况下不可用，及其原因。</p>

<p><strong>注</strong>：本博文的程序代码可以在 <a href="https://github.com/leichunfeng/MBProgressHUD">leichunfeng/MBProgressHUD</a> 上找到，读者可以克隆下来亲自运行下看看效果。</p>

<h2>关于 self.navigationController.view</h2>

<p>相信看过 MBProgressHUD 官方例子 <code>HudDemo</code> 代码的同学应该看到过下述代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">HUD</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MBProgressHUD</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithView</span><span class="p">:</span><span class="nb">self</span><span class="p">.</span><span class="n">navigationController</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>当时，你可能会对 <code>self.navigationController.view</code> 有些疑惑，这是什么玩意？其实，如果我们查看下 <code>UINavigationController.h</code> 文件就会发现，<code>UINavigationController</code> 其实是继承自 <code>UIViewController</code> 的，那么它拥有 <code>view</code> 属性也就不奇怪了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NS_CLASS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">2</span><span class="n">_0</span><span class="p">)</span> <span class="k">@interface</span> <span class="bp">UINavigationController</span> : <span class="bp">UIViewController</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面，我们会结合 Reveal 清楚地看到 <code>self.navigationController.view</code> 到底是什么东西，稍安勿躁。</p>

<h2>显示 MBProgressHUD</h2>

<p>初始化 MBProgressHUD 时需要我们传入一个 <code>UIView</code> 类型的参数 <code>view</code>，而显示 MBProgressHUD 的原理其实就是用 <code>addSubview</code> 方法将 MBProgressHUD 添加为这个 <code>view</code> 的子视图。</p>

<p>我们先来看看未显示 MBProgressHUD 时，应用的视图层次结构。其中 1 为 <code>UIWindow</code> ，即 <code>self.view.window</code>，2 是 <code>UINavigationController</code> 的 <code>view</code> ，即我们前面提到的 <code>self.navigationController.view</code> ，3 为 <code>self.view</code> ，4 为导航栏 <code>UINavigationBar</code> ，即 <code>self.navigationController.navigationBar</code> 。</p>

<p><img src="http://leichunfeng.github.io/images/show-mbprogresshud.jpg" title="应用的视图层次结构" alt="应用的视图层次结构"></p>

<p>通过这张图，我们清楚地看到了 <code>self.view.window</code> 、<code>self.navigationController.view</code> 、<code>self.view</code> 和 <code>self.navigationController.navigationBar</code> 在应用的视图层次中所处的位置，以及它们之间的层次关系。</p>

<p>下面，我们就对比一下 MBProgressHUD 分别在 <code>self.view.window</code> 、<code>self.navigationController.view</code> 和 <code>self.view</code> 上显示时应用的视图层次结构，以及导航栏上按钮的可用情况。</p>

<h3>方式 1 - On self.view.window</h3>

<p>使用这种方式时，MBProgressHUD 被添加到了 <code>self.view.window</code> 上，它与 <code>self.navigationController.view</code> 在视图层次上是平级的，同为 <code>self.view.window</code> 的子视图。但是由于 MBProgressHUD 是后添加的，所以它处于 <code>self.navigationController.view</code> 的上方，因此导航栏上的按钮均不可点击。</p>

<p><img src="http://leichunfeng.github.io/images/on-self.view.window.jpg" title="应用的视图层次结构" alt="应用的视图层次结构"></p>

<h3>方式 2 - On self.navigationController.view</h3>

<p>使用这种方式时，MBProgressHUD 被添加到了 <code>self.navigationController.view</code> 上，它与 <code>self.navigationController.navigationBar</code> 在视图层次上是平级的，同为 <code>self.navigationController.view</code> 的子视图。但是由于 MBProgressHUD 是后添加的，所以它处于 <code>self.navigationController.navigationBar</code> 的上方，因此导航栏上的按钮也均不可点击。</p>

<p><img src="http://leichunfeng.github.io/images/on-self.navigationController.view.jpg" title="应用的视图层次结构" alt="应用的视图层次结构"></p>

<h3>方式 3 - On self.view</h3>

<p>使用这种方式时，MBProgressHUD 被添加到了 <code>self.view</code> 上，不管 <code>self.view</code> 或 MBProgressHUD 是否占满整个屏幕，<code>self.navigationController.navigationBar</code> 永远处于 MBProgressHUD 的上方。因此，导航栏上的按钮一直是可点击的。</p>

<p><img src="http://leichunfeng.github.io/images/on-self.view.jpg" title="应用的视图层次结构" alt="应用的视图层次结构"></p>

<h2>总结</h2>

<p>当你需要让导航栏上的按钮不可点击的时候，可以选择使用 <code>方式 1</code> 或 <code>方式 2</code> 显示 MBProgressHUD 。反之，可以选择 <code>方式 3</code> 。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[将 Octopress 博客从 GitHub 迁移到 GitCafe]]></title>
    <link href="http://leichunfeng.github.io/blog/2014/11/15/migrate-octopress-blog-from-github-to-gitcafe/"/>
    <updated>2014-11-15T13:38:20+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2014/11/15/migrate-octopress-blog-from-github-to-gitcafe</id>
    <content type="html"><![CDATA[<p>在<a href="http://blog.leichunfeng.com/blog/2014/11/11/use-octopress-plus-github-pages-to-setup-a-personal-blog/">上一篇博文</a>中我们提到了因为 GitHub 毕竟是国外的（你懂的）代码托管网站，所以我们博客的访问速度始终还是比较慢的。因此，如果你想让你的博客访问速度有飞一般的感觉的话，那么就跟我一样将你的 Octopress 博客从 GitHub 迁移到 GitCafe 上吧！</p>

<h2>迁移原理</h2>

<p><strong>注意</strong>，这里所说的迁移并非就是要完全抛弃 GitHub ，我们不需要这么极端。而是指我们在将博客内容 <code>push</code> 到 GitHub 的时候，也顺便 <code>push</code> 一份到 GitCafe 上。然后用 GitCafe 上的那份作为我们对外的博客使用，而 GitHub 上的那份则作为备份留存。这样，当我们哪天想再用回 GitHub 的时候，只要将我们的域名重新指回 GitHub 的博客地址就可以了，反之亦然。</p>

<p>在开始之前，我想大概谈一谈迁移的原理，理解了原理后你可能都不需要看下面的迁移步骤，自己就能轻松搞定了。我们知道，Octopress 其实为我们建立了两个分支，<code>source</code> 分支充当书桌，<code>master</code> 分支则用于存放最终生成的 <code>HTML</code> 博文。但有一点我们需要特别注意，那就是 Octopress 对这两个分支的操作其实是在本地两个不同的 Git 仓库中进行的。其中，对 <code>source</code> 分支的操作在 <code>octopress</code> 仓库中进行，而对 <code>master</code> 分支的操作则在 <code>_deploy</code> 仓库中进行。因此，接下来我们需要做的就已经比较明确了，只需要给 <code>_deploy</code> 仓库添加一个新的 GitCafe 远程仓库，然后将博客内容顺道 <code>push</code> 一份到 GitCafe 上就 OK 了。</p>

<h2>准备工作</h2>

<ol>
<li>注册 <a href="http://gitcafe.com/signup?invited_by=leichunfeng">GitCafe</a> 账号。</li>
<li>添加 SSH 公钥到你的 GitCafe 账号下，可参考 GitCafe 官方帮助文档中的<a href="https://gitcafe.com/GitCafe/Help/wiki/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E5%92%8C%E8%AE%BE%E7%BD%AE-Git#wiki">《如何安装和设置 Git》</a>。</li>
<li>创建一个与你的 GitCafe 用户名相同名称的项目，例如 <a href="https://gitcafe.com/leichunfeng/leichunfeng">leichunfeng</a> 。</li>
</ol>


<h2>添加远程仓库</h2>

<p>运行以下命令，给 <code>_deploy</code> 仓库添加你的 GitCafe 仓库为新的远程仓库。记得先将 <code>git@gitcafe.com:leichunfeng/leichunfeng.git</code> 替换为你刚创建的 GitCafe 仓库的 SSH 地址。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">cd</span> <span class="n">_deploy</span>
</span><span class='line'><span class="n">git</span> <span class="n">remote</span> <span class="n">add</span> <span class="n">gitcafe</span> <span class="n">git</span><span class="vi">@gitcafe</span><span class="o">.</span><span class="n">com</span><span class="ss">:leichunfeng</span><span class="o">/</span><span class="n">leichunfeng</span><span class="o">.</span><span class="n">git</span>
</span></code></pre></td></tr></table></div></figure>


<h2>修改发布脚本</h2>

<p>为了实现在我们将博客内容 <code>push</code> 到 GitHub 的时候，也顺便 <code>push</code> 一份到 GitCafe 上，我们需要对 Octopress 的发布脚本稍作修改。这里，我们只需要在 <code>Rakefile</code> 文件中的 <code>:deploy</code> 部分添加以下三行代码就可以了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">## Pushing generated </span><span class="si">#{</span><span class="n">deploy_dir</span><span class="si">}</span><span class="s2"> website&quot;</span>
</span><span class='line'><span class="no">Bundler</span><span class="o">.</span><span class="n">with_clean_env</span> <span class="p">{</span> <span class="nb">system</span> <span class="s2">&quot;git push origin </span><span class="si">#{</span><span class="n">deploy_branch</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">}</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">## Github Pages deploy complete&quot;</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">## Pushing generated </span><span class="si">#{</span><span class="n">deploy_dir</span><span class="si">}</span><span class="s2"> website&quot;</span> <span class="c1"># 此行为新增代码</span>
</span><span class='line'><span class="no">Bundler</span><span class="o">.</span><span class="n">with_clean_env</span> <span class="p">{</span> <span class="nb">system</span> <span class="s2">&quot;git push gitcafe </span><span class="si">#{</span><span class="n">deploy_branch</span><span class="si">}</span><span class="s2">:gitcafe-pages&quot;</span> <span class="p">}</span> <span class="c1"># 此行为新增代码</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">## GitCafe Pages deploy complete&quot;</span> <span class="c1"># 此行为新增代码</span>
</span></code></pre></td></tr></table></div></figure>


<p>细心的你也许会有所发现，我们 <code>push</code> 到 GitCafe 上的远程分支名与 <code>push</code> 到 GitHub 上的远程分支名是不一样的。这是因为 GitHub 使用的是 <code>master</code> 分支来存放页面内容，而 GitCafe 则使用的是 <code>gitcafe-pages</code> 分支。不过，对这个我们不需要太过关心，知道是怎么回事就可以了，换汤不换药。</p>

<p>接下来，运行一下发布命令试试效果吧！</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="n">deploy</span>
</span></code></pre></td></tr></table></div></figure>


<h2>自定义域名</h2>

<p>GitCafe 的自定义域名设置要比 GitHub 的友好得多，它不仅提供了图形界面，而且支持给一个项目设置多个域名。进入<code>项目设置</code>界面，然后在<code>Pages 服务</code>栏目中添加你自己的域名。</p>

<p><img src="http://leichunfeng.github.io/images/gitcafe-custom-domains-new.jpg" title="GitCafe 自定义域名" alt="GitCafe 自定义域名"></p>

<p>同样的，你需要登陆你的域名注册商的管理平台，在你的域名下新增相应的 <code>A</code> 或 <code>CNAME</code> 解析记录。如果你需要将域名指向一个 <code>IPv4</code> 地址（例如：<code>leichunfeng.com</code> -> <code>207.226.141.135</code> ），则需要增加 <code>A</code> 记录；而如果你需要将域名指向另一个域名（例如：<code>blog.leichunfeng.com</code> -> <code>leichunfeng.gitcafe.io</code> ），实现与被指向域名相同的访问效果，则需要增加 <code>CNAME</code> 记录。</p>

<p><img src="http://leichunfeng.github.io/images/net-resolve-record-new.jpg" title="万网解析记录" alt="万网解析记录"></p>

<h2>添加对 GitCafe 的感谢</h2>

<p>GitCafe 是国内为数不多的做得不错的代码托管网站，目前还处于创业阶段。如果你也想跟我一样，在博客底部添加对 GitCafe 的感谢，可以通过修改 <code>source/_includes/custom/footer.html</code> 文件来实现。<strong>注意</strong>，记得将 <code>http://gitcafe.com/signup?invited_by=leichunfeng</code> 中的 <code>leichunfeng</code> 替换成你的 GitCafe 用户名。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;p&gt;</span>
</span><span class='line'>  Copyright <span class="ni">&amp;copy;</span> 2017-02-23 17:24:45 +0800 - 雷纯锋 -
</span><span class='line'>  <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">&quot;credit&quot;</span><span class="nt">&gt;</span>Powered by <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://octopress.org&quot;</span><span class="nt">&gt;</span>Octopress<span class="nt">&lt;/a&gt;&lt;/span&gt;</span>
</span><span class='line'>  <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">&quot;credit&quot;</span><span class="nt">&gt;</span> - 感谢 <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://gitcafe.com/signup?invited_by=leichunfeng&quot;</span> <span class="na">target=</span><span class="s">&quot;_blank&quot;</span><span class="nt">&gt;</span>GitCafe<span class="nt">&lt;/a&gt;</span> 为本站提供存储空间<span class="nt">&lt;/span&gt;</span>
</span><span class='line'><span class="nt">&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>至此，迁移工作就全部完成了。Enjoy ！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用 Octopress+GitHub Pages 搭建个人博客]]></title>
    <link href="http://leichunfeng.github.io/blog/2014/11/11/use-octopress-plus-github-pages-to-setup-a-personal-blog/"/>
    <updated>2014-11-11T21:47:07+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2014/11/11/use-octopress-plus-github-pages-to-setup-a-personal-blog</id>
    <content type="html"><![CDATA[<p>序言中提到周末折腾了两天时间，终于用 Octopress 成功搭建起了自己专属的技术博客，那么本文就来细说一下如何使用 Octopress+GitHub Pages 搭建个人博客。</p>

<h2>Octopress</h2>

<p><a href="http://octopress.org/">Octopress</a> 是一款基于 <a href="https://github.com/jekyll/jekyll">Jekyll</a> 的功能强大的博客框架，是对 Jekyll 的进一步封装，号称是给黑客使用的，用起来比 Jekyll 简单很多，不需要太多的设置，只需要 <a href="https://github.com/imathis/octopress">clone 或者 fork Octopress</a>，安装依赖和主题就可以了。当然，这个时候你的博客还比较粗糙，如果你想让你的博客访问速度更快，有分享和评论功能，以及每篇博文的最后都带上原文链接的话，你需要做的还比较多，不过不用担心，Follow me，我会为你娓娓道来。</p>

<h2>GitHub Pages</h2>

<p><a href="https://pages.github.com/">GitHub Pages</a> 是 GitHub 推出的用于建立用户、组织和项目站点的工具，每个 GitHub 账号和组织都可以建立一个站点以及无数个项目站点。我们要建立个人博客自然使用的是 GitHub Pages 的用户站点功能，建立用户站点非常简单，稍后我们再展开来谈。</p>

<h2>安装 Octopress</h2>

<p>前面我们提到了安装 Octopress 只需要简单的几个步骤就可以了，下面我们一步步来。</p>

<h3>准备工作</h3>

<ol>
<li>安装 <a href="http://git-scm.com/">Git</a> 。</li>
<li>安装 Ruby 1.9.3 及以上版本。</li>
</ol>


<p>你可以使用 <code>ruby --version</code> 查看一下你安装的 <code>Ruby</code> 版本，如果低于 1.9.3，你可以使用 <a href="http://octopress.org/docs/setup/rbenv/">rbenv</a> 或 <a href="http://octopress.org/docs/setup/rvm/">RVM</a> 来安装更高版本。</p>

<h3>克隆 Octopress</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">git</span> <span class="nb">clone</span> <span class="ss">git</span><span class="p">:</span><span class="sr">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">imathis</span><span class="o">/</span><span class="n">octopress</span><span class="o">.</span><span class="n">git</span> <span class="n">octopress</span>
</span><span class='line'><span class="n">cd</span> <span class="n">octopress</span>
</span></code></pre></td></tr></table></div></figure>


<h3>安装依赖</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">gem</span> <span class="n">install</span> <span class="n">bundler</span>
</span><span class='line'><span class="n">rbenv</span> <span class="n">rehash</span> <span class="c1"># 如果你使用的是 rbenv 的话，执行下这句，不是的话可以略过</span>
</span><span class='line'><span class="n">bundle</span> <span class="n">install</span>
</span></code></pre></td></tr></table></div></figure>


<h3>安装 Octopress 默认主题</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="n">install</span>
</span></code></pre></td></tr></table></div></figure>


<h3>配置 Octopress</h3>

<p>至此，你的 Octopress 就已经安装好了，接下来我们对 Octopress 进行一些简单的配置。我们需要修改的只有 <code>_config.yml</code> 一个文件，这个文件包含 <code>Main Configs</code> 、<code>Jekyll &amp; Plugins</code> 和 <code>3rd Party Settings</code> 三个部分。在这里，我们只需要修改 <code>Main Configs</code> 中的 <code>title</code> 、<code>subtitle</code> 和 <code>author</code> 。说明，后面我们会通过 Octopress 提供的 <code>rake setup_github_pages</code> 命令自动修改 <code>url</code> ，这里先不用管。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="ss">title</span><span class="p">:</span> <span class="err">雷纯锋的技术博客</span>
</span><span class='line'><span class="ss">subtitle</span><span class="p">:</span> <span class="err">记录自己学习的点滴，收获分享知识的乐趣</span>
</span><span class='line'><span class="ss">author</span><span class="p">:</span> <span class="err">雷纯锋</span>
</span></code></pre></td></tr></table></div></figure>


<h2>写博文的方法</h2>

<p>用 Octopress 写博文主要是通过执行 Octopress 提供的 <code>rake</code> 命令来完成的，下面简单介绍一下，更多的详细信息可以查看 Octopress 官方文档中的 <a href="http://octopress.org/docs/blogging/">Blogging Basics</a> 。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="n">new_post</span><span class="o">[</span><span class="s2">&quot;title&quot;</span><span class="o">]</span> <span class="c1"># 在 source/_posts 目录下创建一篇新博文</span>
</span><span class='line'><span class="n">rake</span> <span class="n">generate</span>          <span class="c1"># 生成博文到 public 目录下</span>
</span><span class='line'><span class="n">rake</span> <span class="n">watch</span>             <span class="c1"># 查看 source 和 sass 目录的变化，且有变化时重新生成博文</span>
</span><span class='line'><span class="n">rake</span> <span class="n">preview</span>           <span class="c1"># 在 http://localhost:4000/ 预览博文</span>
</span></code></pre></td></tr></table></div></figure>


<p>Octopress 博文采用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> 语法进行书写，Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，它的作用一目了然，因此你可能只需要 5-10 分钟就能快速上手。Markdown 免费编辑器非常多，我本人非常酷爱 Sublime Text ，它绝对可以称得上编辑器中的神器。所以我的博文都是使用 <a href="http://www.sublimetext.com/3">Sublime Text 3</a>+<a href="https://github.com/SublimeText-Markdown/MarkdownEditing">MarkdownEditing</a> 插件进行书写的，书写起来感觉非常惬意。这感觉美妙极了，很难用言语来表达，是我梦寐以求的书写感受，所以也<strong>强烈推荐</strong>你试一试，Who with who knows 。</p>

<h2>发布 Octopress 到 GitHub Pages</h2>

<p>首先，你需要创建一个新的 <a href="https://github.com/repositories/new">GitHub 仓库</a> ，这个仓库的名称为 <code>username.github.io</code> ，其中 <code>username</code> 为你的 GitHub 用户名，例如 <code>leichunfeng.github.io</code> 。接下来，我们使用 Octopress 提供的 <code>rake setup_github_pages</code> 命令来完成一些与 GitHub Pages 相关的配置工作，其中就包括我们前面提到的 <code>_config.yml</code> 文件中的 <code>url</code> 。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="n">setup_github_pages</span>
</span></code></pre></td></tr></table></div></figure>


<p>根据提示需要我们输入 GitHub 仓库的 URL ，拷贝我们刚刚创建的仓库的 SSH 或 HTTPS URL ，例如 <code>git@github.com:leichunfeng/leichunfeng.github.io.git</code> ，粘贴并回车。这个看似简单的 <code>rake</code> 命令其实偷偷地为我们做了很多复杂的工作，包括修改 octopress 远程仓库 origin 的名称为 octopress 、添加我们的 GitHub 仓库为新的 origin 远程仓库和配置 <code>_config.yml</code> 文件中的 <code>url</code> 等等，更多的详细信息可以查看 Octopress 官方文档中的 <a href="http://octopress.org/docs/deploying/github/">Deploying to GitHub Pages</a> 。</p>

<p>接下来，运行以下命令。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="n">generate</span>
</span><span class='line'><span class="n">rake</span> <span class="n">deploy</span> <span class="c1"># 发布博文到 GitHub Pages</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，别忘记提交你的博客源文件。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">git</span> <span class="n">add</span> <span class="o">.</span>
</span><span class='line'><span class="n">git</span> <span class="n">commit</span> <span class="o">-</span><span class="n">m</span> <span class="s1">&#39;your message&#39;</span>
</span><span class='line'><span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="n">source</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这里，我还是想大概谈一谈 Octopress 的工作原理，不然你可能也会跟我刚接触 Octopress 时一样充满疑惑。Octopress 其实为我们建立了两个分支，一个是 <code>source</code> 分支，就像我们的书桌，用于存放我们书写时需要用到的各种工具，包括原始的 markdown 文件、生成博文用的插件、主题和脚本等等。另一个是 <code>master</code> 分支，其实就是 <code>public</code> 目录中的内容，用于存放最终生成的 <code>HTML</code> 博文。当我们执行 <code>rake generate</code> 命令时，Octopress 会为我们生成 <code>HTML</code> 博文到 <code>public</code> 目录下。当执行 <code>rake deploy</code> 命令时，Octopress 则会将 <code>public</code> 目录中的内容提交并同步到 <code>GitHub Pages</code> 。建议你自己亲自对比一下运行以上命令前后 octopress 目录中文件的变化，这样可以快速地熟悉 Octopress 的工作原理。</p>

<p>到这里，你的个人博客就已经搭建成功了，你可以使用 <code>http://username.github.io</code> 来访问你的博客了，给自己一点掌声吧！不过如果你希望你的博客能够更加与众不同的话，那么我们还有一些事情需要去做，休息一会，我们继续。</p>

<h3>自定义域名</h3>

<p>如果你也跟我一样有自己的域名的话，可以使用自己的域名指向你的博客地址。首先，你需要在 <code>source</code> 目录下建立一个名为 <code>CNAME</code> 的文件，这个文件只需要一行内容，就是你自己的域名。不过需要特别注意的一点就是这个域名不要带上 <code>http(s)://</code> 网址前缀，例如我的域名 <code>blog.leichunfeng.com</code> 。最后，运行 <code>rake</code> 命令重新生成并发布博文。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">echo</span> <span class="s1">&#39;your-domain.com&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">source</span><span class="o">/</span><span class="no">CNAME</span>
</span><span class='line'><span class="c1"># 或者</span>
</span><span class='line'><span class="n">echo</span> <span class="s1">&#39;blog.your-domain.com&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">source</span><span class="o">/</span><span class="no">CNAME</span>
</span><span class='line'>
</span><span class='line'><span class="n">rake</span> <span class="n">generate</span>
</span><span class='line'><span class="n">rake</span> <span class="n">deploy</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来，你需要登陆你的域名注册商的管理平台，在你的域名下新增一条解析记录。如果你想使用子域名，例如 <code>blog.example.com</code> ，你需要新增的就是一条记录类型为 <code>CNAME</code> ，记录值为 <code>username.github.io</code> 的解析记录。如果你想使用顶级域名，例如 <code>example.com</code> ，那么你需要新增的就是一条记录类型为 <code>A</code> ，记录值为 <code>192.30.252.153</code> or <code>192.30.252.154</code> 的解析记录。大概过 1 个小时左右，你就可以使用你自己的域名来访问你的博客了。怎么样，这种感觉是不是非常美妙？</p>

<h2>高级配置</h2>

<p>如果你希望你的博客具有微博分享和评论功能的话，可以参考下<code>唐巧</code>的博文 <a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/">《象写程序一样写博客：搭建基于github的博客》</a> 中的<code>高级配置</code>章节，这里不再赘述。不过，我建议你最好在注册了<a href="http://www.uyan.cc/">友言</a>或 <a href="http://www.jiathis.com/">JiaThis</a> 的账号后再点击<code>获取代码</code>，这样获取到的代码就会带有你的 <code>uid</code> ，那么你就可以通过友言或 JiaThis 的管理后台查看你的统计数据了。</p>

<h3>优化博客的访问速度</h3>

<ol>
<li>删除或注释配置 <code>_config.yml</code> 文件中有关 <code>Twitter</code> 的部分。</li>
<li>修改 <code>source/_includes/custom/head.html</code> 文件，删除 <code>google</code> 的自定义字体。<strong>注意</strong>，如果使用注释的方式会造成最终生成出来的 <code>HTML</code> 页面的 <code>body</code>
部分也被注释。</li>
<li>修改 <code>source/_includes/head.html</code> 文件中 <code>jquery.min.js</code> 的链接地址。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>将 <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</span><span class='line'>替换为 <span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>添加原文链接</h3>

<p>给你的每篇博文最后添加上原文链接，这样不管是其他人转载或是分享你的博文，读者都能够根据原文链接轻松地访问到你的原始博文。要实现这个目的并不难，但是我不想因为这样而破坏了博文原本的结构和布局，还要让读者在阅读博文的时候毫无违和感，谁让我是一个偏执狂呢！我查看过不少这方面的博文，其中<a href="http://codemacro.com/2012/07/26/post-footer-plugin-for-octopress/">《为octopress每篇文章添加一个文章信息》</a>还算比较接近我的需求，但还不够完美，且太复杂。于是我决定自己动手实现，结果已如你所见。</p>

<ul>
<li>创建 <code>source/_includes/post/original_link.html</code> 文件，内容只有一行代码。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">echo</span> <span class="s1">&#39;&lt;br&gt;原文链接：&lt;a href=&quot;http://blog.leichunfeng.com{#{page.url}#}&quot;&gt;http://blog.leichunfeng.com{#{page.url}#}&lt;/a&gt;&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">source</span><span class="o">/</span><span class="n">_includes</span><span class="o">/</span><span class="n">post</span><span class="o">/</span><span class="n">original_link</span><span class="o">.</span><span class="n">html</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>修改 <code>source/_layouts/post.html</code> 文件，在 <code>{#% include post/categories.html %#}</code> 后面添加一行代码。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">{</span><span class="c1">#% include post/categories.html %#}</span>
</span><span class='line'><span class="p">{</span><span class="c1">#% include post/original_link.html %#} &lt;!-- 添加这一行代码 --&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意</strong>，请记得将第一步中的 <code>blog.leichunfeng.com</code> 替换成你自己的博客域名，将上述两步中的 <code>#</code> 号去掉。</p>

<p>到这里，本文就已经接近尾声了，不过我们对博客访问速度的追求仍然没有结束。因为 GitHub 毕竟是国外的（你懂的）代码托管网站，所以我们博客的访问速度始终还是比较慢的。在下一篇博文中我将向大家介绍如何<a href="http://blog.leichunfeng.com/blog/2014/11/15/migrate-octopress-blog-from-github-to-gitcafe/">《将 Octopress 博客从 GitHub 迁移到 GitCafe》</a>，到时你的博客的访问速度也会跟我的一样，飞一般的感觉。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[序言]]></title>
    <link href="http://leichunfeng.github.io/blog/2014/11/11/preface/"/>
    <updated>2014-11-11T18:49:07+08:00</updated>
    <id>http://leichunfeng.github.io/blog/2014/11/11/preface</id>
    <content type="html"><![CDATA[<p>周末折腾了两天时间，终于用 <a href="http://octopress.org/">Octopress</a> 成功搭建起了自己专属的技术博客。不过在正式开始写第一篇技术博客之前，我还是想先写一篇序言，聊一聊自己此时此刻的想法，就当作是为博客开个头吧。</p>

<p>其实，我非常羡慕那些文笔好的人，可以自由自在地用文字抒发自己的想法和情感，挥洒自如。其中，我的一个大学室友的文笔就非常不错，他在大学期间就写了一本比较受欢迎的小说 — <a href="http://www.qidian.com/Book/2279600.aspx">《魔兽法师的荣耀》</a>，让我顿时对他刮目相看，没有想到平时懒散惯了的屌丝也会有如此文艺的一面。因此，作为一直被世人所调侃的程序员中的一份子，我也一直想让自己变得文艺一点，力争摆脱屌丝的高大形象，希望能改变一点人们对程序员的世俗眼光。其中，写作应该算是一种比较优雅的方式，可以让我在自由自在表达自己情感的同时，让自己稍稍带上些文雅的气息。</p>

<p>从毕业到现在已经有近两年半的时间了，光阴稍纵即逝。期间经历了太多的事情，让我深知人生不易，且行且珍惜的道理。我是一个怀旧的人，我现在仍然时常会想起大学时美好的时光，回忆那大学生活的点滴，因为那是一种无忧远虑、不问世事的田园生活，因为那时我也有一个完整的家，因为那是我人生中的一笔非常宝贵的财富。</p>

<p>因此，我希望从现在开始能够将自己学习的点滴都用文字记录下来，因为这将是我人生中的另一笔非常宝贵的财富。虽然接下来我所要写的很多技术文章别人可能都已经写过了，但是在我看来这些都是我所亲身经历过的，每个人的理解和感悟也并不会完全一样。虽然我的文笔并不好，但是我确信我能够做到言之有物、言之有理。</p>

<p>我觉得我是幸运的，因为我在短短两年半的时间内就有机会接触到比较多的开发语言和编程知识，比如<a href="https://developer.apple.com/devcenter/ios/index.action">iOS</a>、<a href="http://developer.android.com/index.html">Android</a>、<a href="http://www.java.com/zh_CN/">Java</a>、<a href="http://www.html5.com/">HTML5</a>、<a href="http://www.appcan.cn/">AppCan</a>、<a href="http://phonegap.com/">PhoneGap</a>等。我是一个懒惰的码农，却一直在为不成为码农而不懈努力，并希望成为一名优秀的程序员。我的惰性是一直存在的，但在加入程序员队伍后变得愈发强烈，并且与日俱增。</p>

<p>因为懒得在手机上用拼音输入而学习双拼输入法，因为懒得在电脑上用全拼输入而学习五笔输入法，因为懒得写重复的代码而学习《重构 改善既有代码的设计》和《大话设计模式》，因为懒得用鼠标点击而记忆各种快捷键&hellip;但是往往后者需要花费比前者更多的时间和精力，这是多么矛盾啊。</p>

<p>虽说是技术博客，但是我想本博客所涉及到的范围应该不仅仅只是局限于程序层面，只要是我觉得有意思的东西我都会考虑写上来，比如接下来我可能会考虑写一篇《一分钟学会双拼输入法》的文章，因为已经有好些人加我QQ希望学习双拼输入法了。</p>

<p>最后，我是一个乐于分享的人，希望本博客能够作为我与读者分享和交流的一扇窗户，透过这扇窗我能够结交更多志同道合的朋友。</p>
]]></content>
  </entry>
  
</feed>
